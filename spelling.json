[
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/about.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# About React Native Firebase\n\nThe React Native Firebase project started life in late 2016 as a personal project [Mike Diarmid](https://twitter.com/mikediarmid)\nand [Elliot Hesp](https://twitter.com/elliothesp) were working on. The project gained instant popularity, allowing React Native developers\nto hook into the native services Firebase provides.\n\nDuring the first few months of its development, the repository was moved into the organization of Invertase on GitHub.\nThe organization was a collection of the personal and combined Open Source efforts Mike and Elliot had been\nworking over the past number of years. With a constant flow of feature requests, issues and contributions,\nthe library rapidly grew in popularity, achieving over 100k NPM downloads in its first 12 months of development.\n\nIn mid-2017, we were approached by Google, who offered to help ensure the projects continued support by providing direct contact with the\nFirebase team and by providing funding to ensure the project had dedicated time assigned to its upkeep.\n\nIn the 2018 Firebase Summit in Prague during the opening keynote, Google openly announced their\nworking relationship with Invertase - check it out below:\n\n<https://twitter.com/rnfirebase/status/1056839638961348608/video/1>\n\n## Future of the library\n\nThe React Native Firebase library has been a huge driving force for our knowledge and experience. Even with years of\nexperience in Open Source, JavaScript, Android and iOS, we're constantly learning and improving the library -\nwhilst focusing on the needs of the community and many users of the library. Maintaining a popular Open Source\nlibrary is hard, yet rewarding work.\n\nWith the support from the community and Google, we're pleased to announce that starting in 2019, our very own\nMike Diarmid will be working full time on the library. With the lessons we've learnt, we'll be focusing on taking the\nlibrary to a new level. Read about it [here](https://invertase.io/blog/react-native-firebase-2019).\n\nThe success and upkeep of the library would not be possible without the support and contributions from the community.\nTo date, we've had contributions from 114 members of the Open Source community on the repository to who we're very\ngrateful to, the project wouldn't be where it is without you. Special thanks to Chris Bianca\nat [CS Frequency Limited](http://invertase.link/csf-website) for their work in helping to get this project off the ground.\n\nWe'd also like to extend our thanks to our backers on Open Collective, whose contributions have made it possible to\nsustain the vast amount of time required in the upkeep of such a project.\n\nThe future of Invertase and React Native Firebase is exciting.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/enabling-multidex.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nAs more native dependencies are added to your project, it may bump you over the\n64k method limit on the Android build system. Once this limit has been reached, you will start to see the following error\nwhilst attempting to build your Android application:\n\n    Execution failed for task ':app:mergeDexDebug'.\n\nTo learn more about multidex, view the official [Android documentation](https://developer.android.com/studio/build/multidex#mdex-gradle).\n\n## Enabling Multidex\n\nThere are 3 steps involved in enabling multidex.\n\nSteps 1 and 2 tell Gradle to turn on multidex with a directive, and add new dependency.\n\nOpen the `/android/app/build.gradle` file. Under `dependencies` we need to add the module, and then enable it\nwithin the `defaultConfig`:\n\n```groovy\nandroid {\n    defaultConfig {\n        // ...\n        multiDexEnabled true // <-- ADD THIS in the defaultConfig sectino\n    }\n    // ...\n}\n\ndependencies {\n  implementation 'androidx.multidex:multidex:2.0.1'  // <-- ADD THIS DEPENDENCY\n}\n```\n\nThe 3rd step is to alter your `android/app/src/main/java/.../MainApplication.java` file to extend `MultiDexApplication` like so:\n\n```java\n// ... all your other imports here\nimport androidx.multidex.MultiDexApplication; // <-- ADD THIS IMPORT\n\n\n// Your class definition needs `extends MultiDexApplication` like below\npublic class MainApplication extends MultiDexApplication implements ReactApplication {\n```\n\nOnce added, rebuild your application: `npx react-native run-android`.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/faqs-and-tips.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nOver the years, there’s been a lot of discussions on our [GitHub](https://github.com/invertase/react-native-firebase) and [Discord](https://invertase.link/discord). Many of them have been about common problems developers face when using our package, and some of them resulted in very good advice being given.\n\nIn order to save others time and frustration, this page has been created to document some of these common problems and good pieces of advice.\nIf you come across a discussion that results in great advice that can benefit many developers, or a discussion that resolves a problem that many developers encounter, please do add it here! Someone will definitely be grateful.\n\n# FAQs\n\n### I need help with [anything regarding <= v5 of React Native Firebase]. Where could I get help with that?\n\nReact Native Firebase v5 is now deprecated and unsupported. There's been over a year's grace period provided to migrate to v6, so moving forward maintainers probably won't pay much attention to issues regarding v5. Understandably, upgrading to v6 can take some effort, but staying on v5 probably isn't a great choice for the long-term health of your project.\nLots of the breaking changes that were introduced were either due to upstream deprecations in the official SDKs, or to simply make the package more stable and more representative of how the actual SDKs work.\nThe longer you stay on v5, the more your project will be out of sync with the official SDKs, unfortunately. Couple that with the fact that it's no longer actively supported, and that's trouble looming over the horizon for your project.\n\nWe highly recommend taking the necessary pains to update to v6.\n\n### My CI build hangs at the `Running script '[CP-User] [RNFB] Core Configuration'` step.\n\nThis may be fixed by creating a `firebase.json` file at the root of your project if it's not there already. If you don't want to change any of the default React Native Firebase configurations, you can leave it empty in the following way: \n\n    {\n      \"react-native\": {\n      }\n    }\n\n# Tips\n\n-   Advice on supporting multiple environments (for example, dev, prod, maybe also staging, qa) for your React Native Firebase App: [#3504](https://github.com/invertase/react-native-firebase/issues/3504)\n-   Using [Fastlane for iOS deployment](https://docs.fastlane.tools/getting-started/ios) together with [RN Firebase Crashlytics](https://rnfirebase.io/crashlytics/usage) within CI has been observed to cause builds that hang indefinitely. Using `setup_ci(force: true)` before building the application may solve the issue.: [#3706](https://github.com/invertase/react-native-firebase/issues/3706)\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nReact Native Firebase is the officially recommended collection of packages that brings React Native support for all Firebase services on both Android and iOS apps.\n\n## Prerequisites\n\nBefore getting started, the documentation assumes you are able to create a project with React Native and that you have an active Firebase project.\nIf you do not meet these prerequisites, follow the links below:\n\n-   [Getting started with React Native](https://facebook.github.io/react-native/docs/getting-started.html)\n-   [Create a new Firebase project](https://console.firebase.google.com/)\n\n## Installation\n\nInstalling React Native Firebase requires a few steps; installing the NPM module, adding the Firebase config files &\nrebuilding your application.\n\n### 1. Install via NPM\n\nInstall the React Native Firebase \"app\" module to the root of your React Native project with NPM or Yarn:\n\n```bash\n# Using npm\nnpm install --save @react-native-firebase/app\n\n# Using Yarn\nyarn add @react-native-firebase/app\n```\n\nThe `@react-native-firebase/app` module must be installed before using any other Firebase service.\n\n### 2. Android Setup\n\nTo allow the Android app to securely connect to your Firebase project, a configuration file must be downloaded and added\nto your project.\n\n#### Generating Android credentials\n\nOn the Firebase console, add a new Android application and enter your projects details. The \"Android package name\" must match your\nlocal projects package name which can be found inside of the `manifest` tag within the `/android/app/src/main/AndroidManifest.xml`\nfile within your project.\n\n> The debug signing certificate is optional to use Firebase with your app, but is required for Dynamic Links, Invites and Phone Authentication.\n> To generate a certificate run `cd android && ./gradlew signingReport` and copy the SHA1 from the `debug` key. This generates two variant keys.\n> You can copy the 'SHA1' that belongs to the `debugAndroidTest` variant key option.\n\nDownload the `google-services.json` file and place it inside of your project at the following location: `/android/app/google-services.json`.\n\n#### Configure Firebase with Android credentials\n\nTo allow Firebase on Android to use the credentials, the `google-services` plugin must be enabled on the project. This requires modification to two\nfiles in the Android directory.\n\nFirst, add the `google-services` plugin as a dependency inside of your `/android/build.gradle` file:\n\n```groovy\nbuildscript {\n  dependencies {\n    // ... other dependencies\n    classpath 'com.google.gms:google-services:4.2.0'\n    // Add me --- /\\\n  }\n}\n```\n\nLastly, execute the plugin by adding the following to your `/android/app/build.gradle` file:\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'com.google.gms.google-services' // <- Add this line\n```\n\n### 3. iOS Setup\n\nTo allow the iOS app to securely connect to your Firebase project, a configuration file must be downloaded and added to your project.\n\n#### Generating iOS credentials\n\nOn the Firebase console, add a new iOS application and enter your projects details. The \"iOS bundle ID\" must match your\nlocal project bundle ID. The bundle ID can be found within the \"General\" tab when opening the project with Xcode.\n\nDownload the `GoogleService-Info.plist` file.\n\nUsing Xcode, open the projects `/ios/{projectName}.xcodeproj` file (or `/ios/{projectName}.xcworkspace` if using Pods).\n\nRight click on the project name and \"Add files\" to the project, as demonstrated below:\n\n![Add files via Xcode](https://images.prismic.io/invertase/717983c0-63ca-4b6b-adc5-31318422ab47_add-files-via-xcode.png?auto=format)\n\nSelect the downloaded `GoogleService-Info.plist` file from your computer, and ensure the \"Copy items if needed\" checkbox is enabled.\n\n![Select 'Copy Items if needed'](https://prismic-io.s3.amazonaws.com/invertase%2F7d37e0ce-3e79-468d-930c-b7dc7bc2e291_unknown+%282%29.png)\n\n#### Configure Firebase with iOS credentials\n\nTo allow Firebase on iOS to use the credentials, the Firebase iOS SDK must be configured during the bootstrap phase of your application.\n\nTo do this, open your `/ios/{projectName}/AppDelegate.m` file, and add the following:\n\nAt the top of the file, import the Firebase SDK:\n\n    #import <Firebase.h>\n\nWithin your existing `didFinishLaunchingWithOptions` method, add the following to the top of the method:\n\n    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n      // Add me --- \\/\n      if ([FIRApp defaultApp] == nil) {\n        [FIRApp configure];\n      }\n      // Add me --- /\\\n      // ...\n    }\n\n### 4. Autolinking & rebuilding\n\nOnce the above steps have been completed, the React Native Firebase library must be linked to your project and your application needs to be rebuilt.\n\nUsers on React Native 0.60+ automatically have access to \"[autolinking](https://github.com/react-native-community/cli/blob/master/docs/autolinking.md)\",\nrequiring no further manual installation steps. To automatically link the package, rebuild your project:\n\n```bash\n# Android apps\nnpx react-native run-android\n\n# iOS apps\ncd ios/\npod install --repo-update\ncd ..\nnpx react-native run-ios\n```\n\nOnce successfully linked and rebuilt, your application will be connected to Firebase using the `@react-native-firebase/app` module. This module does not provide much functionality, therefore to use other Firebase services; each of the modules for the individual Firebase services need installing separately.\n\n#### Manual Linking\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/install-ios) and [Android](/install-android).\n\n* * *\n\n## Miscellaneous\n\n### Android Enabling Multidex\n\nAs your application starts to grow with more native dependencies, your builds may start to fail with the common\n`Execution failed for task ':app:mergeDexDebug'` error. This error occurs when Android reaches the\n[64k methods](https://developer.android.com/studio/build/multidex) limit.\n\nOne common solution is to [enable multidex](/enabling-multidex) support for Android. This is a common solution to solving\nthe problem, however it is recommended you read the Android documentation to understand how it may impact your application.\n\n### Hermes Support\n\nAt this time, React Native Firebase does not support the [Hermes](https://hermesengine.dev/) JavaScript engine due to\ncompatibility issues. We are actively tracking the changes to Hermes and will ensure support once both are compatible\nwith each other.\n\n### Overriding Native SDK Versions\n\nReact Native Firebase internally sets the versions of the native SDKs which each module uses. Each release of the library\nis tested against a fixed set of SDK versions (e.g. Firebase SDKs), allowing us to be confident that every feature the\nlibrary supports is working as expected.\n\nSometimes it's required to change these versions to play nicely with other React Native libraries; therefore we allow\nmanually overriding these native SDK versions.\n\n> Using your own SDK versions is generally not recommended as it can lead to breaking changes in your application. Proceed with caution.\n\n#### Android\n\nWithin your projects /android/app/build.gradle file, provide your own versions by specifying any of the following options shown below:\n\n```groovy\nproject.ext {\n  set('react-native', [\n    versions: [\n      // Overriding Build/Android SDK Versions\n      android : [\n        minSdk    : 16,\n        targetSdk : 28,\n        compileSdk: 28,\n        buildTools: \"28.0.3\"\n      ],\n\n      // Overriding Library SDK Versions\n      firebase: [\n        // Override Firebase SDK Version\n        bom           : \"21.1.0\"\n      ],\n    ],\n  ])\n}\n```\n\nOnce changed, rebuild your application with `npx react-native run-android`.\n\n#### iOS\n\nOpen your projects `/ios/Podfile` and add any of the globals shown below to the top of the file:\n\n```ruby\n# Override Firebase SDK Version\n$FirebaseSDKVersion = '6.13.0'\n```\n\nOnce changed, reinstall your projects pods via pod install and rebuild your project with `npx react-native run-ios`.\n\n### Increasing Android build memory\n\nAs you add more Firebase modules, there is an incredible demand placed on the Android build system, and the default memory\nsettings will not work. To avoid `OutOfMemory` errors during Android builds, you should uncomment the alternate Gradle memory\nsetting present in `/android/gradle.properties`:\n\n    # Specifies the JVM arguments used for the daemon process.\n    # The setting is particularly useful for tweaking memory settings.\n    # Default value: -Xmx10248m -XX:MaxPermSize=256m\n    org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8\n\n### Allow iOS Static Frameworks\n\nIf you are using Static Frameworks on iOS, you need to manually enable this for the project. To enable Static Framework\nsupport, add the following global to the top of your `/ios/Podfile` file:\n\n```ruby\n$RNFirebaseAsStaticFramework = true\n```\n\n### Expo\n\nExpo does not support integration with native modules via it's [\"Managed workflow\"](https://docs.expo.io/versions/latest/introduction/managed-vs-bare/#managed-workflow). Integration is only possible when used with the [\"Bare workflow\"](https://docs.expo.io/versions/latest/introduction/managed-vs-bare/#bare-workflow).\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/install-android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_app'\nproject(':@react-native-firebase_app').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/app/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Firebase module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_app\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.app.ReactNativeFirebaseAppPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseAppPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/install-ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Add the Pod\n\nAdd the `RNFBApp` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  #  ...\n  pod 'RNFBApp', :path => '../node_modules/@react-native-firebase/app'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBApp` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/migrating-to-v6.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Introduction\n\nThis is a reference for upgrading from React Native Firebase v5.x.x to v6.x.x. Even though there is a lot to cover,\neach module generally follows similar steps to migrate.\n\nWe highly recommend your project is using React Native 0.60+ before upgrading to take advantage of new features to make\nthe migration process much simpler.\n\n> We highly recommend backing up your project before migrating!\n\nIf you're looking to start fresh, check out the [Getting Started](/) section of the documentation.\n\n## Why you should migrate\n\nReact Native Firebase version 6 has been re-created from the ground up, with a heavy focus on testing, documentation & feature\ncompatibility with the Firebase SDKs. We've also been working closely with the Firebase team to ensure all module APIs have\nbeen approved before being released.\n\nWe have also ensured the release is compatible with some of the popular tooling in the React Native community, such as\n[autolinking](https://github.com/react-native-community/cli/blob/master/docs/autolinking.md) & [TypeScript](https://facebook.github.io/react-native/blog/2018/05/07/using-typescript-with-react-native).\n\nVersion 6 also brings support for previously unsupported modules such as [Firebase ML Kit](https://firebase.google.com/docs/ml-kit).\n\n## NPM dependency changes\n\nPrior to version 6, all modules are installable from the `react-native-firebase` NPM package. With version 6 we are\nnow taking advantage of NPM organizations, allowing us to distribute each module as its own package. This has a number\nof advantages such as smaller app bundle sizes (you only install what modules you need), and internally we treat each module\nas its own package, allowing for easier testing and quality assurance. Every project must install the `@react-native-firebase/app`\nmodule, replacing the `react-native-firebase` module.\n\n## Removing `react-native-firebase`\n\nThere are a number of steps to carry out to remove the `react-native-firebase` module from your existing app. To help make this process\neasier, we'll break out the process into 3 sections:\n\n-   [Removing v5 from JavaScript](#removing-v5-from-javascript)\n-   [Removing v5 from Android](#removing-v5-from-android)\n-   [Removing v5 from iOS](#removing-v5-from-ios)\n\n* * *\n\n### Removing v5 from JavaScript\n\nAs mentioned above, we need to remove the `react-native-firebase` NPM module from our project. To do this, open your projects\n`package.json` file and remove the dependency:\n\n```diff\n{\n  \"dependencies\": {\n    \"react\": \"16.8.3\",\n    \"react-native\": \"0.59.9\",\n-   \"react-native-firebase\": \"^5.5.4\"\n  }\n}\n```\n\nTo remove the package from your local environment, delete the `yarn.lock`/`package-lock.json` files and reinstall\nthe project dependencies with `yarn`.\n\n* * *\n\n### Removing v5 from Android\n\nRemoving version 5 from your native Android code is a more involved process. We'll go file by file to ensure all references\nto the older version have been removed.\n\n#### Removing from Gradle Settings\n\nOpen up your projects `/android/settings.gradle` file. There will be 2 lines which need to be removed:\n\n```diff\nrootProject.name = 'AwesomeApp'\n- include ':react-native-firebase'\n- project(':react-native-firebase').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-firebase/android')\n\ninclude ':app'\n```\n\n#### Removing native dependencies\n\nWe now need to remove the RNFirebase and Firebase dependencies from your project.\nIn version 6, these are automatically installed for us.\n\nOpen your projects `/android/app/build.gradle` file. First remove the `react-native-firebase` dependency:\n\n```diff\ndependencies {\n-   implementation project(path: ':react-native-firebase')\n}\n```\n\nNext, remove the `firebase-core` and `play-services-base` dependencies. Note, other modules you are using may\nrequired `play-services-base` to be installed.\n\n_Specific versions listed may be different than your own project_\n\n```diff\ndependencies {\n-   implementation \"com.google.firebase:firebase-core:16.0.9\"\n-   implementation \"com.google.android.gms:play-services-base:16.1.0\"\n}\n```\n\nNext we need to remove the module specific Firebase dependencies. The naming convention for these modules is:\n`implementation \"com.google.firebase:firebase-<< module >>:<<version>>\"`.\n\nFor example, to remove the native Firebase dependency for the Authentication module:\n\n```diff\ndependencies {\n-   implementation \"com.google.firebase:firebase-auth:17.0.0\"\n}\n```\n\n#### Removing the React Native Firebase packages\n\nWe now need to remove the React Native Firebase packages from being added to our React Native application. Go ahead and open\nthe `/android/app/src/main/java/<< app name >>/MainApplication.java` file.\n\nFirst, we need to remove the core `RNFirebasePackage` from the imports and being added to the package list:\n\n```diff\n-   import io.invertase.firebase.RNFirebasePackage;\n```\n\n```diff\n    @Override\n    protected List<ReactPackage> getPackages() {\n      return Arrays.<ReactPackage>asList(\n        new MainReactPackage(),\n-       new RNFirebasePackage(),\n```\n\nDepending on what modules you installed using version 5, remove the packages for each module. For example, to remove the\nAuthentication package:\n\n```diff\n-   import io.invertase.firebase.auth.RNFirebaseAuthPackage;\n```\n\n```diff\n    @Override\n    protected List<ReactPackage> getPackages() {\n      return Arrays.<ReactPackage>asList(\n        new MainReactPackage(),\n-       new RNFirebaseAuthPackage(),\n```\n\n#### Cleaning Gradle\n\nAndroid caches module dependencies for quicker builds. As we've heavily modified our project dependencies it's recommended you\nclean Gradle, allowing for a fresh installation. In your project, execute the following commands:\n\n```bash\n$ cd android/\n$ ./gradlew clean\n```\n\n* * *\n\n### Removing v5 from iOS\n\nThe following steps assume you have used CocoaPods to manage your projects iOS dependencies.\n\n#### Remove the RNFirebase Pod\n\nRemove the `RNFirebase` pod from your `/ios/Podfile`:\n\n```diff\ntarget 'AwesomeApp' do\n-   pod 'RNFirebase', :path => '../node_modules/react-native-firebase/ios'\n```\n\n#### Remove the Firebase Core Pod\n\nThe `Firebase/Core` need to be removed from the project. In version 6, this is automatically installed. Open the\n`/ios/Podfile` and remove the Pod:\n\n```diff\ntarget 'AwesomeApp' do\n-   pod 'Firebase/Core', '~> 6.3.0'\n```\n\n#### Remove module specific Pods\n\nDepending on what modules you were using with version 5, we now need to remove the Firebase Pods. For example, if you\nare using the Authentication module, remove the `Firebase/Auth` Pod:\n\n```diff\ntarget 'AwesomeApp' do\n-   pod 'Firebase/Auth', '~> 6.3.0'\n```\n\n### Re-installing Pods\n\nOnce the Pod dependencies have been removed, the following commands will remove the Pods from your local project:\n\n```bash\n$ cd ios\n$ rm -rf Podfile.lock\n$ pod install\n```\n\n* * *\n\n## Installing `@react-native-firebase/app`\n\nAs mentioned earlier, version 6 uses the `@react-native-firebase` NPM organization for each module. Every app using\nversion 6 must install the `app` module before installing each specific module.\n\nTo get started, install the new dependency with [Yarn](https://yarnpkg.com/lang/en/):\n\n```bash\nyarn add @react-native-firebase/app\n```\n\nIf you are using React Native 0.60+, the module will be automatically linked via [autolinking](https://github.com/react-native-community/cli/blob/master/docs/autolinking.md).\n\nUsers on an older version of React Native must manually link the `app` module. See the following steps for [Android](/v6/app/android) and\n[iOS](/v6/app/ios) for more information on manual linking.\n\n## Specific module installation\n\nDepending on which Firebase service your app uses, you now need to install the NPM packages for each service. For example,\napps using the Authentication module need to install the `auth` package:\n\n```bash\nyarn add @react-native-firebase/auth\n```\n\nInstall the modules required for your application:\n\n| Module                                                       | NPM Package                                |\n| ------------------------------------------------------------ | ------------------------------------------ |\n| <Anchor href=\"v6/admob\">AdMob</Anchor>                       | @react-native-firebase/admob               |\n| <Anchor href=\"v6/analytics\">Analytics</Anchor>               | @react-native-firebase/analytics           |\n| <Anchor href=\"v6/app\">App</Anchor>                           | @react-native-firebase/app                 |\n| <Anchor href=\"v6/invites\">App Invites</Anchor>               | @react-native-firebase/invites             |\n| <Anchor href=\"v6/auth\">Authentication</Anchor>               | @react-native-firebase/auth                |\n| <Anchor href=\"v6/firestore\">Cloud Firestore</Anchor>         | @react-native-firebase/firestore           |\n| <Anchor href=\"v6/functions\">Cloud Functions</Anchor>         | @react-native-firebase/functions           |\n| <Anchor href=\"v6/messaging\">Cloud Messaging</Anchor>         | @react-native-firebase/messaging           |\n| <Anchor href=\"v6/storage\">Cloud Storage</Anchor>             | @react-native-firebase/storage             |\n| <Anchor href=\"v6/crashlytics\">Crashlytics</Anchor>           | @react-native-firebase/crashlytics         |\n| <Anchor href=\"v6/links\">Dynamic Links</Anchor>               | @react-native-firebase/dynamic-links       |\n| <Anchor href=\"v6/in-app-messaging\">In-app Messaging</Anchor> | @react-native-firebase/in-app-messaging    |\n| <Anchor href=\"v6/iid\">Instance ID</Anchor>                   | @react-native-firebase/iid                 |\n| <Anchor href=\"v6/mlkit\">ML Kit Natural Language</Anchor>     | @react-native-firebase/ml-natural-language |\n| <Anchor href=\"v6/mlkit\">ML Kit Vision</Anchor>               | @react-native-firebase/ml-vision           |\n| <Anchor href=\"v6/perf\">Performance Monitoring</Anchor>       | @react-native-firebase/perf                |\n| <Anchor href=\"v6/database\">Realtime Database</Anchor>        | @react-native-firebase/database            |\n| <Anchor href=\"v6/remote-config\">Remote Config</Anchor>       | @react-native-firebase/remote-config       |\n\nUsers on React Native version 0.60+, the modules will be automatically linked. For users on a lower version,\nsee the module specific pages for manual installation guides.\n\n## Updating project code\n\nIn versions prior to 6, accessing the React Native Firebase package was carried out by importing the `react-native-firebase`\nmodule, for example:\n\n```js\nimport firebase from 'react-native-firebase';\n\n// App code...\nconst user = firebase.auth().currentUser;\n```\n\nAlthough it is possible to access specific module functionality from the package imports, if you're coming from v5 the\nfollowing usage may seem daunting for a large project:\n\n```js\nimport auth from '@react-native-firebase/auth';\n\n// App code...\nconst user = auth().currentUser;\n```\n\nFortunately, it is possible to continue to migrate to the previous versions import method:\n\nFind and replace all usages of the import with the new import:\n\n```diff\n- import firebase from 'react-native-firebase';\n+ import firebase from '@react-native-firebase/app';\n```\n\nWe now need to import additional packages inside of an entry point file of our project, for example\nto import the Authentication module, add the following to your projects `/App.js` file (or entry file):\n\n```js\nimport firebase from '@react-native-firebase/app';\nimport '@react-native-firebase/auth';\n\n// App code\nconst user = firebase.auth().currentUser;\n```\n\nThis only needs to be done once. The `auth` module will now be available on all `firebase` instances.\n\n* * *\n\n## Module Breaking Changes\n\nBelow outlines a list of breaking changes for each module which may impact your application. Please ensure all\napp functionality is tested once migrated to version 6 is complete.\n\n### App\n\n`@react-native-firebase/app`\n\n-   `onReady()` removed: Users initializing a secondary app via `app.initializeApp` will need to now remove the `onReady`\n    listener. Instead, `initializeApp` resolves a promise once the secondary app has finished initializing.\n-   Initializing the `[DEFAULT]` app manually will now throw an error. Previously this only displayed a warning.\n\n### AdMob\n\n`@react-native-firebase/admob`\n\nThe AdMob module has undergone a full re-write to support a new, cleaner API and regulation changes (such as GDPR).\nPlease see the <Anchor href=\"/admob\">AdMob</Anchor> documentation and update your code usage.\n\n-   `RewardedVideo` has now been deprecated in favor of a new native API. Please see `RewardedAd` for more information.\n\n### Invites\n\nThe `invites` module has now been deprecated. Please see the official [Firebase documentation](https://firebase.google.com/docs/invites/deprecation)\nfor more information.\n\nThe recommended approach for handling this deprecation is to use the Dynamic Links module.\n\n### Analytics\n\n`@react-native-firebase/analytics`\n\n-   All methods now return a `Promise`. Previously these were 'fire and forget'.\n\n### Crashlytics\n\n`@react-native-firebase/crashlytics`\n\n-   `setBoolValue`, `setFloatValue`, `setIntValue` & `setStringValue` have been removed and replaced with two new methods (the Crashlytics SDK converted all these into strings internally anyway):\n    -   `setAttribute(key: string, value: string): Promise<null>` - set a singular key value to show alongside any subsequent crash reports\n    -   `setAttributes(values: { [key: string]: string }): Promise<null>` - set multiple key values to show alongside any subsequent crash reports\n-   All methods except `crash`, `log` & `recordError` now return a Promise that resolve when complete.\n-   `recordError` now accepts a JavaScript `Error` instead of a code and message.\n-   `setUserIdentifier()` has been renamed to `setUserId()` to match the Analytics Web SDK implementation.\n-   `enableCrashlyticsCollection()` has been renamed to `setCrashlyticsCollectionEnabled()`.\n\n### Firestore\n\n`@react-native-firebase/firestore`\n\n-   The `Blob` class can no longer be manually constructed.\n-   All user code is now validated in `JavaScript`. Passing incorrect data or querying chaining will now throw a JavaScript error. Ensure all queries are thoroughly tested.\n    -   The `Query` class has undergone a rewrite. Previously some invalid queries could be passed to the native SDKs causing a crash, these are now validated in JavaScript.\n-   The where equal operator `=` has been deprecated. Please use `==`.\n-   The setting `setTimestampsInSnapshotsEnabled` has been deprecated.\n\n### Dynamic Links\n\n`@react-native-firebase/dynamic-links`\n\n-   Module usage has been renamed from `links()` to `dynamicLinks()`.\n-   The `onLink` and `getInitialLink` methods now return a `DynamicLink` object, rather than the string URL.\n-   The _builder_ syntax has been deprecated in favor of simple objects. See `buildLink()` documentation for an example.\n-   Added extra validation. Building a dynamic link with platform specific options will now error if not all required parameters are set.\n\n### Functions\n\n`@react-native-firebase/functions`\n\nNo breaking changes.\n\n### In-App Messaging\n\n`@react-native-firebase/in-app-messaging`\n\nThis is a new module. See documentation for usage.\n\n### Instance ID\n\n`@react-native-firebase/iid`\n\nNo breaking changes.\n\n### Cloud Messaging\n\n`@react-native-firebase/messaging`\n\n-   [android] The manually added `RNFirebaseMessagingService` service in your `AndroidManifest.xml` file is no longer required - you can safely remove it.\n-   [iOS] The manually added `RNFirebaseMessaging` usages in your `AppDelegate` files are no longer required - you can safely remove them.\n-   The _builder_ syntax has been deprecated in favor of simple objects. See `newRemoteMessage()` documentation for an example.\n-   [iOS] The minimum supported iOS version is now 10\n-   iOS 9 or lower only accounts for 0.% of all iPhone devices.\n-   To see a detailed device versions breakdown see [this link](https://david-smith.org/iosversionstats/).\n-   Community contributions that add iOS 9 support are welcome.\n\n### Performance Monitoring\n\n`@react-native-firebase/perf`\n\n-   All `Trace` & `HttpMetric` methods (except for `start` & `stop`) are now synchronous and no longer return a Promise,\n    extra attributes/metrics now only get sent to native when you call stop.\n-   `firebase.perf.Trace.incrementMetric` will now create a metric if it could not be found.\n-   `firebase.perf.Trace.getMetric` will now return 0 if a metric could not be found.\n\n### Realtime Database\n\n`@react-native-firebase/database`\n\n-   The `Reference` class has undergone a rewrite. In previous versions, chaining invalid methods together on a query was possible. In version 6, the functionality now replicates the Firebase Web SDK.\n    -   Please thoroughly test your database queries.\n-   Internal JavaScript validation has been added and will throw a JavaScript error if methods are called with incorrect parameters.\n-   All query based modifiers are now validated as per the Web SDK spec. In v5 it is possible to chain queries which are not allowed together causing native errors (e.g. `.orderByKey().orderByPriority()`, `.startAt('foo', 'bar').orderByKey()` etc). Doing so in v6 will now throw an error to keep it in-line with the Web SDK.\n-   `Reference.push` now correctly mimics the Web SDK, returning a thenable reference.\n\n### Remote Config\n\n`@react-native-firebase/remote-config`\n\n-   Module namespace has been renamed to `.remoteConfig()` from `.config()`.\n-   All Remote Config values can now be accessed synchronously in JS, see `getValue(key: string): ConfigValue` & `getAll(): ConfigValues` below.\n    -   These replace all the original async methods: `getValue`, `getValues`, `getKeysByPrefix`.\n-   `setDefaultsFromResource` now returns a Promise that resolves when completed, this will reject with code `config/resouce_not_found` if the file could not be found.\n-   `setDefaultsFromResource` now expects a resource file name for Android to match iOS, formerly this required a resource id (something you would not have in RN as this was generated at build time by Android).\n    -   An example for both platforms can be found in the tests.\n-   `enableDeveloperMode` has been removed, you can now use `setConfigSettings({ isDeveloperModeEnabled: boolean })` instead.\n-   `setDefaults` now returns a Promise that resolves when completed.\n\n### Cloud Storage\n\n`@react-native-firebase/storage`\n\n-   Removed formerly deprecated `UploadTaskSnapshot.downloadUrl` property, use `StorageReference.getDownloadURL(): Promise<string>` instead.\n-   `StorageReference.downloadFile()` is now deprecated and will be removed in a later release, please rename usages of this to `writeToFile()` - renamed to match Native SDKs.\n-   `firebase.storage.Native` has moved to `firebase.utils.Native`.\n-   `firebase.utils.Native` is now deprecated and will be removed in a later release, please rename usages of this to `firebase.utils.FilePath`.\n-   `firebase.utils.Native.*` some properties have been renamed and deprecated and will be removed in a later release, follow the in-app console warnings on how to migrate.\n\n### ML Kit Natural Language\n\n`@react-native-firebase/ml-natural-language`\n\nThis is a new module. See documentation for usage.\n\n### ML Kit Vision\n\n`@react-native-firebase/ml-vision`\n\nThis is a new module. See documentation for usage.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/typescript.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nThe React Native Firebase project comes with support for TypeScript. The project provides\nAmbient Declarations for each Firebase module, without having to install any additional dependencies.\n\n## Example\n\nTo demonstrate TypeScript usage in a practical example, the following assumes TypeScript is already setup on your environment.\nIf you are looking to setup a new project or migrate an existing project to TypeScript please check out this official [blog post](https://facebook.github.io/react-native/blog/2018/05/07/using-typescript-with-react-native).\n\nThe below example makes use of the <a href=\"/auth\">Authentication</a> module, demonstrating how to safely type code using the declarations the module provides.\n\nLets go ahead and create a new `App.tsx` component:\n\n```jsx\nimport * as React from 'react';\nimport { Text } from 'react-native';\nimport auth from '@react-native-firebase/auth';\n\nfunction App() {\n  const user = auth().currentUser;\n\n  return <Text>Welcome {user.email}</Text>;\n}\n\nexport default App;\n```\n\nThis code will produce a TypeScript error: `Object is possibly null`. Accessing `currentUser` returns the\ncurrent <a href=\"/reference/auth/user\">`User`</a> if the user is signed in or `null` if\nthey are signed out. This error prevents our code from compiling and for good reason - without checking the users authentication status, accessing the `email` property on `User` will cause the app to crash!\n\nTo rectify our unsafe code, we can check the existence of the `user` before accessing it:\n\n```jsx\nfunction App() {\n  const user = auth().currentUser;\n\n  if (!user) {\n    return <Text>Please login</Text>;\n  }\n\n  return <Text>Welcome {user.email}</Text>;\n}\n```\n\nTypeScript will no longer show any errors, allowing us to safely continue developing our app.\n\nIt is also possible to access the module types directly, if you need to locally reference variables within your own codebase.\n\nFor example, we may need to store the `User` in local state. Manually defining a type for local state TypeScript loses the ability to type check the code.\n\nWe can easily access the types manually through the module though, for example:\n\n```ts\nimport * as React from 'react';\nimport { useEffect, useState } from 'react';\nimport auth, { FirebaseAuthTypes } from '@react-native-firebase/auth';\n\nfunction App() {\n  const [loading, setLoading] = useState<boolean>(true);\n  const [user, setUser] = useState<FirebaseAuthTypes.User | null>(null);\n\n  useEffect(() => {\n    auth().onAuthStateChanged(userState => {\n      setUser(userState);\n\n      if (loading) {\n        setLoading(false);\n      }\n    });\n  }, []);\n}\n\nexport default App;\n```\n\nWe firstly initialize a local state variable called `user`, and manually provide a type definition of that state item\nof `<FirebaseAuthTypes.User | null>`. As we are unaware of the users authentication state, we initialize state with a value of `null`\nwhich is a valid type for this state.\n\nThe `onAuthStateChanged` listener triggers with a `User` or `null` parameter whenever the users authentication state changes. The\n`@react-native-firebase/auth` module provides TypeScript with these types automatically. As the returned types match\nthe local state type, we are able to set the state immediately without any type check errors.\n\nAttempting to set `user` state to anything other than the `User` or `null` will throw a TypeScript error.\n\n## Definitions\n\nThe full set of TypeScript definitions for each module can be found on the [`invertase/react-native-firebase`](https://github.com/invertase/react-native-firebase)\nrepository within each package.\n\nFor example, the `auth` module definitions are located at [`react-native-firebase/packages/auth/lib/index.d.ts`](https://github.com/invertase/react-native-firebase/blob/master/packages/auth/lib/index.d.ts).\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/admob/european-user-consent.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nUnder the Google [EU User Consent Policy](https://www.google.com/about/company/consentstaging.html), you must make\ncertain disclosures to your users in the European Economic Area (EEA) and obtain their consent to use cookies or\nother local storage, where legally required, and to use personal data (such as `AdID`) to serve ads. This policy\nreflects the requirements of the `EU ePrivacy Directive` and the `General Data Protection Regulation` (GDPR).\n\nThe React Native Firebase AdMob module provides out of the box support for helping to manage your users consent\nwithin your application. The `AdsConsent` helper which comes with the module wraps the Google Consent SDK for both\nAndroid & iOS, and provides a single JavaScript interface for both platforms.\n\nThe `AdsConsent` helper & AdMob module provides out of the box support for:\n\n-   Requesting consent for multiple publisher IDs.\n-   Showing a Google-rendered consent form, listing all providers on your enabled mediation networks.\n-   Manually handling user consent if you prefer not to use the Google-rendered consent form.\n-   Forwarding your user consent status onto AdMob ad requests.\n\n## Understanding AdMob Ads\n\nAds served by Google can be categorized as personalized or non-personalized, both requiring consent from users in the EEA. By default,\nad requests to Google serve personalized ads, with ad selection based on the user's previously collected data. Users outside of the EEA do not require consent.\n\n> The `AdsConsent` helper only provides you with the tools for requesting consent, it is up to the developer to ensure the consent status is reflected throughout the app.\n\n## Handling consent\n\nThe following steps show the various methods and ways of handling consent within your app.\n\n### Delaying app measurement\n\nBy default, the Google Mobile Ads SDK initializes app measurement and begins sending user-level event data to Google immediately when the app starts.\nIf your app will be used by users within the EEA, it is important you prevent app measurement until your first ad has been requested (after consent).\n\nWithin your projects `firebase.json` file, set the `admob_delay_app_measurement_init` to `true` to delay app measurement:\n\n```json\n{\n  \"react-native\": {\n    \"admob_app_id\": \"YOUR_APP_ID\",\n    \"admob_delay_app_measurement_init\": true\n  }\n}\n```\n\nOnce set, rebuild your application:\n\n```bash\n# For iOS\nnpx react-native run-ios\n\n# For Android\nnpx react-native run-android\n```\n\n### Requesting consent information\n\nIt is recommended you request consent information each time your application starts. The Consent SDK stores the users consent status\nbased on the state of your AdMob network. If the state changes (e.g. a new mediation provider is added) the SDK automatically\ninvalidates the consent status (setting is to \"UNKNOWN\").\n\nThe `AdsConsent` helper provides a promised based method to return the users consent status called `requestInfoUpdate`. This method\naccepts an array of publisher IDs, which are used by the Consent SDK to determine the users consent status.\n\nYour own publisher ID can be found on the [Google AdMob dashboard](https://apps.admob.com/v2/settings) under \"Settings > Account Information\":\n\n![Publisher ID](https://prismic-io.s3.amazonaws.com/invertase%2Fbcb7e7d6-2bb3-4e8c-8e6e-be99d6bc4f56_new+project+%2816%29.jpg)\n\nTo request consent, call the method as early as possible within your app before presenting any ads:\n\n```js\nimport { AdsConsent } from '@react-native-firebase/admob';\n\nconst consentInfo = await AdsConsent.requestInfoUpdate(['pub-6189033257628123']);\n```\n\nThe result of the method returns an `AdsConsentInfo` interface, which provides information about the users status and location:\n\n-   **status**: The status can be one of 3 outcomes:\n    -   `UNKNOWN`: The user has not yet given consent, or has been invalidated since the last time they gave consent.\n    -   `NON_PERSONALIZED`: The user gave consent to see non-personalized ads only.\n    -   `PERSONALIZED`: The user gave consent to see personalized ads.\n-   **isRequestLocationInEeaOrUnknown**: A boolean value. If `true` the users location is within the EEA or is unknown.\n\nThe combination of status and location allows you to handle the next steps for requesting consent, if required:\n\n1.  If the users location is within the EEA or unknown, and their status is unknown, you must request consent before showing any ads.\n2.  If the users location is within the EEA or unknown, and their status is **not** unknown, you can show only the ad personalization they have requested.\n3.  If the users location is outside of the EEA, you do not have to give consent.\n\n### Gathering user consent\n\nNow we understand the consent status of the user, we can gather their consent (if required). This can be done in two ways:\n\n1.  Using a Google-rendered consent form.\n2.  Using a custom method.\n\nIf you are aware that users are under the age of consent in Europe, it is possible to set this using the `setTagForUnderAgeOfConsent`\nmethod (TFUA). Once the setting is enabled, the Google-rendered consent form will fail to load. All ad requests that include\nTFUA will be made ineligible for personalized advertising and remarketing. TFUA disables requests to third-party ad technology\nproviders, such as ad measurement pixels and third-party ad servers.\n\nTo remove this setting, pass `false` to the method.\n\n#### 1. Google-rendered consent form\n\nThe Google-rendered consent form is a full-screen configurable form that displays over your app content.\nYou can configure the form to present the user with combinations of the following options:\n\n-   Consent to view personalized ads\n-   Consent to view non-personalized ads\n-   Use a paid version of the app instead of viewing ads\n\nYou should review the consent text carefully: what appears by default is a message that might be appropriate if you use\nGoogle to monetize your app; but Google cannot provide legal advice on the consent text that is appropriate for you.\nTo update consent text of the Google-rendered consent form, modify the `consentform.html` file included in the Consent SDK as required.\n\n> An [example of a Google-rendered](https://developers.google.com/admob/images/android_eu_consent_form.png) consent form.\n\nTo show the consent form, the `AdsConsent` helper provides a `showForm` method, which takes options to configure the form.\nYou must provide a privacy policy URL.\n\n```js\nimport { AdsConsent, AdsConsentStatus } from '@react-native-firebase/admob';\n\nconst consentInfo = await AdsConsent.requestInfoUpdate(['pub-6189033257628123']);\n\nif (\n  consentInfo.isRequestLocationInEeaOrUnknown &&\n  consentInfo.status === AdsConsentStatus.UNKNOWN\n) {\n  const formResult = await AdsConsent.showForm({\n    privacyPolicy: 'https://invertase.io/privacy-policy',\n    withPersonalizedAds: true,\n    withNonPersonalizedAds: true,\n    withAdFree: true,\n  });\n}\n```\n\nOnce the user has selected their preference, the `formResult` contains their status and whether or not they prefer an\nad-free option of your application (if enabled):\n\n```js\nconst formResult = await AdsConsent.showForm({\n  privacyPolicy: 'https://invertase.io/privacy-policy',\n  withPersonalizedAds: true,\n  withNonPersonalizedAds: true,\n  withAdFree: true,\n});\n\nif (formResult.userPrefersAdFree) {\n  // Handle the users request, e.g. redirect to a paid for version of the app\n}\n\n// The user requested non-personalized or personalized ads\nconst status = formResult.status;\n```\n\nThe `formResult.status` provides feedback on whether the user consented to personalized ads, or non-personalized ads.\nIt is important that you forward this status onto all ad requests (see below).\n\n> Do not persist the status. You could however store this locally in application state (e.g. React Context) and update the status on every app launch as it may change.\n\n#### 2. Custom consent method\n\nIf you wish to implement your own consent flow, the `AdsConsent` helper provides the tools needed to accomplish this.\nDepending on your requirements, a list of the enabled network mediation providers for the AdMob App ID can be returned and shown\nto the user via the `getAdProviders` method:\n\n```js\nimport { AdsConsent } from '@react-native-firebase/admob';\n\nconst providers = await AdsConsent.getAdProviders();\n```\n\nEach provider is an interface of `AdProvider`, containing information such as their company ID, company name and privacy policy URL.\nUsing this information you can request consent from your users.\n\nOnce consent has been returned, the Consent SDK needs to be aware of the custom user consent status. This can be forwarded on using the\n`setStatus` method, for example:\n\n```js\nimport { AdsConsent, AdsConsentStatus } from '@react-native-firebase/admob';\n\n// After getting user consent...\nawait AdsConsent.setStatus(AdsConsentStatus.PERSONALIZED);\n```\n\nTo invalidate the users consent status (e.g. if the providers list changes since their last consent), set the status back to\n`UNKNOWN`. When your application next boots, you can get the users previous consent status using the `getStatus` method.\n\n### Testing\n\nWhen developing the consent flow, the behavior of the `AdsConsent` responses may not be reliable due to the environment\n(e.g. using an emulator vs real device). It is possible to set a debug location to test the various responses from the\nConsent SDK.\n\nIf using a real device, ensure you whitelist it using the device ID, which can be obtained from native logs or using a library\nsuch as [react-native-device-info](https://github.com/react-native-community/react-native-device-info). Once found,\ncall the `addTestDevice(deviceId)` method.\n\n> Emulators are automatically whitelisted.\n\nTo set a debug location, use the `setDebugGeography` method. It accepts 3 values:\n\n-   **DISABLED**: Removes any previous debug locations.\n-   **EEA**: Set the test device to be within the EEA.\n-   **NOT_EEA**: Set the test device to be outside of the EEA.\n\nFor example:\n\n```js\nimport { AdsConsent, AdsConsentDebugGeography } from '@react-native-firebase/admob';\n\nawait AdsConsent.setDebugGeography(AdsConsentDebugGeography.EEA);\n```\n\n> Always ensure debug information is removed for production apps!\n\n### Forwarding the consent status to ads\n\nAssuming the user is within the EEA and has provided consent, their status needs to be forwarded to every ad request we\nmake in our application.\n\n> If the user is within the EEA and has not given consent, do not display AdMob ads (even non-personalized).\n\nTaking a Rewarded Video as an example, we can apply the users consent when our ad is loaded via the `RequestOptions`. For example:\n\n```js\nimport { AdsConsent, RewardedAd } from '@react-native-firebase/admob';\n\nconst status = await AdsConsent.getStatus();\n\nconst rewardedAd = RewardedAd.createForAdRequest('AD_UNIT_ID', {\n  requestNonPersonalizedAdsOnly: status === AdsConsentStatus.NON_PERSONALIZED,\n});\n```\n\nThe requested ad URL via the SDK will send a request with an additional parameter `&npa=1`, which will return a\nnon-personalized ad.\n\n### Troubleshooting\n\n#### \"Could not parse Event FE preflight response.\"\n\nThis is a common error which occurs on both Android & iOS when making a request to display a Google-rendered consent form. Unfortunately the reasoning for this error is generic, making it hard to debug. There are a number of steps to check which are usually the cause for this error:\n\n-   The AdMob App ID is incorrect: Ensure you have entered the correct ID into the `firebase.json` file under the `admob_app_id` key in the `react-native` config.\n-   A publisher ID is incorrect: Ensure your entered publisher IDs are correct.\n    -   The publisher ID needs to be available on the same account as your AdMob App ID.\n-   The user is outside of the EEA: If a user does not need to provide consent, the form request will error. Ensure you have checked the users status via `requestInfoUpdate`. If using an emulator, ensure you set a debug location via `setDebugGeography`.\n-   Your AdMob account is not valid:\n    -   Your account is disabled: This can occur if Google notices you have duplicate accounts. They will email you about this, and block you from entering the dashboard.\n    -   You have provided invalid payment information: If your account has no payment information set up, this seems to cause this error to trigger.\n\nIf you are still struggling to present the consent form, reach out to AdMob support to investigate your account status via <https://support.google.com/admob>\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/admob/displaying-ads.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nThe AdMob package allows you to display three types of adverts; Interstitial, Rewarded & Banner.\n\n## Interstitial Ads\n\nInterstitials are full-screen ads that cover the interface of an app until closed by the user. These type of ads are\nprogrammatically loaded and then shown at a suitable point during your application flow (e.g. after a level on a gaming\napp has been completed, or game over). The ads can be preloaded in the background to ensure they're ready to go when needed.\n\nTo create a new interstitial, call the `createForAdRequest` method from the `InterstitialAd` class. The first argument\nof the method is the \"Ad Unit ID\". For testing, we can use a Test ID, however for production the ID from the\nGoogle AdMob dashboard under \"Ad units\" should be used:\n\n```js\nimport { InterstitialAd, TestIds, AdEventType } from '@react-native-firebase/admob';\n\nconst adUnitId = __DEV__ ? TestIds.INTERSTITIAL : 'ca-app-pub-xxxxxxxxxxxxx/yyyyyyyyyyyyyy';\n\nconst interstitial = InterstitialAd.createForAdRequest(adUnitId, {\n  requestNonPersonalizedAdsOnly: true,\n  keywords: ['fashion', 'clothing'],\n});\n```\n\nThe second argument is additional optional request options object to be sent whilst loading an advert, such as keywords & location.\nSetting additional request options helps AdMob choose better tailored ads from the network. View the [`RequestOptions`](/reference/admob/requestoptions)\ndocumentation to view the full range of options available.\n\nThe call to `createForAdRequest` returns an instance of the [`InterstitialAd`](/reference/admob/interstitialad) class,\nwhich provides a number of utilities for loading and displaying interstitials.\n\nTo listen to events, such as when the advert from the network has loaded or when an error occurs, we can subscribe via the\n`onAdEvent` method:\n\n```jsx\nimport React, { useEffect, useState } from 'react';\nimport { Button } from 'react-native';\nimport { InterstitialAd, AdEventType, TestIds } from '@react-native-firebase/admob';\n\nconst adUnitId = __DEV__ ? TestIds.INTERSTITIAL : 'ca-app-pub-xxxxxxxxxxxxx/yyyyyyyyyyyyyy';\n\nconst interstitial = InterstitialAd.createForAdRequest(adUnitId, {\n  requestNonPersonalizedAdsOnly: true,\n  keywords: ['fashion', 'clothing'],\n});\n\nfunction App() {\n  const [loaded, setLoaded] = useState(false);\n\n  useEffect(() => {\n    const eventListener = interstitial.onAdEvent(type => {\n      if (type === AdEventType.LOADED) {\n        setLoaded(true);\n      }\n    });\n\n    // Start loading the interstitial straight away\n    interstitial.load();\n\n    // Unsubscribe from events on unmount\n    return () => {\n      eventListener();\n    };\n  }, []);\n\n  // No advert ready to show yet\n  if (!loaded) {\n    return null;\n  }\n\n  return (\n    <Button\n      title=\"Show Interstitial\"\n      onPress={() => {\n        interstitial.show();\n      }}\n    />\n  );\n}\n```\n\nThe code above subscribes to the interstitial events (via `onAdEvent()`) and immediately starts to load a new advert from\nthe network (via `load()`). Once an advert is available, local state is set, re-rendering the component showing a `Button`.\nWhen pressed, the `show` method on the interstitial instance is called and the advert is shown over-the-top of your\napplication.\n\nThe `onAdEvent` listener also triggers when events inside of the application occur, such as if the user clicks the advert,\nor closes the advert and returns back to your app. To view a full list of events which are available, view the\n[`AdEventType`](/reference/admob/adeventtype) documentation.\n\nIf needed, you can reuse the existing instance of the `InterstitialAd` class to load more adverts and show them when required.\n\n## Rewarded Ads\n\nRewarded Ads are full-screen ads that cover the interface of an app until closed by the user. The content of a rewarded\nadvert is controlled via the Google AdMob dashboard.\n\nThe purpose of a rewarded ad is to reward users with _something_ after completing an action inside of the advert, such\nas watching a video or submitting an option via an interactive form. If the user completes the action, you can reward them\nwith something (e.g. in-game currency).\n\nTo create a new interstitial, call the `createForAdRequest` method from the `RewardedAd` class. The first argument\nof the method is the \"Ad Unit ID\". For testing, we can use a Test ID, however for production the ID from the\nGoogle AdMob dashboard under \"Ad units\" should be used:\n\n```js\nimport { RewardedAd, TestIds } from '@react-native-firebase/admob';\n\nconst adUnitId = __DEV__ ? TestIds.INTERSTITIAL : 'ca-app-pub-xxxxxxxxxxxxx/yyyyyyyyyyyyyy';\n\nconst rewarded = RewardedAd.createForAdRequest(adUnitId, {\n  requestNonPersonalizedAdsOnly: true,\n  keywords: ['fashion', 'clothing'],\n});\n```\n\nThe second argument is additional optional request options object to be sent whilst loading an advert, such as keywords & location.\nSetting additional request options helps AdMob choose better tailored ads from the network. View the [`RequestOptions`](/reference/admob/requestoptions)\ndocumentation to view the full range of options available.\n\nThe call to `createForAdRequest` returns an instance of the [`RewardedAd`](/reference/admob/rewardedad) class,\nwhich provides a number of utilities for loading and displaying rewarded ads.\n\nTo listen to events, such as when the advert from the network has loaded or when an error occurs, we can subscribe via the\n`onAdEvent` method:\n\n```js\nimport React, { useEffect, useState } from 'react';\nimport { Button } from 'react-native';\nimport { RewardedAd, RewardedAdEventType, TestIds } from '@react-native-firebase/admob';\n\nconst adUnitId = __DEV__ ? TestIds.REWARDED : 'ca-app-pub-xxxxxxxxxxxxx/yyyyyyyyyyyyyy';\n\nconst rewarded = RewardedAd.createForAdRequest(adUnitId, {\n  requestNonPersonalizedAdsOnly: true,\n  keywords: ['fashion', 'clothing'],\n});\n\nfunction App() {\n  const [loaded, setLoaded] = useState(false);\n\n  useEffect(() => {\n    const eventListener = rewarded.onAdEvent((type, error, reward) => {\n      if (type === RewardedAdEventType.LOADED) {\n        setLoaded(true);\n      }\n\n      if (type === RewardedAdEventType.EARNED_REWARD) {\n        console.log('User earned reward of ', reward);\n      }\n    });\n\n    // Start loading the rewarded ad straight away\n    rewarded.load();\n\n    // Unsubscribe from events on unmount\n    return () => {\n      eventListener();\n    };\n  }, []);\n\n  // No advert ready to show yet\n  if (!loaded) {\n    return null;\n  }\n\n  return (\n    <Button\n      title=\"Show Rewarded Ad\"\n      onPress={() => {\n        rewarded.show();\n      }}\n    />\n  );\n}\n```\n\nThe code above subscribes to the rewarded ad events (via `onAdEvent()`) and immediately starts to load a new advert from\nthe network (via `load()`). Once an advert is available, local state is set, re-rendering the component showing a `Button`.\nWhen pressed, the `show` method on the rewarded ad instance is called and the advert is shown over-the-top of your\napplication.\n\nLike Interstitial Ads, the events returns from the `onAdEvent` listener trigger when the user clicks the advert or closes\nthe advert and returns back to your app. However, an extra `EARNED_REWARD` event can be triggered if the user completes the\nadvert action. An additional `reward` property is sent with the event, containing the amount and type of rewarded (specified via the dashboard).\nAn additional `reward` property is sent with the event, containing the amount and type of rewarded (specified via the dashboard).\n\nTo learn more, view the [`RewardedAdEventType`](/reference/admob/rewardedadeventtype) documentation.\n\nIf needed, you can reuse the existing instance of the `RewardedAd` class to load more adverts and show them when required.\n\n## Banner Ads\n\nBanner ads are partial adverts which can be integrated within your existing application. Unlike Interstitial and Rewarded Ads,\na Banner only takes up a limited area of the application and displays an advert within the area. This allows you to integrate\nadverts without a disruptive action.\n\nThe module exposes a [`BannerAd`](/reference/admob/bannerad) component. The `unitId` and `size` props are required to display\na banner:\n\n```js\nimport React from 'react';\nimport { BannerAd, BannerAdSize, TestIds } from '@react-native-firebase/admob';\n\nconst adUnitId = __DEV__ ? TestIds.BANNER : 'ca-app-pub-xxxxxxxxxxxxx/yyyyyyyyyyyyyy';\n\nfunction App() {\n  return (\n    <BannerAd\n      unitId={adUnitId}\n      size={BannerAdSize.FULL_BANNER}\n      requestOptions={{\n        requestNonPersonalizedAdsOnly: true,\n      }}\n    />\n  );\n}\n```\n\nThe `size` prop takes a [`BannerAdSize`](/reference/admob/banneradsize) type, and once the advert is available, will\nfill the space for the chosen size.\n\n> If no inventory for the size specified is available, an error will be thrown via `onAdFailedToLoad`!\n\nThe `requestOptions` prop is additional optional request options object to be sent whilst loading an advert, such as keywords & location.\nSetting additional request options helps AdMob choose better tailored ads from the network. View the [`RequestOptions`](/reference/admob/requestoptions)\ndocumentation to view the full range of options available.\n\nThe component also exposes props for listening to events, which you can use to handle the state of your app is the user\nor network triggers an event:\n\n-   `onAdClosed`\n-   `onAdFailedToLoad`\n-   `onAdLeftApplication`\n-   `onAdOpened`\n\nEach render of the component loads a single advert, allowing you to display multiple adverts at once. If you need to reload/change\nan advert for a currently mounted component, you'll need to force a re-render inside of your own code.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/admob/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/app/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/app/usage.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nThe App module is available by default once you have installed the React Native Firebase library by following the\n[Getting Started](/) documentation. The App module currently provides the following functionality:\n\n-   Creating [Secondary Firebase App Instances](#secondary-apps).\n-   Exposing [Utilities](/app/utils) to aid development.\n\n# Secondary Apps\n\nUnlike the Firebase Web SDK, there is no need to manually call the [`initializeApp`](https://firebase.google.com/docs/web/setup#add-sdks-initialize)\nmethod with your project credentials. The native Android & iOS SDKs automatically connect to your Firebase project using\nthe credentials provided during the [Getting Started](/) installation steps. The app module does however provide support\nfor manually initializing secondary Firebase app instances.\n\nCurrently, the native Firebase SDKs only provide functionality for creating secondary apps on the following services:\n\n-   [Authentication](/auth).\n-   [Realtime Database](/database).\n-   [Cloud Firestore](/firestore).\n-   [Cloud Functions](/functions)\n-   [Cloud Storage](/storage).\n-   [Instance ID](/iid).\n-   [ML Kit Natural Language](/ml-language).\n-   [ML Kit Vision](/ml-vision).\n-   [Remote Config](/remote-config).\n\n## Initializing secondary apps\n\nThe module exposes an `initializeApp` method which accepts arguments containing the credentials and options for your secondary\napps:\n\n```js\nimport firebase from '@react-native-firebase/app';\n\n// Your secondary Firebase project credentials...\nconst credentials = {\n  clientId: '',\n  appId: '',\n  apiKey: '',\n  databaseURL: '',\n  storageBucket: '',\n  messagingSenderId: '',\n  projectId: '',\n};\n\nconst config = {\n  name: 'SECONDARY_APP',\n};\n\nawait firebase.initializeApp(credentials, config);\n```\n\nOnce created, you can confirm the app instance has been created by accessing the `apps` property on the module:\n\n```js\nconst apps = firebase.apps;\n\napps.forEach(app => {\n  console.log('App name: ', app.name);\n});\n```\n\n## Switching app instance\n\nYou can switch app instances at any time whilst developing by calling the `app` method with the name of the secondary app:\n\n```js\nimport firebase from '@react-native-firebase/app';\nimport '@react-native-firebase/auth';\n\n// Example using auth\nfirebase.app('SECONDARY_APP').auth().currentUser;\n```\n\nOr pass the secondary app instance you created above directly to the desired module, for example:\n\n```js\nimport firebase from '@react-native-firebase/app';\nimport auth from '@react-native-firebase/auth';\n\n// create secondary app as described above\nconst secondaryApp = await firebase.initializeApp(credentials, config);\n\n// Example using auth with passing the secondary app instance\nauth(secondaryApp).currentUser;\n```\n\n## Deleting instances\n\nYou can delete any secondary instances by calling the `delete` method on the instance:\n\n```js\nawait firebase.app('SECONDARY_APP').delete();\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/app/utils.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nThe App module also provides access to some handy utility methods which have been exposed to aid with your\ndevelopment.\n\n# File Paths\n\nWhen working with modules such as [Cloud Storage](/storage), you may need to know about the devices\ncurrent directory paths. Rather than installing a separate module, the library provides useful statics\nwhich can be used.\n\nAccess the `FilePath` static via utils:\n\n```js\nimport { utils } from '@react-native-firebase/app';\n\nconsole.log(utils.FilePath.PICTURES_DIRECTORY);\n```\n\n# Test Lab\n\nFirebase [TestLab](https://firebase.google.com/docs/test-lab/?utm_source=invertase&utm_medium=react-native-firebase&utm_campaign=utils)\nis a cloud-based app-testing infrastructure. With one operation, you can test your Android or iOS app across\na wide variety of devices and device configurations, and see the results—including logs, videos,\nand screenshots—in the Firebase console.\n\nIt is useful to change the apps configuration if it is being run in Test Lab, for example disabling Analytics\ndata collection. Such functionality can be carried out by taking advantage of the `isRunningInTestLab`.\n\n> Be aware, `isRunningInTestLab` is Android only property!\n\n```js\nimport { utils } from '@react-native-firebase/app';\nimport analytics from '@react-native-firebase/analytics';\n\nasync function bootstrap() {\n  if (utils().isRunningInTestLab) {\n    await analytics().setAnalyticsCollectionEnabled(false);\n  }\n}\n```\n\n# Android - Checking Play Services\n\nIt is useful to know if the Android device has play services available, and what to do in response to certain use cases:\n\n```js\nimport { utils } from '@react-native-firebase/app';\n\nasync function checkPlayServicesExample() {\n  const {\n    status,\n    isAvailable,\n    hasResolution,\n    isUserResolvableError,\n  } = utils.playServicesAvailability;\n  // all good and valid \\o/\n  if (isAvailable) return Promise.resolve();\n  // if the user can resolve the issue i.e by updating play services\n  // then call Google Play's own/default prompting functionality\n  if (isUserResolvableError || hasResolution) {\n    switch (status) {\n      case 1:\n        // SERVICE_MISSING - Google Play services is missing on this device.\n        // show something to user\n        // and then attempt to install if necessary\n        return utils.makePlayServicesAvailable();\n      case 2:\n        // SERVICE_VERSION_UPDATE_REQUIRED - The installed version of Google Play services is out of date.\n        // show something to user\n        // and then attempt to update if necessary\n        return utils.resolutionForPlayServices();\n\n      default:\n        // some default dialog / component?\n        // use the link below to tailor response to status codes to suit your use case\n        // https://developers.google.com/android/reference/com/google/android/gms/// common/ConnectionResult#SERVICE_VERSION_UPDATE_REQUIRED\n        if (isUserResolvableError) return utils.promptForPlayServices();\n        if (hasResolution) return utils.resolutionForPlayServices();\n    }\n  }\n  // There's no way to resolve play services on this device\n  // probably best to show a dialog / force crash the app\n  return Promise.reject(new Error('Unable to find a valid play services version.'));\n}\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/analytics/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/analytics/screen-tracking.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nStandard React Native applications run inside a single `Activity`/`ViewController`, meaning any screen changes won't be\ntracked by the native Firebase SDKs. There are a number of ways to implement navigation within React Native apps,\ntherefore there is no \"one fits all\" solution to screen tracking.\n\n# React Navigation\n\nThe [React Navigation](https://reactnavigation.org/) library allows for various navigation techniques such as\nStack, Tab, Native or even custom navigation. The `NavigationController` component which the library exposes provides\naccess to the current navigation state when a screen changes, allowing you to use the [`setCurrentScreen`](/reference/analytics#setCurrentScreen)\nmethod the Analytics library provides:\n\n```jsx\nimport analytics from '@react-native-firebase/analytics';\nimport { NavigationContainer } from '@react-navigation/native';\n\n<NavigationContainer\n  ref={navigationRef}\n  onStateChange={state => {\n    const previousRouteName = routeNameRef.current;\n    const currentRouteName = getActiveRouteName(state);\n\n    if (previousRouteName !== currentRouteName) {\n      analytics().setCurrentScreen(currentRouteName, currentRouteName);\n    }\n```\n\nFor a full working example, view the [Screen tracking for analytics](https://reactnavigation.org/docs/screen-tracking/)\ndocumentation on the React Navigation website.\n\n# React Native Navigation\n\nThe [`wix/react-native-navigation`](https://github.com/wix/react-native-navigation) provides 100% native platform navigation\nfor React Native apps. To manually track screens, you need to setup a `componentDidAppear` event listener and manually call the\n[`setCurrentScreen`](/reference/analytics#setCurrentScreen) method the Analytics library provides:\n\n```js\nimport analytics from '@react-native-firebase/analytics';\nimport { Navigation } from 'react-native-navigation';\n\nNavigation.events().registerComponentDidAppearListener(({ componentName, componentType }) => {\n  if (componentType === 'Component') {\n    analytics().setCurrentScreen(componentName, componentName);\n  }\n});\n```\n\nTo learn more, view the [events documentation](https://wix.github.io/react-native-navigation/api/events#componentdidappear)\non the React Native Navigation website.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/auth/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/auth/phone-auth.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nPhone authentication allows users to sign in to Firebase using their phone as the authenticator. An SMS message is sent\nto the user via their phone number containing a unique code. Once the code has been authorized, the user is able to sign\nin to Firebase.\n\nPhone numbers that end users provide for authentication will be sent and stored by Google to improve our spam and abuse\nprevention across Google services, including but not limited to Firebase. Developers should ensure they have appropriate\nend-user consent prior to using the Firebase Authentication phone number sign-in service.\n\n> Firebase Phone Auth is not supported in all countries. Please see their [FAQs](https://firebase.google.com/support/faq/#develop) for more information.\n\nEnsure the \"Phone\" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).\n\n# Sign-in\n\nThe module provides a `signInWithPhoneNumber` method which accepts a phone number. Firebase sends an SMS message to the\nuser with a code, which they must then confirm. The `signInWithPhoneNumber` method returns a confirmation method which accepts\na code. Based on whether the code is correct for the device, the method rejects or resolves.\n\nThe example below demonstrates how you could setup such a flow within your own application:\n\n```jsx\nimport React, { useState } from 'react';\nimport { Button, TextInput } from 'react-native';\nimport auth from '@react-native-firebase/auth';\n\nfunction PhoneSignIn() {\n  // If null, no SMS has been sent\n  const [confirm, setConfirm] = useState(null);\n\n  const [code, setCode] = useState('');\n\n  // Handle the button press\n  async function signInWithPhoneNumber(phoneNumber) {\n    const confirmation = await auth().signInWithPhoneNumber(phoneNumber);\n    setConfirm(confirmation);\n  }\n\n  async function confirmCode() {\n    try {\n      await confirm.confirm(code);\n    } catch (error) {\n      console.log('Invalid code.');\n    }\n  }\n\n  if (!confirm) {\n    return (\n      <Button\n        title=\"Phone Number Sign In\"\n        onPress={() => signInWithPhoneNumber('+1 650-555-3434')}\n      />\n    );\n  }\n\n  return (\n    <>\n      <TextInput value={code} onChangeText={text => setCode(text)} />\n      <Button title=\"Confirm Code\" onPress={() => confirmCode()} />\n    </>\n  );\n}\n```\n\nUpon successful sign-in, any [`onAuthStateChanged`](/auth/usage#listening-to-authentication-state) listeners will trigger\nwith the new authentication state of the user.\n\n# Testing\n\nFirebase provides support for locally testing phone numbers. For local testing to work, you must have ensured your local\nmachine SHA1 debug key was added whilst creating your application on the Firebase Console. View the [Getting Started](/)\nguide on how to set this up.\n\nOn the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers), select the \"Phone\" authentication provider and click on the\n\"Phone numbers for testing\" dropdown.\n\nEnter a new phone number (e.g. `+44 7444 555666`) and a test code (e.g. `123456`).\n\nOnce added, the number can be used with the `signInWithPhoneNumber` method, and entering the code specified will\ncause a successful sign-in.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/auth/social-auth.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nReact Native Firebase provides support for integrating with different social platforms. The authentication with these\ndifferent platforms is left to the developer to implement due to the various implementations and flows possible using\ntheir OAuth APIs.\n\n# Social providers\n\n## Apple\n\nStarting April 2020, all existing applications using external 3rd party login services (such as Facebook, Twitter, Google etc)\nmust ensure that Apple Sign-In is also provided. To learn more about these new guidelines, view the [Apple announcement](https://developer.apple.com/news/?id=09122019b).\nApple Sign-In is not required for Android devices.\n\nTo integrate Apple Sign-In on your iOS applications, you need to install a 3rd party library to authenticate with Apple.\nOnce authentication is successful, a Firebase credential can be used to sign the user into Firebase with their Apple account.\n\nTo get started, you must first install the [`react-native-apple-authentication`](https://github.com/invertase/react-native-apple-authentication)\nlibrary. There are a number of [prerequisites](https://github.com/invertase/react-native-apple-authentication#prerequisites-to-using-this-library) to using the library, including\n[setting up your Apple Developer account](https://github.com/invertase/react-native-apple-authentication/blob/master/docs/INITIAL_SETUP.md) to enable Apple Sign-In.\n\nEnsure the \"Apple\" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).\n\nOnce setup, we can trigger an initial request to allow user to sign in with their Apple account, using a pre-rendered\nbutton the `react-native-apple-authentication` library provides:\n\n```jsx\nimport React from 'react';\nimport { AppleButton } from '@invertase/react-native-apple-authentication';\n\nfunction AppleSignIn() {\n  return (\n    <AppleButton\n      buttonStyle={AppleButton.Style.WHITE}\n      buttonType={AppleButton.Type.SIGN_IN}\n      style={{\n        width: 160,\n        height: 45,\n      }}\n      onPress={() => onAppleButtonPress().then(() => console.log('Apple sign-in complete!'))}\n    />\n  );\n}\n```\n\nWhen the user presses the pre-rendered button, we can trigger the initial sign-in request using the `performRequest` method,\npassing in the scope required for our application:\n\n```js\nimport auth from '@react-native-firebase/auth';\nimport appleAuth, {\n  AppleAuthRequestScope,\n  AppleAuthRequestOperation,\n} from '@invertase/react-native-apple-authentication';\n\nasync function onAppleButtonPress() {\n  // Start the sign-in request\n  const appleAuthRequestResponse = await appleAuth.performRequest({\n    requestedOperation: AppleAuthRequestOperation.LOGIN,\n    requestedScopes: [AppleAuthRequestScope.EMAIL, AppleAuthRequestScope.FULL_NAME],\n  });\n\n  // Ensure Apple returned a user identityToken\n  if (!appleAuthRequestResponse.identityToken) {\n    throw 'Apple Sign-In failed - no identify token returned';\n  }\n\n  // Create a Firebase credential from the response\n  const { identityToken, nonce } = appleAuthRequestResponse;\n  const appleCredential = auth.AppleAuthProvider.credential(identityToken, nonce);\n\n  // Sign the user in with the credential\n  return auth().signInWithCredential(appleCredential);\n}\n```\n\nUpon successful sign-in, any [`onAuthStateChanged`](/auth/usage#listening-to-authentication-state) listeners will trigger\nwith the new authentication state of the user.\n\n## Facebook\n\nFacebook provide an [official React Native library](https://github.com/facebook/react-native-fbsdk) which wraps around\nthe native Facebook SDKs to enable Facebook sign-in.\n\nBefore getting started, ensure you have installed the library, [configured your Android & iOS applications](https://developers.facebook.com/docs/android/getting-started/) and\nsetup your [Facebook Developer Account](https://github.com/facebook/react-native-fbsdk#3-configure-projects)\nto enable Facebook Login.\n\nEnsure the \"Facebook\" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).\n\nOnce setup, we can trigger the login flow with Facebook by calling the `logInWithPermissions` method on the `LoginManager`\nclass:\n\n```jsx\nimport React from 'react';\nimport { Button } from 'react-native';\n\nfunction FacebookSignIn() {\n  return (\n    <Button\n      title=\"Facebook Sign-In\"\n      onPress={() => onFacebookButtonPress().then(() => console.log('Signed in with Facebook!'))}\n    />\n  );\n}\n```\n\nThe `onFacebookButtonPress` can then be implemented as follows:\n\n```js\nimport auth from '@react-native-firebase/auth';\nimport { LoginManager, AccessToken } from 'react-native-fbsdk';\n\nasync function onFacebookButtonPress() {\n  // Attempt login with permissions\n  const result = await LoginManager.logInWithPermissions(['public_profile', 'email']);\n\n  if (result.isCancelled) {\n    throw 'User cancelled the login process';\n  }\n\n  // Once signed in, get the users AccesToken\n  const data = await AccessToken.getCurrentAccessToken();\n\n  if (!data) {\n    throw 'Something went wrong obtaining access token';\n  }\n\n  // Create a Firebase credential with the AccessToken\n  const facebookCredential = auth.FacebookAuthProvider.credential(data.accessToken);\n\n  // Sign-in the user with the credential\n  return auth().signInWithCredential(facebookCredential);\n}\n```\n\nUpon successful sign-in, any [`onAuthStateChanged`](/auth/usage#listening-to-authentication-state) listeners will trigger\nwith the new authentication state of the user.\n\n## Twitter\n\nUsing the external [`react-native-twitter-signin`](https://github.com/GoldenOwlAsia/react-native-twitter-signin) library,\nwe can sign-in the user with Twitter and generate a credential which can be used to sign-in with Firebase.\n\nTo get started, install the library and ensure you have completed setup, following the required [prerequisites](https://github.com/GoldenOwlAsia/react-native-twitter-signin#prerequisites) list.\n\nEnsure the \"Twitter\" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).\n\nBefore triggering a sign-in request, you must initialize the Twitter SDK using your accounts consumer key & secret:\n\n```js\nimport { NativeModules } from 'react-native';\nconst { RNTwitterSignIn } = NativeModules;\n\nRNTwitterSignIn.init('TWITTER_CONSUMER_KEY', 'TWITTER_CONSUMER_SECRET').then(() =>\n  console.log('Twitter SDK initialized'),\n);\n```\n\nOnce initialized, setup your application to trigger a sign-in request with Twitter using the `login` method.\n\n```jsx\nimport React from 'react';\nimport { Button } from 'react-native';\n\nfunction TwitterSignIn() {\n  return (\n    <Button\n      title=\"Twitter Sign-In\"\n      onPress={() => onTwitterButtonPress().then(() => console.log('Signed in with Twitter!'))}\n    />\n  );\n}\n```\n\nThe `onTwitterButtonPress` can then be implemented as follows:\n\n```js\nimport auth from '@react-native-firebase/auth';\nimport { NativeModules } from 'react-native';\nconst { RNTwitterSignIn } = NativeModules;\n\nasync function onTwitterButtonPress() {\n  // Perform the login request\n  const { authToken, authTokenSecret } = await RNTwitterSignIn.logIn();\n\n  // Create a Twitter credential with the tokens\n  const twitterCredential = auth.TwitterAuthProvider.credential(authToken, authTokenSecret);\n\n  // Sign-in the user with the credential\n  return auth().signInWithCredential(twitterCredential);\n}\n```\n\nUpon successful sign-in, any [`onAuthStateChanged`](/auth/usage#listening-to-authentication-state) listeners will trigger\nwith the new authentication state of the user.\n\n## Google\n\nThe [`google-signin`](https://github.com/react-native-community/react-native-google-signin) library provides a wrapper around the official Google login library,\nallowing you to create a credential and sign-in to Firebase.\n\nMost configuration is already setup when using Google Sign-In with Firebase, however you need to ensure your machines\nSHA1 key has been configured for use with Android. You can see view how to generate the key on the [Getting Started](/)\ndocumentation.\n\nEnsure the \"Google\" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).\n\nBefore triggering a sign-in request, you must initialize the Google SDK using your any required scopes and the\n`webClientId`, which can be found in the `android/app/google-services.json` file as the `client/oauth_client/client_id` property (the id ends with `.apps.googleusercontent.com`).\n\n```js\nimport { GoogleSignin } from '@react-native-community/google-signin';\n\nGoogleSignin.configure({\n  webClientId: '',\n});\n```\n\nOnce initialized, setup your application to trigger a sign-in request with Google using the `signIn` method.\n\n```jsx\nimport React from 'react';\nimport { Button } from 'react-native';\n\nfunction GoogleSignIn() {\n  return (\n    <Button\n      title=\"Google Sign-In\"\n      onPress={() => onGoogleButtonPress().then(() => console.log('Signed in with Google!'))}\n    />\n  );\n}\n```\n\nThe `onGoogleButtonPress` can then be implemented as follows:\n\n```js\nimport auth from '@react-native-firebase/auth';\nimport { GoogleSignin } from '@react-native-community/google-signin';\n\nasync function onGoogleButtonPress() {\n  // Get the users ID token\n  const { idToken } = await GoogleSignin.signIn();\n\n  // Create a Google credential with the token\n  const googleCredential = auth.GoogleAuthProvider.credential(idToken);\n\n  // Sign-in the user with the credential\n  return auth().signInWithCredential(googleCredential);\n}\n```\n\nUpon successful sign-in, any [`onAuthStateChanged`](/auth/usage#listening-to-authentication-state) listeners will trigger\nwith the new authentication state of the user.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/crashlytics/android-setup.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n> If you're migrating from Fabric, make sure you remove the `fabric.properties` file from your Android project. If you do not do this you will not receive crash reports on the Firebase console.\n\n# Adding Firebase Crashlytics Gradle Tools\n\nThese steps are required, if you do not add these your app will most likely crash at startup with the following Error:\n\n\"The Crashlytics build ID is missing. This occurs when Crashlytics tooling is absent from your app's build configuration.\nPlease review Crashlytics onboarding instructions and ensure you have a valid Crashlytics account.\"\\_\n\n## 1. Add the Google repository (if it's not there already)\n\nAdd the following line to the `android/build.gradle` file :\n\n```groovy\n// ..\nbuildscript {\n  // ..\n  repositories {\n    // ..\n    google()\n  }\n  // ..\n}\n```\n\n## 2. Add the Firebase Crashlytics Plugin dependency\n\nAdd the following dependency to the `android/build.gradle` file:\n\n```groovy\n// ..\nbuildscript {\n  // ..\n  dependencies {\n    // ..\n    classpath 'com.google.firebase:firebase-crashlytics-gradle:2.0.0'\n  }\n  // ..\n}\n```\n\n## 3. Apply the Firebase Crashlytics Plugin to your app\n\nApply the `com.google.firebase.crashlytics` plugin by adding the following to the top of your `android/app/build.gradle` file:\n\n    apply plugin: 'com.android.application'\n    apply plugin: 'com.google.gms.google-services' // apply after this line\n    apply plugin: 'com.google.firebase.crashlytics'\n    // ..\n\n## 4. (Optional) Enable Crashlytics NDK reporting\n\nCrashlytics NDK reporting allows you to capture Native Development Kit crashes, e.g. in React Native this will capture\ncrashes originating from the Yoga layout engine.\n\nAdd the `firebaseCrashlytics` block line to the `android/app/build.gradle` file:\n\n```groovy\nandroid {\n    // ...\n\n    buildTypes {\n        release {\n            /* Add the firebaseCrashlytics extension (by default,\n            * it's disabled to improve build speeds) and set\n            * nativeSymbolUploadEnabled to true. */\n\n            firebaseCrashlytics {\n                nativeSymbolUploadEnabled true\n            }\n            // ...\n        }\n    }\n}\n```\n\n## 5. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/crashlytics/crash-reports.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Overview\n\nOnce you have Crashlytics up and running in your app, you can navigate to Crashlytics in your Firebase Console underneath\n'Quality' and start reviewing the reports as they come in. If this page still tells you to setup, build or run your app\nthen you have not correctly setup Crashlytics in your app (see [Usage](/crashlytics/usage)).\n\n> Keep in mind when testing out Crashlytics that Crashlytics is [disabled by default in debug mode](crashlytics/usage#crashlytics-in-debug-mode).\n\nUpon running the first two examples under [usage](crashlytics/usage), you will be shown a display similar to following image.\n![](https://i.imgur.com/YIQ88ZF.png)\nIn this example the [Crash Attributes](crashlytics/usage#crash-attributes) example was ran four times and the [Error Reports](#error-reports) example three times, in addition to several miscellaneous exceptions that have occurred during the write-up.\n\n> If you are certain that your app has produced error reports, but none are visible, try restarting your app fully. Crashlytics only uploads reports upon launching the app.\n\n## Issues\n\nUnder issues, Firebase has gathered all the reports from your app and organized them into separate issues, where each\nissue is a unique crash or stack trace in your app. One of the issues visible in the example shown originates from `CrashTest.java`,\nwhich is the Android module responsible for testing Crashlytics through the `crash` method, throwing an uncaught exception\nto crash the app. Using this method on the same platform will always add reports to the same issue.\n\n# Managing issues\n\nBy clicking on a specific issue, you can view its statistics and all the associated reports in more detail. In this example\nwe're viewing the `CrashTest.java` issue.\n\n![Crash Example](https://i.imgur.com/XYBNuJx.png)\n\nHere you're shown the breakdown of this issue by date, device and operating system. On the bottom you can browse specific\nreports and view their specific contents. We have selected the logs part of the report, showing the two custom log messages\nthat our example generated. Note that there is a third `Crash Test` log automatically generated by Crashlytics upon using the\n`crash` method. By navigating to data you can view information about the platform where the report was generated and information\nabout the associated user. Under keys you can see the custom attributes that we have attached to the report.\n\n## Closing issues\n\nNote that in the top right there is a button that says 'Close'. After having addressed an issue you can close it, allowing\nyou to filter it out in the overview by selecting 'Open' under 'Issue state', when clicking on the 'Filter issues' button.\nThis is visible in the first example, where we're displaying only 3 relevant non-fatal events out of the 12 that occurred.\nWhen the same issue re-occurs, it will automatically open again. By clicking the arrow next to the button we can mute the\nissue, preventing this from happening.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/crashlytics/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/crashlytics/installation.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/database/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/database/offline-support.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nThe Realtime Database provides support for offline environments. By default, data will be stored locally on your device\nand automatically managed by the Firebase SDKs.\n\n# Enabling Persistence\n\nPersistence is disabled by default when using Realtime Database, however it\n[can be changed to be enabled by default in the firebase.json](/database/usage#enabling-persistence). You can also enable persistence programmatically, by calling the `setPersistenceEnabled`\nas early on in your application code as possible:\n\n```js\n// index.js\nimport { AppRegistry } from 'react-native';\nimport database from '@react-native-firebase/database';\n\ndatabase()\n  .setPersistenceEnabled(true)\n  .then(() => console.log('Realtime Database persistence enabled'));\n\nAppRegistry.registerComponent('app', () => App);\n```\n\n# Going offline\n\nThe API provides a `goOffline` method to force the Realtime Database SDK to go offline, which can be useful for testing.\n\n```js\nimport database from '@react-native-firebase/database';\n\nawait database().goOffline();\n```\n\nOnce offline, all operations will continue to execute, instead using a local instance of your database to perform writes to.\nFor example, we write to a record which has a listener whilst offline allowing the listener to be called with the updated data:\n\n```jsx\nimport React, { useEffect } from 'react';\nimport database from '@react-native-firebase/database';\n\nfunction App() {\n  useEffect(() => {\n    const userAgeRef = database().ref('/users/123/age');\n\n    userAgeRef.on('value', snapshot => {\n      console.log('Users age: ', snapshot.val());\n    });\n\n    database()\n      .goOffline()\n      .then(() => {\n        return userRef.set(32);\n      })\n      .then(() => {\n        console.log('User updated whilst offline.');\n      });\n  }, []);\n}\n```\n\nThe above code will first execute the `on` listener with data from the remote database.\n\nOnce offline, the `set` method on the reference node will `locally` be set to a new value.\n\nThe `on` listener\nhowever will now subscribe to the local database and provide the new value.\n\nThis provides the ability to write code which works in both an online and offline environment without worrying about\ndata synchronization.\n\n# Going online\n\nThe `goOnline` method re-connects the Realtime Database with the remote database. Any locally written changes performed\nwhilst offline will be automatically synchronized with the remote database.\n\n```js\nimport database from '@react-native-firebase/database';\n\nawait database().goOnline();\n```\n\n# Local persistence size\n\nBy default Firebase Database will use up to `10MB` of disk space to cache data. If the cache grows beyond this size,\nFirebase Database will start removing data that hasn't been recently used. If you find that your application caches too\nlittle or too much data, call the `setPersistenceCacheSizeBytes` method to update the default cache size:\n\n```js\nimport database from '@react-native-firebase/database';\n\nawait database().setPersistenceCacheSizeBytes(2000000); // 2MB\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/database/presence-detection.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nRealtime Database provides the ability to trigger events on the Firebase servers whenever a device is disconnected. This\ncould be whenever a user has no access to a network or when they quit the app.\n\nOne use-case using this functionality is to build a simple presence detection system, whereby we can hold a realtime list\nof users currently online within our application. This could be useful when building a chat application\nand you wish to view which of your users are currently online.\n\n# Setup\n\nTo get started, we first need a location to store our online users.\n\nTo keep things simple we'll assume the user is authenticated (e.g. with [Firebase Authentication](/auth)) so we can use their unique user identifier.\n\nWhenever the application opens, [write a new value](/database/usage#writing-data) on a reference node (e.g. `/online/:userId`):\n\n```jsx\nimport React, { useEffect } from 'react';\nimport auth from '@react-native-firebase/auth';\nimport database from '@react-native-firebase/database';\n\nfunction App() {\n  useEffect(() => {\n    // Assuming user is logged in\n    const userId = auth().currentUser.uid;\n\n    const reference = database().ref(`/online/${userId}`);\n\n    // Set the /users/:userId value to true\n    reference.set(true).then(() => console.log('Online presence set'));\n  }, []);\n}\n```\n\nWhenever the application boots and can connect to the remote server, the value will be written to the database indicating the user is online.\n\n# On Disconnect\n\nNext we need to remove the value when our user disconnects. Typically you would execute this functionality from the device\nitself, however this presents a problem.\n\nIf the device suddenly goes offline, or is quit, the app can no longer execute code or connect to Firebase. Luckily, the\nRealtime Database API provides a way to execute code on the Firebase servers whenever the connection between an app & server\nis lost.\n\nThe `onDisconnect` method on a reference returns a new [`OnDisconnect`](/reference/database/ondisconnect) instance. This instance\nprovides functionality to remove or set data whenever a client disconnects. Using the\n[`remove`](/reference/database/ondisconnect#remove) method we can remove the node on the database if the client disconnects:\n\n```jsx\nimport React, { useEffect } from 'react';\nimport auth from '@react-native-firebase/auth';\nimport database from '@react-native-firebase/database';\n\nfunction App() {\n  useEffect(() => {\n    // Assuming user is logged in\n    const userId = auth().currentUser.uid;\n\n    const reference = database().ref(`/online/${userId}`);\n\n    // Set the /users/:userId value to true\n    reference.set(true).then(() => console.log('Online presence set'));\n\n    // Remove the node whenever the client disconnects\n    reference\n      .onDisconnect()\n      .remove()\n      .then(() => console.log('On disconnect function configured.'));\n  }, []);\n}\n```\n\nThe above code demonstrates a very simple but powerful way to track which users are currently online.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/dynamic-links/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/firestore/emulator.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nYou can test your app and its Firestore implementation with an emulator which is built to mimic the behavior of Cloud Firestore. This means you can connect your app directly to the emulator to perform integration testing or QA without touching production data.\n\nFor example, you can connect your app to the emulator to safely read and write documents in testing.\n\n## Running the emulator\n\nTo be able to mimic the behavior of Cloud Firestore, you need to run the emulator. This is effectively a server that will receive and send requests in lieu of Cloud Firestore. This is achieved by running the following commands:\n\n```bash\n// install the Firebase CLI which will run the emulator\ncurl -sL firebase.tools | bash\n\n// run this command to start the emulator, it will also install it if this is your first time running the command\nfirebase emulators:start --only firestore\n```\n\nYou should see a `firestore-debug.log` file in the directory you ran the command which will have a log of all the requests.\n\n# Connect to emulator from your app\n\nYou need to configure the following property as soon as possible in the startup of your application:\n\n```jsx\nimport '@react-native-firebase/app';\nimport firestore from '@react-native-firebase/firestore';\n\nconst db = firestore();\n\n// set the host property to connect to the emulator\n// set these before any read/write operations occur to ensure it doesn't affect your Cloud Firestore data!\n\ndb.settings({ host: 'localhost:8080' });\n```\n\n# Clear locally stored emulator data\n\nRun the following command to clear the data accumulated locally from using the emulator. Please note that you have to insert your project id in the request at this point `[INSERT YOUR PROJECT ID HERE]`.\n\n```bash\ncurl -v -X DELETE \"http://localhost:8080/emulator/v1/projects/[INSERT YOUR PROJECT ID HERE]/databases/(default)/documents\"\n```\n\nThere are more things that can be achieved with the emulator such as using local rules to test the integrity & security of your database. For further information, please follow the Firebase emulator documentation [here](https://firebase.google.com/docs/emulator-suite).\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/firestore/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/firestore/usage-with-flatlists.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nCloud Firestore provides out of the box support for subscribing to [realtime changes](/firestore/usage#realtime-changes)\non a collection of documents. Whilst building apps with Cloud Firestore, you can easily display lists of a collections\ndocuments using a [`FlatList`](https://reactnative.dev/docs/flatlist.html).\n\nA `FlatList` accepts an array of data, and displays the results in a performance friendly scrollable list. By integrating\na realtime listener with the `FlatList`, whenever data changes without our database it'll automatically and efficiently update\non our application.\n\n# Setup state\n\nFirst, setup a component which will display the list of data. The component will have 2 separate states; `loading` and\n`users`:\n\n```jsx\nimport React, { useState } from 'react';\nimport { ActivityIndicator } from 'react-native';\n\nfunction Users() {\n  const [loading, setLoading] = useState(true); // Set loading to true on component mount\n  const [users, setUsers] = useState([]); // Initial empty array of users\n\n  if (loading) {\n    return <ActivityIndicator />;\n  }\n\n  // ...\n}\n```\n\n# `useEffect` hook\n\nNext, we'll setup a hook with `useEffect`. This hook will trigger when our components mount, and we'll then subscribe to\nthe \"Users\" collection documents:\n\n```jsx\nimport React, { useState, useEffect } from 'react';\nimport { ActivityIndicator } from 'react-native';\nimport firestore from '@react-native-firebase/firestore';\n\nfunction Users() {\n  const [loading, setLoading] = useState(true); // Set loading to true on component mount\n  const [users, setUsers] = useState([]); // Initial empty array of users\n\n  useEffect(() => {\n    const subscriber = firestore()\n      .collection('Users')\n      .onSnapshot(() => {\n        // see next step\n      });\n\n    // Unsubscribe from events when no longer in use\n    return () => subscriber();\n  }, []);\n\n  if (loading) {\n    return <ActivityIndicator />;\n  }\n\n  // ...\n}\n```\n\n# Transforming data\n\nWith our event handler setup, we can now iterate over the collection documents. Whilst iterating, we need to create an\narray of data a `FlatList` accepts. At a minimum, this is an object with a unique `key` property. For this unique property,\nwe can use the `id` of a document:\n\n```js\nuseEffect(() => {\n  const subscriber = firestore()\n    .collection('Users')\n    .onSnapshot(querySnapshot => {\n      const users = [];\n\n      querySnapshot.forEach(documentSnapshot => {\n        users.push({\n          ...documentSnapshot.data(),\n          key: documentSnapshot.id,\n        });\n      });\n\n      setUsers(users);\n      setLoading(false);\n    });\n\n  // Unsubscribe from events when no longer in use\n  return () => subscriber();\n}, []);\n```\n\nOnce the initial set of documents is returned, we update the `users` state with our raw object data and set the `loading`\nstate to `false`. We can now\n\n# Integration\n\nWith the raw user data in local state, we can now pass this to the `FlatList`:\n\n```jsx\nimport React, { useState, useEffect } from 'react';\nimport { ActivityIndicator, FlatList, View, Text } from 'react-native';\nimport firestore from '@react-native-firebase/firestore';\n\nfunction Users() {\n  // ...\n\n  if (loading) {\n    return <ActivityIndicator />;\n  }\n\n  return (\n    <FlatList\n      data={users}\n      renderItem={({ item }) => (\n        <View style={{ height: 50, flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n          <Text>User ID: {item.id}</Text>\n          <Text>User Name: {item.name}</Text>\n        </View>\n      )}\n    />\n  );\n}\n```\n\nWith little effort, our list will automatically update in realtime whenever a document is added/removed/modified!\nThis functionality can be further manipulated to respond to user filters via [Querying](/firestore/usage#querying) if required.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/functions/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/functions/writing-deploying-functions.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nCloud Functions are a powerful asset to a developers workflow, allowing you to build complex backend tasks with\nminimal maintenance overhead. The following page outlines the steps required for writing, testing & deploying Cloud Functions to your Firebase project.\n\n## Environment Setup\n\nFirebase provides a CLI which is required to build and deploy Cloud Functions. To install the CLI, install the `firebase-tools` package globally on your computer from your terminal:\n\n```bash\nnpm install -g firebase-tools\n```\n\nOnce installed, login to Firebase with the CLI. This process will automatically open a browser instance giving you the ability to login to your Firebase account.\n\n```bash\nfirebase login\n```\n\nOnce logged in, create a new directory on your development environment. This will be used as our working directory\nwhere our Cloud Functions will be written and deployed from. Within this directory, run the following command from your\nterminal to initialize a new project structure:\n\n```bash\nfirebase init functions\n```\n\nYou will be offered two options for language support, for this tutorial select JavaScript. Allow the CLI to install\ndependencies using NPM. Once complete your project structure will look like this:\n\n    myproject\n     +- .firebaserc    # Hidden file that helps you quickly switch between\n     |                 # projects with `firebase use`\n     |\n     +- firebase.json  # Describes properties for your project\n     |\n     +- functions/     # Directory containing all your functions code\n          |\n          +- .eslintrc.json  # Optional file containing rules for JavaScript linting.\n          |\n          +- package.json  # NPM package file describing your Cloud Functions code\n          |\n          +- index.js      # main source file for your Cloud Functions code\n          |\n          +- node_modules/ # directory where your dependencies (declared in\n                           # package.json) are installed\n\n## Writing a Function\n\nThe Firebase CLI has created a project structure and also installed a number of dependencies which will be used to build our Cloud Functions.\n\nTo enable us to mock some fake data to use in the deployed functions, lets use the [`faker`](https://www.npmjs.com/package/faker)\nlibrary to create mock data.\n\n```bash\ncd functions/\nnpm install faker\n```\n\nNow it's time to write our Cloud Function. Open up the generated `functions/index.js` file in your chosen editor.\nThe CLI has already imported the `firebase-functions` package required to build a Cloud Function. Firebase uses\n[named exports](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export) to help identify\nfunctions. These exports are used to build the API endpoint name which will be accessible from our React Native application.\n\nFor this tutorial, we are creating a product listing API. Go ahead and create a new HTTPS callable named function called `listProducts`:\n\n```js\n// functions/index.js\nconst functions = require('firebase-functions');\n\nexports.listProducts = functions.https.onCall((data, context) => {\n  // ...\n});\n```\n\nThe `onCall` callback returns two objects:\n\nWe can now return an array of products, generated from the `faker` library. As we are mocking a data set, it's important\nto keep consistent results for each request. The data should be generated before the request is received, rather than a\nnew data set being generated on each request:\n\n```js\n// functions/index.js\nconst functions = require('firebase-functions');\nconst faker = require('faker');\n\n// Initialize products array\nconst products = [];\n\n// Max number of products\nconst LIMIT = 100;\n\n// Push a new product to the array\nfor (let i = 0; i < LIMIT; i++) {\n  products.push({\n    name: faker.commerce.productName(),\n    price: faker.commerce.price(),\n  });\n}\n\nexports.listProducts = functions.https.onCall((data, context) => {\n  return products;\n});\n```\n\n### Testing your function\n\nBefore deploying our functions project, we can run the `serve` command which builds a locally accessible instance of our\nCloud Functions. Run the following command from within the `functions/` directory:\n\n```bash\ncd functions/\nnpm run serve\n```\n\nOnce booted, the CLI will be provide a local web server with the products endpoint openly available, e.g:\n\n    functions: listProducts: http://localhost:5000/rnfirebase-demo/us-central1/listProducts\n\nIn your terminal (or browser), access the endpoint provided. Our list of generated products is ready for use.\n\n    curl -i -H \"Accept: application/json\" -H \"Content-Type: application/json\" -X GET  http://localhost:5000/rnfirebase-demo/us-central1/listProducts\n\n### Security\n\nBy default the endpoint will be publicly accessible when deployed. Firebase offers an out-of-the-box solution for handling\nauthentication, which integrates with the [Authentication](/auth) module. To secure our endpoint for authenticated users only, check whether the `auth`\nproperty exists on the function execution context:\n\n```js\nexports.listProducts = functions.https.onCall((data, context) => {\n  if (!context.auth) {\n    throw new functions.https.HttpsError('unauthenticated', 'Endpoint requires authentication!');\n  }\n\n  return products;\n});\n```\n\nWhen calling the function without authentication, an error response will be returned to the caller.\n\nIf the user is authenticated, we can access the users data via the `context.auth` property. For example their unique user identifier will be available by accessing `context.auth.uid`.\n\n### Handling function arguments\n\nA common requirement for endpoints is calling the endpoint with custom parameters. For example, rather than returning a list\nof 1000 products, we can paginate the data by passing in arguments when calling our function.\n\nThese arguments can be accessed via the `data` property when the function is executed, let's update our function code to support pagination arguments:\n\n```js\nexports.listProducts = functions.https.onCall((data, context) => {\n  const { page = 1, limit = 10 } = data;\n\n  const startAt = (page - 1) * limit;\n  const endAt = startAt + limit;\n\n  return products.slice(startAt, endAt);\n});\n```\n\n## Deploying Functions\n\nOnce your functions are ready to be deployed, the project provides a `deploy` script which will upload all of your code\nonto the Firebase infrastructure and automatically provision production ready endpoints. Within the project, run the\n`deploy` script from the `functions` directory:\n\n```bash\ncd functions/\nnpm run deploy\n```\n\nOnce complete, your Cloud Function will also be available from a publicly accessible endpoint if required, for example:\n\n    https://us-central1-rnfirebase-demo-23aa8.cloudfunctions.net/listProducts\n\n### Calling your function\n\nOnce your function has been deployed you can now call it through the React Native Firebase Functions SDK in your application:\n\n```js\nimport { firebase } from '@react-native-firebase/functions';\n\n// ...\n\n// note the name of our deployed function, 'listProducts', is referenced here:\nconst { data } = await firebase.functions().httpsCallable('listProducts')({\n  page: 1,\n  limit: 15,\n});\n\n// ...\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/iid/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/in-app-messaging/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/messaging/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/messaging/ios-permissions.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n## Understanding permissions\n\nBefore diving into requesting notification permissions from your users, it is important to understand how iOS handles permissions.\n\nNotifications cannot be shown to users if the user has not \"granted\" your application permission. The overall notification permission of a single application can be either be \"not determined\", \"granted\" or \"declined\". Upon installing a new application, the default status is \"not determined\".\n\nIn order to receive a \"granted\" status, you must request permission from your user (see below). The user can either accept or decline your request to grant permissions. If granted, notifications will be displayed based on the permission settings which were requested.\n\nIf the user declines the request, you cannot re-request permission, trying to request permission again will immediately return a \"denied\" status without any user interaction - instead the user must manually enable notification permissions from the iOS Settings UI.\n\n## Requesting permissions\n\nAs explained in the [Usage](/messaging#ios---requesting-permissions) documentation, permission\nmust be requested from your users in order to display remote notifications from FCM, via the\n`requestPermission` API:\n\n```js\nimport messaging from '@react-native-firebase/messaging';\n\nasync function requestUserPermission() {\n  const authorizationStatus = await messaging().requestPermission();\n\n  if (authorizationStatus) {\n    console.log('Permission status:', authorizationStatus);\n  }\n}\n```\n\nOnce a user has selected a permission status, iOS prevents the permission dialog from being displayed again. This allows the users of your application full control of how notifications are handled:\n\n-   If the user declines permission, they must manually allow notifications via the Settings UI for your application.\n-   If the user has accepted permission, notifications will be shown using the settings requested (e.g. with or without sound).\n\n### Permission settings\n\nAlthough overall notification permission can be granted, the permissions can be further broken down into settings.\n\nSettings are used by the device to control notifications behavior, for example alerting the user with sound. When requesting permission, you can provide a custom object of settings if you wish to override the defaults. This is demonstrated in the following example:\n\n```js\nawait messaging().requestPermission({\n  sound: false,\n  announcement: true,\n  // ... other permission settings\n});\n```\n\nThe full list of permission settings can be seen in the table below along with their default values:\n\n| Permission     | Default | Description                                                                                                                   |\n| -------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------- |\n| `alert`        | `true`  | Sets whether notifications can be displayed to the user on the device.                                                        |\n| `announcement` | `false` | If enabled, Siri will read the notification content out when devices are connected to AirPods.                                |\n| `badge`        | `true`  | Sets whether a notification dot will appear next to the app icon on the device when there are unread notifications.           |\n| `carPlay`      | `true`  | Sets whether notifications will appear when the device is connected to [CarPlay](https://www.apple.com/ios/carplay/).         |\n| `provisional`  | `false` | Sets whether provisional permissions are granted. See [Provisional permission](#provisional-permission) for more information. |\n| `sound`        | `true`  | Sets whether a sound will be played when a notification is displayed on the device.                                           |\n\nThe settings provided will be stored by the device and will be visible in the iOS Settings UI for your application.\n\nIf the permission dialog has already been presented to the user and you wish to update the existing permission settings\n(e.g. enabling sound), the setting will be silently updated and the `requestPermission` call will instantly resolve without showing a dialog.\n\n#### Reading current status\n\nIn some cases, you may wish to read the current permission status. The `requestPermission`\nAPI used above resolves an enum that returns the current status.\n\nFor example:\n\n```js\nimport messaging from '@react-native-firebase/messaging';\n\nasync function checkApplicationPermission() {\n  const authorizationStatus = await messaging().requestPermission();\n\n  if (authorizationStatus === messaging.AuthorizationStatus.AUTHORIZED) {\n    console.log('User has notification permissions enabled.');\n  } else if (authorizationStatus === messaging.AuthorizationStatus.PROVISIONAL) {\n    console.log('User has provisional notification permissions.');\n  } else {\n    console.log('User has notification permissions disabled');\n  }\n}\n```\n\nThe value returned is a number value, which can be mapped to one of the following values from `messaging.AuthorizationStatus`:\n\n-   `-1` = `messaging.AuthorizationStatus.NOT_DETERMINED`: Permission has not yet been requested for your application.\n-   `0` = `messaging.AuthorizationStatus.DENIED`: The user has denied notification permissions.\n-   `1` = `messaging.AuthorizationStatus.AUTHORIZED`: The user has accept the permission & it is enabled.\n-   `2` = `messaging.AuthorizationStatus.PROVISIONAL`: [Provisional authorization](#provisional-authorization) has been granted.\n\nTo help improve the chances of the user granting your app permission, it is recommended that permission is requested at a time which makes\nsense during the flow of your application (e.g. starting a new chat), where the user would expect to receive such notifications.\n\nIt is also possible to fetch the current permission status without requesting permission, by calling the `hasPermission` API instead.\n\n### Provisional authorization\n\nDevices on iOS 12+ can use provisional authorization. This type of permission system allows for notification\npermission to be instantly granted without displaying a dialog to your user. The permission allows notifications to be displayed quietly;\n\n-   meaning they're only visible within the device notification center.\n\nTo enable provisional notifications, pass an object to the `requestPermission` method, with the `provisional` key set to `true`:\n\n```js\nawait messaging().requestPermission({\n  provisional: true,\n});\n```\n\nUsers can then choose a permission option via the notification itself, and select whether they can continue to display quietly, display prominently or not at all.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/messaging/notifications.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nNotifications are an important tool used on the majority of Android & iOS applications, used to improve user\nexperience, used to engage users with your application and much more. The Cloud Messaging module provides basic support for\ndisplaying and handling notifications.\n\n> Looking for an advanced local notifications library which integrates with FCM? [Check out Notifee!](https://notifee.app)\n\n# Displaying a Notification\n\nThe Firebase Cloud Messaging SDKs for Android and iOS allow for notifications to be displayed on devices when the application\nis either quit or in the background. The Firebase Console, Firebase Admin SDKs and REST API all allow a `notification`\nproperty to be attached to a message.\n\nIf an incoming message with this property exists, and the app is not currently visible (quit or in the background),\na notification is displayed on the device. However, if the application is in the foreground, an event will be delivered\ncontaining the notification data and no visible notification will be displayed. See the [Usage](/messaging) documentation\nto learn more about handling events.\n\n## Via Firebase Console\n\nThe [Firebase Console provides a simple UI](https://console.firebase.google.com/project/_/notification) to allow devices\nto display a notification. Using the console, you can:\n\n-   Send a basic notification with custom text and images.\n-   Target applications which have been added to your project.\n-   Schedule notifications to display at a later date.\n-   Send recurring notifications.\n-   Assign conversion events for your analytical tracking.\n-   A/B test user interaction (called \"experiments\").\n-   Test notifications on your development devices.\n\nThe Firebase Console automatically sends a message to your devices containing a `notification` property which is handled\nby the React Native Firebase Cloud Messaging module. See [Handling Interaction](#handling-interaction) to learn about how\nto support user interaction.\n\n## Via Admin SDKs\n\nThe various Firebase Admin SDKs allow you to send messages to your users. If these messages also contain notification\noptions, the React Native Firebase Cloud Messaging module will automatically display these notifications.\n\nFor example, when using the [`firebase-admin`](https://www.npmjs.com/package/firebase-admin) package in a Node.js environment\nto send [messages from a server](/messaging/server-integration), a `notification` property can be added to the message payload:\n\n```js\nawait admin.messaging().sendMulticast({\n  tokens: [\n    /* ... */\n  ], // ['token_1', 'token_2', ...]\n  notification: {\n    title: 'Basic Notification',\n    body: 'This is a basic notification sent from the server!',\n    imageUrl: 'https://my-cdn.com/app-logo.png',\n  },\n});\n```\n\nThe Cloud Messaging module will intercept these messages and if the `notification` property is available, it will display\na notification on the device (if the app is not in the foreground). Messages sent with both a `notification` and `data` property\nwill display a notification and also trigger the `onMessage` handlers (see [Usage](/messaging)).\n\nThe different Admin SDKs available have similar implementation details on how to add a custom `notification` property to\nthe FCM payload, however the Cloud Messaging module will handle all requests. To learn more, view the\n[Firebase Admin SDK documentation](https://firebase.google.com/docs/reference/admin) for your chosen admin SDK. For those using the\nHTTP implementation, view the [REST Cloud Messaging](https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages)\nreference.\n\n## Via REST\n\nIf you are unable to use a [Firebase Admin SDK](https://firebase.google.com/docs/reference/admin), Firebase also provides\nsupport for sending messages to devices via a POST request:\n\n```HTTP\nPOST https://fcm.googleapis.com/v1/projects/myproject-b5ae1/messages:send HTTP/1.1\n\nContent-Type: application/json\nAuthorization: Bearer ya29.ElqKBGN2Ri_Uz...HnS_uNreA\n\n{\n   \"message\":{\n      \"token\":\"bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...\",\n      \"data\":{},\n      \"notification\":{\n        \"body\":\"This is an FCM notification message!\",\n        \"title\":\"FCM Message\"\n      }\n   }\n}\n```\n\nTo learn more about the REST API, view the [Firebase documentation](https://firebase.google.com/docs/cloud-messaging/send-message),\nand select the \"REST\" tab under the code examples.\n\n# Handling Interaction\n\nWhen a user interacts with your notification by pressing on it, the default behavior is to open the application (since\nnotifications via FCM only display when the application is in the background, the application will always open).\n\nIn many cases, it is useful to detect whether the application was opened by pressing on a notification (so you\ncould open a specific screen for example). The API provides two APIs for handling interaction:\n\n-   `getInitialNotification`: When the application is opened from a quit state.\n-   `onNotificationOpenedApp`: When the application is running, but in the background.\n\nTo handle both scenarios, the code can be executed during setup. For example, using [React Navigation](https://reactnavigation.org/)\nwe can set an initial route when the app is opened from a quit state, and push to a new screen when the app is in a background state:\n\n```jsx\nimport React, { useState, useEffect } from 'react';\nimport messaging from '@react-native-firebase/messaging';\nimport { NavigationContainer, useNavigation } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\n\nconst Stack = createStackNavigator();\n\nfunction App() {\n  const navigation = useNavigation();\n  const [loading, setLoading] = useState(true);\n  const [initialRoute, setInitialRoute] = useState('Home');\n\n  useEffect(() => {\n    // Assume a message-notification contains a \"type\" property in the data payload of the screen to open\n\n    messaging().onNotificationOpenedApp(remoteMessage => {\n      console.log(\n        'Notification caused app to open from background state:',\n        remoteMessage.notification,\n      );\n      navigation.navigate(remoteMessage.data.type);\n    });\n\n    // Check whether an initial notification is available\n    messaging()\n      .getInitialNotification()\n      .then(remoteMessage => {\n        if (remoteMessage) {\n          console.log(\n            'Notification caused app to open from quit state:',\n            remoteMessage.notification,\n          );\n          setInitialRoute(remoteMessage.data.type); // e.g. \"Settings\"\n        }\n        setLoading(false);\n      });\n  }, []);\n\n  if (loading) {\n    return null;\n  }\n\n  return (\n    <NavigationContainer>\n      <Stack.Navigator initialRouteName={initialRoute}>\n        <Stack.Screen name=\"Home\" component={HomeScreen} />\n        <Stack.Screen name=\"Settings\" component={SettingsScreen} />\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}\n```\n\nThe call to `getInitialNotification` should happen within a React lifecycle method after mounting (e.g. `componentDidMount` or `useEffect`).\nIf it's called too soon (e.g. within a class constructor or global scope), the notification data may not be available.\n\n**Quick Tip:** On `Android` you can test receiving remote notifications on the emulator but on `iOS` you will need to use a real device as the iOS simulator does not support receiving remote notifications.\n\n# Notifee - Advanced Notifications\n\nFCM provides support for displaying basic notifications to users with minimal integration required. If however you require\nmore advanced notifications you need to integrate with a 3rd party local notifications package, such as [Notifee](https://notifee.app).\n\n## Android Features\n\n-   [Advanced channel and group management](https://notifee.app/react-native/docs/android/channels).\n-   Custom appearance with [HTML text styling](https://notifee.app/react-native/docs/android/appearance#text-styling), [custom icons](https://notifee.app/react-native/docs/android/appearance#icons), [badge support](https://notifee.app/react-native/docs/android/appearance#badges), [colors](https://notifee.app/react-native/docs/android/appearance#color) and more.\n-   Behavior management such as [custom sounds](https://notifee.app/react-native/docs/android/behaviour#sound), [vibration patterns](https://notifee.app/react-native/docs/android/behaviour#vibration), device [notification light management](https://notifee.app/react-native/docs/android/behaviour#lights) and more.\n-   Displaying on-going [Foreground Service Notifications](https://notifee.app/react-native/docs/android/foreground-service) for dealing with long-running background tasks.\n-   Advanced [interaction handling](https://notifee.app/react-native/docs/android/interaction) with action buttons, quick reply features and more.\n-   Support for built in styling; [Big Picture Style](https://notifee.app/react-native/docs/android/styles#big-picture), [Big Text Style](https://notifee.app/react-native/docs/android/styles#big-text), [Inbox Style](https://notifee.app/react-native/docs/android/styles#inbox) & [Messaging Style](https://notifee.app/react-native/docs/android/styles#messaging) notifications.\n-   Adding [Progress Indicators](https://notifee.app/react-native/docs/android/progress-indicators) & [Timers](https://notifee.app/react-native/docs/android/timers) to your notification.\n\n## iOS Features\n\n-   Advanced [Permission](https://notifee.app/react-native/docs/ios/permissions) management.\n-   Behavior management such as [custom sounds](https://notifee.app/react-native/docs/ios/behaviour#sound) and [critical notifications](https://notifee.app/react-native/docs/ios/behaviour#critical-notifications).\n-   Creating [actions & categories](https://notifee.app/react-native/docs/ios/categories).\n\nTo learn more about integrating FCM with Notifee, view the [integration](https://notifee.app/react-native/docs/integrations/fcm) documentation.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/messaging/server-integration.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nThe Cloud Messaging module provides the tools required to enable you to send custom messages directly from your own servers.\nFor example, you could send a FCM message to a specific device when a new chat message is saved to your database\nand display a [notification](/messaging/notifications) or update local device storage so the message is instantly available.\n\nFirebase provides a number of SDKs in different languages such as [Node.JS](https://www.npmjs.com/package/firebase-admin),\n[Java](https://firebase.google.com/docs/reference/admin/java/reference/com/google/firebase/messaging/package-summary),\n[Python](https://firebase.google.com/docs/reference/admin/python/firebase_admin.messaging),\n[C#](https://firebase.google.com/docs/reference/admin/dotnet/namespace/firebase-admin/messaging) and\n[Go](https://godoc.org/firebase.google.com/go/messaging). It also supports sending messages over\n[HTTP](https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages). These methods allow you to send messages\ndirectly to your user's devices via the FCM servers.\n\n# Device tokens\n\nTo send a message to a device, you must access its unique token. A token is automatically generated by the device and\ncan be accessed using the Cloud Messaging module. The token should be saved inside of your systems data-store and should\nbe easily accessible when required.\n\nThe examples below use a [Cloud Firestore](/firestore) database to store and manage the tokens, and [Authentication](/auth)\nto manage the users identity. You can however use any datastore or authentication method of your choice.\n\n> If using iOS, ensure you have read and followed the steps in [registered with FCM](/messaging#ios---registering-devices-with-fcm) and [requested user permission](#ios---requesting-permissions) before trying to receive messages!\n\n## Saving tokens\n\nOnce your application has started, you can call the `getToken` method on the Cloud Messaging module to get the unique\ndevice token (if using a different push notification provider, such as Amazon SNS, you will need to call `getAPNSToken` on iOS):\n\n```jsx\nimport React, { useEffect } from 'react';\nimport messaging from '@react-native-firebase/messaging';\nimport auth from '@react-native-firebase/auth';\nimport firestore from '@react-native-firebase/firestore';\nimport { Platform } from 'react-native';\n\nasync function saveTokenToDatabase(token) {\n  // Assume user is already signed in\n  const userId = auth().currentUser.uid;\n\n  // Add the token to the users datastore\n  await firestore()\n    .collection('users')\n    .doc(userId)\n    .update({\n      tokens: firestore.FieldValue.arrayUnion(token),\n    });\n}\n\nfunction App() {\n  useEffect(() => {\n    // Get the device token\n    messaging()\n      .getToken()\n      .then(token => {\n        return saveTokenToDatabase(token);\n      });\n      \n    // If using other push notification providers (ie Amazon SNS, etc)\n    // you may need to get the APNs token instead for iOS:\n    // if(Platform.OS == 'ios') { messaging().getAPNSToken().then(token => { return saveTokenToDatabase(token); }); }\n\n    // Listen to whether the token changes\n    return messaging().onTokenRefresh(token => {\n      saveTokenToDatabase(token);\n    });\n  }, []);\n}\n```\n\nThe above code snippet has a single purpose; storing the device FCM token on a remote database. The `useEffect` is fired\nwhen the `App` component runs and immediately gets the token. It also listens to any events when the device automatically refreshes\nthe token.\n\nInside of the `saveTokenToDatabase` method, we store the token on a record specifically relating to the current user. You may also\nnotice that the token is being added via the `FieldValue.arrayUnion` method. A user can have more than one token (for example using 2 devices)\nso it's important to ensure that we store all tokens in the database.\n\n## Using tokens\n\nWith the tokens stored in a secure datastore, we now have the ability to send messages via FCM to those devices.\n\n> The following example uses the Node.JS `firebase-admin` package to send messages to our devices, however any SDK (listed above)\n> can be used.\n\nGo ahead and setup the [`firebase-tools`](https://www.npmjs.com/package/firebase-admin) library on your server environment.\nOnce setup, our script needs to perform two actions:\n\n1.  Fetch the tokens required to send the message.\n2.  Send a data payload to the devices that the tokens are registered to.\n\nImagine our application being similar to Instagram. Users are able to upload pictures, and other users can \"like\" those pictures.\nEach time a post is liked, we want to send a message to the user that uploaded the picture. The code below simulates a function\nwhich is called with all of the information required when a picture is liked:\n\n```js\n// Node.js\nvar admin = require('firebase-admin');\n\n// ownerId - who owns the picture someone liked\n// userId - id of the user who liked the picture\n// picture - metadata about the picture\n\nasync function onUserPictureLiked(ownerId, userId, picture) {\n  // Get the owners details\n  const owner = admin\n    .firestore()\n    .collection('users')\n    .doc(ownerId)\n    .get();\n\n  // Get the users details\n  const user = admin\n    .firestore()\n    .collection('users')\n    .doc(userId)\n    .get();\n\n  await admin.messaging().sendToDevice(\n    owner.tokens, // ['token_1', 'token_2', ...]\n    {\n      data: {\n        owner: JSON.stringify(owner),\n        user: JSON.stringify(user),\n        picture: JSON.stringify(picture),\n      },\n    },\n    {\n      // Required for background/quit data-only messages on iOS\n      contentAvailable: true,\n      // Required for background/quit data-only messages on Android\n      priority: 'high',\n    },\n  );\n}\n```\n\nData-only messages are sent as low priority on both Android and iOS and will not trigger the `setBackgroundMessageHandler`\nby default. To enable this functionality, you must set the \"priority\" to `high` on Android and enable the\n`content-available` flag for iOS in the message payload.\n\n> If using the FCM REST API, see the [following documentation](https://firebase.google.com/docs/cloud-messaging/http-server-ref) on setting `priority` and `content-available`!\n\nThe `data` property can send an object of key-value pairs totaling `4KB` as string values (hence the `JSON.stringify`).\n\nBack within our application, as explained in the [Usage](/messaging) documentation, our message handlers will receive a\n[`RemoteMessage`](/reference/messaging/remotemessage) payload containing the message details sent from the server:\n\n```jsx\nfunction App() {\n  useEffect(() => {\n    const unsubscribe = messaging().onMessage(async remoteMessage => {\n      const owner = JSON.parse(remoteMessage.data.owner);\n      const user = JSON.parse(remoteMessage.data.user);\n      const picture = JSON.parse(remoteMessage.data.picture);\n\n      console.log(`The user \"${user.name}\" liked your picture \"${picture.name}\"`);\n    });\n\n    return unsubscribe;\n  }, []);\n}\n```\n\nYour application code can then handle messages as you see fit; updating local cache, displaying a [notification](/messaging/notifications)\nor updating UI. The possibilities are endless!\n\n# Send messages to topics\n\nWhen devices [subscribe to topics](/messaging/usage#topics), you can send messages without specifying/storing any device\ntokens.\n\nUsing the `firebase-admin` Admin SDK as an example, we can send a message to devices subscribed to a topic:\n\n```js\nconst admin = require('firebase-admin');\n\nconst message = {\n  data: {\n    type: 'warning',\n    content: 'A new weather warning has been created!',\n  },\n  topic: 'weather',\n};\n\nadmin\n  .messaging()\n  .send(message)\n  .then(response => {\n    console.log('Successfully sent message:', response);\n  })\n  .catch(error => {\n    console.log('Error sending message:', error);\n  });\n```\n\n## Conditional topics\n\nTo send a message to a combination of topics, specify a condition, which is a boolean expression that specifies the target\ntopics. For example, the following condition will send messages to devices that are subscribed to `weather` and either `news`\nor `traffic`:\n\n    'weather' in topics && ('news' in topics || 'traffic' in topics)\n\nTo send a message to this condition, replace the `topic` key with `condition`:\n\n```js\nconst admin = require('firebase-admin');\n\nconst message = {\n  data: {\n    content: 'New updates are available!',\n  },\n  condition: \"'weather' in topics && ('news' in topics || 'traffic' in topics)\",\n};\n\nadmin\n  .messaging()\n  .send(message)\n  .then(response => {\n    console.log('Successfully sent message:', response);\n  })\n  .catch(error => {\n    console.log('Error sending message:', error);\n  });\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-natural-language/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-vision/barcode-scanning.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nBarcode scanning can read data encoded using most standard barcode formats. Barcode scanning happens on the device,\nand doesn't require a network connection. It's a convenient way to pass information from the real world to your app.\n\nThe Machine Learning service is only offered on the device, and no cloud service exists.\n\nGiven an image file, the Barcode Scanning service will attempt to recognize one or more barcodes, offering information\nsuch as:\n\n-   The 4-point coordinates of the barcodes on the image.\n-   The type of barcode (e.g. a phone number, contact information, calendar invite etc).\n\nTo view the full list of information available, view the [`VisionBarcode`](/reference/ml-vision/visionbarcode) documentation.\n\n# On-device Barcode Scanning\n\n## Enable the model\n\nTo enable the mode, set the `ml_vision_barcode_model` key to `true` in your `firebase.json` file:\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"ml_vision_barcode_model\": true\n  }\n}\n```\n\nOnce complete, rebuild your application:\n\n```bash\n# For Android\nnpx react-native run-android\n\n# For iOS\ncd ios/ && pod install --repo-update\nnpx react-native run-ios\n```\n\n## Process\n\nOnce the model has been downloaded, call the `barcodeDetectorProcessImage` method with a path to a local file on your device:\n\n```js\nimport { utils } from '@react-native-firebase/app';\nimport vision, { VisionBarcodeValueType } from '@react-native-firebase/ml-vision';\n\nasync function processBarcodes(localPath) {\n  const barcodes = await vision().barcodeDetectorProcessImage(localPath);\n\n  barcodes.forEach(barcode => {\n    if (barcode.valueType === VisionBarcodeValueType.CALENDAR_EVENT) {\n      console.log('Barcode is a calendar event: ', barcode.calendarEvent);\n    }\n\n    if (barcode.valueType === VisionBarcodeValueType.CONTACT_INFO) {\n      console.log('Barcode contains contact info: ', barcode.contactInfo);\n    }\n\n    if (barcode.valueType === VisionBarcodeValueType.DRIVER_LICENSE) {\n      console.log('Barcode contains drivers license info: ', barcode.driverLicense);\n    }\n\n    if (barcode.valueType === VisionBarcodeValueType.EMAIL) {\n      console.log('Barcode contains email address info: ', barcode.email);\n    }\n\n    if (barcode.valueType === VisionBarcodeValueType.GEO) {\n      console.log('Barcode contains location info: ', barcode.geoPoint);\n    }\n\n    if (barcode.valueType === VisionBarcodeValueType.PHONE) {\n      console.log('Barcode contains phone number info: ', barcode.phone);\n    }\n\n    if (barcode.valueType === VisionBarcodeValueType.SMS) {\n      console.log('Barcode contains SMS info: ', barcode.sms);\n    }\n\n    if (barcode.valueType === VisionBarcodeValueType.URL) {\n      console.log('Barcode contains URL info: ', barcode.url);\n    }\n\n    if (barcode.valueType === VisionBarcodeValueType.WIFI) {\n      console.log('Barcode contains WIFI info: ', barcode.wifi);\n    }\n  });\n}\n\n// Local path to file on the device\nconst localFile = `${utils.FilePath.PICTURES_DIRECTORY}/barcode-document.jpg`;\n\nprocessBarcodes(localFile).then(() => console.log('Finished processing file.'));\n```\n\nTo learn about the types of information the barcode scanner can return, view the\n[`VisionBarcode`](/reference/ml-vision/visionbarcode) documentation.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-vision/face-detection.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nFace detection can detect faces in an image, identify key facial features, and get the contours of detected faces.\nThis provides information needed to perform tasks like embellishing selfies and portraits, or generating avatars\nfrom a user's photo.\n\nThe Machine Learning service is only offered on the device, and no cloud service exists.\n\nGiven an image file, the Face Detection service will attempt to recognize one or more faces, offering information\nsuch as:\n\n-   Face contour coordinates.\n-   The rotation of the head/face along the Y & Z axis.\n-   The probability that the face has it's left/right eyes open.\n-   The probability that the face is smiling.\n-   A list of face features (e.g. eyes, nose, mouth etc) and their positions on the face.\n\n# On-device Face Detection\n\n## Enable the model\n\nTo enable the mode, set the `ml_vision_face_model` key to `true` in your `firebase.json` file:\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"ml_vision_face_model\": true\n  }\n}\n```\n\nOnce complete, rebuild your application:\n\n```bash\n# For Android\nnpx react-native run-android\n\n# For iOS\ncd ios/ && pod install --repo-update\nnpx react-native run-ios\n```\n\n## Process\n\nOnce the model has been downloaded, call the `faceDetectorProcessImage` method with a path to a local file on your device:\n\n```js\nimport { utils } from '@react-native-firebase/app';\nimport vision, { VisionFaceContourType } from '@react-native-firebase/ml-vision';\n\nasync function processFaces(localPath) {\n  const faces = await vision().faceDetectorProcessImage(localPath);\n\n  faces.forEach(face => {\n    console.log('Head rotation on Y axis: ', face.headEulerAngleY);\n    console.log('Head rotation on Z axis: ', face.headEulerAngleZ);\n\n    console.log('Left eye open probability: ', face.leftEyeOpenProbability);\n    console.log('Right eye open probability: ', face.rightEyeOpenProbability);\n    console.log('Smiling probability: ', face.smilingProbability);\n\n    face.faceContours.forEach(contour => {\n      if (contour.type === VisionFaceContourType.FACE) {\n        console.log('Face outline points: ', contour.points);\n      }\n    });\n  });\n}\n\n// Local path to file on the device\nconst localFile = `${utils.FilePath.PICTURES_DIRECTORY}/barcode-document.jpg`;\n\nprocessBarcodes(localFile).then(() => console.log('Finished processing file.'));\n```\n\nTo learn about the types of information the face detector can return, view the\n[`VisionFace`](/reference/ml-vision/visionface) documentation.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-vision/image-labeling.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nImage labeling can recognize entities in an image without having to provide any additional contextual metadata, using\neither an on-device API or a cloud-based API. It gets a list of the entities that were recognized: people, things, places,\nactivities, and so on.\n\n# Cloud Image Labeling\n\nThe cloud based image labeling service uploads a given image to the Firebase services, processes the results and returns them.\nTo get started, call the `cloudImageLabelerProcessImage` method with a path to a local file on your device:\n\n```js\nimport { utils } from '@react-native-firebase/app';\nimport vision from '@react-native-firebase/ml-vision';\n\nasync function processImage(localPath) {\n  const labels = await vision().cloudImageLabelerProcessImage(localPath);\n\n  labels.forEach(label => {\n    console.log('Service labelled the image: ', label.text);\n    console.log('Confidence in the label: ', label.confidence);\n  });\n}\n\n// Local path to file on the device\nconst localFile = `${utils.FilePath.PICTURES_DIRECTORY}/image-document.jpg`;\n\nprocessImage(localFile).then(() => console.log('Finished processing file.'));\n```\n\nTo learn more about the available data on a processed document, view the [`VisionImageLabel`](/reference/ml-vision/visionimagelabel)\ndocumentation.\n\n## Configuration\n\nBy default, the service will return labels with any confidence level, which may include labels you do not care about or\nare too obvious. Set the `confidenceThreshold` key to a value between 0 & 1, where 1 represents 100% confidence. The\ncloud service will only return labels with a confidence greater than what you specified:\n\n```js\nconst processed = await vision().cloudDocumentTextRecognizerProcessImage(localPath, {\n  // 80% or higher confidence labels only\n  confidenceThreshold: 0.8,\n});\n```\n\nView the [`VisionCloudImageLabelerOptions`](/reference/ml-vision/visioncloudimagelabeleroptions) documentation for more information.\n\n# On-device Image Labeling\n\nRunning the ML Kit service on a device requires the `ml_vision_image_label_model` and `ml_vision_label_model` to be download to the device. Although the results\nof on-device processing will be faster and more accurate, including the model in your application will increase the size\nof the application.\n\n## Enable the model\n\nTo enable the mode, set the `ml_vision_image_label_model` & `ml_vision_label_model` key to `true` in your `firebase.json` file:\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"ml_vision_image_label_model\": true,\n    \"ml_vision_label_model\": true\n  }\n}\n```\n\nOnce complete, rebuild your application:\n\n```bash\n# For Android\nnpx react-native run-android\n\n# For iOS\ncd ios/ && pod install --repo-update\nnpx react-native run-ios\n```\n\n## Process\n\nOnce the models have been downloaded, call the `imageLabelerProcessImage` method with a path to a local file on your device:\n\n```js\nimport { utils } from '@react-native-firebase/app';\nimport vision from '@react-native-firebase/ml-vision';\n\nasync function processImage(localPath) {\n  const labels = await vision().imageLabelerProcessImage(localPath);\n\n  labels.forEach(label => {\n    console.log('Service labelled the image: ', label.text);\n    console.log('Confidence in the label: ', label.confidence);\n  });\n}\n\n// Local path to file on the device\nconst localFile = `${utils.FilePath.PICTURES_DIRECTORY}/image-document.jpg`;\n\nprocessImage(localFile).then(() => console.log('Finished processing file.'));\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-vision/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-vision/landmark-recognition.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nLandmark recognition can recognize well-known landmarks in an image. It returns the landmarks that were recognized, along\nwith each landmark's geographic coordinates and the region of the image the landmark was found.\n\nThe Machine Learning service is only offered as a cloud based one, and no on-device service exists.\n\nGiven an image file, the Landmark Recognition service will attempt to recognize one or more landmarks, offering information\nsuch as:\n\n-   The 4-point coordinates of the landmarks on the image.\n-   Latitude & Longitude locations of the landmarks.\n-   The confidence the Machine Learning service has in it's own results.\n-   An entity ID for use on Google's [Knowledge Graph Search API](https://developers.google.com/knowledge-graph/).\n\n# Cloud Landmark Recognition\n\nThe cloud based landmark recognition service uploads a given image document to the Firebase services, processes the results and returns them.\nTo get started, call the `cloudLandmarkRecognizerProcessImage` method with a path to a local image file on your device:\n\n```js\nimport { utils } from '@react-native-firebase/app';\nimport vision from '@react-native-firebase/ml-vision';\n\nasync function processLandmarks(localPath) {\n  const landmarks = await vision().cloudLandmarkRecognizerProcessImage(localPath);\n\n  landmarks.forEach(visionLandmark => {\n    console.log('Landmark name: ', visionLandmark.landmark);\n    console.log('Landmark locations: ', block.locations);\n    console.log('Confidence score: ', block.confidence);\n  });\n}\n\n// Local path to file on the device\nconst localFile = `${utils.FilePath.PICTURES_DIRECTORY}/image-file.jpg`;\n\nprocessLandmarks(localFile).then(() => console.log('Finished processing file.'));\n```\n\n## Configuration\n\nTo help speed up requests and improve results, the `cloudLandmarkRecognizerProcessImage` method accepts an optional\nconfiguration object.\n\n```js\nimport vision, { VisionCloudLandmarkRecognizerModelType } from '@react-native-firebase/ml-vision';\n\nconst landmarks = await vision().cloudLandmarkRecognizerProcessImage(localPath, {\n  // Limit the results\n  maxResults: 2,\n  // Set the model type\n  modelType: VisionCloudLandmarkRecognizerModelType.LATEST_MODEL,\n});\n```\n\nBy default, the service will use a stable model to detect landmarks. However, if you feel results are not up-to-date, you\ncan optionally use the latest model available. Results however may change unexpectedly.\n\nView the [`VisionCloudLandmarkRecognizerOptions`](http://localhost:8000/reference/ml-vision/visioncloudlandmarkrecognizeroptions) documentation for more information.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-vision/text-recognition.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nText recognition can automate tedious data entry for credit cards, receipts, and business cards. With the Cloud-based API,\nyou can also extract text from pictures of documents, which you can use to increase accessibility or translate documents.\n\nOnce a file has been processed, the API returns a [`VisionDocumentText`](/reference/ml-vision/visiondocumenttext), referencing\nall found text along with each [`VisionDocumentTextBlock`](/reference/ml-vision/visiondocumenttextblock). Each block contains\nmeta-data such as:\n\n-   The 4-point coordinates of the box on the document.\n-   Paragraphs within the block.\n-   Recognized languages within the block/document.\n-   The confidence the Machine Learning service has in it's own results.\n\n# Cloud Text Recognition\n\nThe cloud based text recognition service uploads a given document to the remote Firebase service which processes the results and returns them.\nTo get started, call the `cloudDocumentTextRecognizerProcessImage` method with a path to a local file on your device:\n\n```js\nimport { utils } from '@react-native-firebase/app';\nimport vision from '@react-native-firebase/ml-vision';\n\nasync function processDocument(localPath) {\n  const processed = await vision().cloudDocumentTextRecognizerProcessImage(localPath);\n\n  console.log('Found text in document: ', processed.text);\n\n  processed.blocks.forEach(block => {\n    console.log('Found block with text: ', block.text);\n    console.log('Confidence in block: ', block.confidence);\n    console.log('Languages found in block: ', block.recognizedLanguages);\n  });\n}\n\n// Local path to file on the device\nconst localFile = `${utils.FilePath.PICTURES_DIRECTORY}/text-document.jpg`;\n\nprocessDocument(localFile).then(() => console.log('Finished processing file.'));\n```\n\nTo learn more about the available data on a processed document, view the [`VisionDocumentText`](/reference/ml-vision/visiondocumenttext)\ndocumentation.\n\n## Configuration\n\nTo help improve the results when using the cloud service, you can optionally provide arguments to the `cloudDocumentTextRecognizerProcessImage`\nmethod:\n\n```js\nconst processed = await vision().cloudDocumentTextRecognizerProcessImage(documentPath, {\n  // The document contains Kurdish\n  languageHints: ['KU'],\n});\n```\n\nIn most scenarios, not providing any hints will yield better results. Use this configuration if the cloud service is struggling\nto detect a language.\n\nView the [`VisionCloudDocumentTextRecognizerOptions`](/reference/ml-vision/visionclouddocumenttextrecognizeroptions) documentation for more information.\n\n# On-device Text Recognition\n\nRunning the ML Kit service on a device requires the `ml_vision_ocr_model` to be download to the device. Although the results\nof on-device processing will be faster and more accurate, including the model in your application will increase the size\nof the application.\n\n## Enable the model\n\nTo enable the mode, set the `ml_vision_ocr_model` key to `true` in your `firebase.json` file:\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"ml_vision_ocr_model\": true\n  }\n}\n```\n\nOnce complete, rebuild your application:\n\n```bash\n# For Android\nnpx react-native run-android\n\n# For iOS\ncd ios/ && pod install --repo-update\nnpx react-native run-ios\n```\n\n## Process\n\nOnce the model has been downloaded, call the `textRecognizerProcessImage` method with a path to a local file on your device:\n\n```js\nimport { utils } from '@react-native-firebase/app';\nimport vision from '@react-native-firebase/ml-vision';\n\nasync function processDocument(localPath) {\n  const processed = await vision().textRecognizerProcessImage(localPath);\n\n  console.log('Found text in document: ', processed.text);\n\n  processed.blocks.forEach(block => {\n    console.log('Found block with text: ', block.text);\n    console.log('Confidence in block: ', block.confidence);\n    console.log('Languages found in block: ', block.recognizedLanguages);\n  });\n}\n\n// Local path to file on the device\nconst localFile = `${utils.FilePath.PICTURES_DIRECTORY}/text-document.jpg`;\n\nprocessDocument(localFile).then(() => console.log('Finished processing file.'));\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/perf/axios-integration.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Axios\n\nThe [Axios library](https://github.com/axios/axios) allows you to easily send HTTP requests via your\nReact Native application. Axios provides functionality allowing all requests & responses to be intercepted, exposing\nmetadata which can be hooked into the Performance Monitoring library.\n\n## Request Interceptor\n\nBefore HTTP requests are sent out of the React Native environment, a callback can be attached to the `request`\nproperty on the axios instance. At this point, a new HTTP metric can be defined on the Performance Monitoring library:\n\n```js\nimport axios from 'axios';\nimport perf from '@react-native-firebase/perf';\n\naxios.interceptors.request.use(async function(config) {\n  const httpMetric = perf().newHttpMetric(config.url, config.method);\n  config.metadata = { httpMetric };\n\n  // add any extra metric attributes, if required\n  // httpMetric.putAttribute('userId', '12345678');\n\n  await httpMetric.start();\n  return config;\n});\n```\n\nThis callback attaches the HTTP metric returned onto the request metadata, which can later be used on an\nincoming response.\n\n## Response Interceptor\n\nSimilar to the request interceptor, we can also hook into all responses from the HTTP calls. The response\ninterceptor can accept two callbacks, one for successful responses and one requests which failed:\n\n```js\nimport axios from 'axios';\n\naxios.interceptors.response.use(\n  async function(response) {\n    // Request was successful, e.g. HTTP code 200\n\n    const { httpMetric } = response.config.metadata;\n\n    // add any extra metric attributes if needed\n    // httpMetric.putAttribute('userId', '12345678');\n\n    httpMetric.setHttpResponseCode(response.status);\n    httpMetric.setResponseContentType(response.headers['content-type']);\n    await httpMetric.stop();\n\n    return response;\n  },\n  async function(error) {\n    // Request failed, e.g. HTTP code 500\n\n    const { httpMetric } = error.config.metadata;\n\n    // add any extra metric attributes if needed\n    // httpMetric.putAttribute('userId', '12345678');\n\n    httpMetric.setHttpResponseCode(error.response.status);\n    httpMetric.setResponseContentType(error.response.headers['content-type']);\n    await httpMetric.stop();\n\n    // Ensure failed requests throw after interception\n    return Promise.reject(error);\n  },\n);\n```\n\nAll outbound requests sent from Axios will appear in your Firebase console, detailing information such as\nhow long the request took, response codes & more. Such data can give you greater insight into the performance\nof your application via any external APIs you may be using.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/perf/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/releases/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nStarting with version `v6.5.0`; all React Native Firebase packages are now independently versioned with individually generated release notes:\n\n| Package                 |                                                                                                                         |                                                                                                                                  |\n| ----------------------- | :---------------------------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------------------------------------------------------: |\n| AdMob                   |        ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/admob.svg?style=for-the-badge&logo=npm)        |        [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/admob/CHANGELOG.md)        |\n| Analytics               |      ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/analytics.svg?style=for-the-badge&logo=npm)      |      [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/analytics/CHANGELOG.md)      |\n| App                     |         ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/app.svg?style=for-the-badge&logo=npm)         |         [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/app/CHANGELOG.md)         |\n| Authentication          |         ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/auth.svg?style=for-the-badge&logo=npm)        |         [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/auth/CHANGELOG.md)        |\n| Cloud Firestore         |      ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/firestore.svg?style=for-the-badge&logo=npm)      |      [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/firestore/CHANGELOG.md)      |\n| Cloud Functions         |      ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/functions.svg?style=for-the-badge&logo=npm)      |      [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/functions/CHANGELOG.md)      |\n| Cloud Messaging         |      ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/messaging.svg?style=for-the-badge&logo=npm)      |      [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/messaging/CHANGELOG.md)      |\n| Cloud Storage           |       ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/storage.svg?style=for-the-badge&logo=npm)       |       [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/storage/CHANGELOG.md)       |\n| Crashlytics             |     ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/crashlytics.svg?style=for-the-badge&logo=npm)     |     [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/crashlytics/CHANGELOG.md)     |\n| Dynamic Links           |    ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/dynamic-links.svg?style=for-the-badge&logo=npm)    |    [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/dynamic-links/CHANGELOG.md)    |\n| In-app Messaging        |   ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/in-app-messaging.svg?style=for-the-badge&logo=npm)  |   [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/in-app-messaging/CHANGELOG.md)  |\n| Instance ID             |         ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/iid.svg?style=for-the-badge&logo=npm)         |         [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/iid/CHANGELOG.md)         |\n| ML Kit Natural Language | ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/ml-natural-language.svg?style=for-the-badge&logo=npm) | [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/ml-natural-language/CHANGELOG.md) |\n| ML Kit Vision           |      ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/ml-vision.svg?style=for-the-badge&logo=npm)      |      [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/ml-vision/CHANGELOG.md)      |\n| Performance Monitoring  |         ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/perf.svg?style=for-the-badge&logo=npm)        |         [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/perf/CHANGELOG.md)        |\n| Realtime Database       |       ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/database.svg?style=for-the-badge&logo=npm)      |       [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/database/CHANGELOG.md)      |\n| Remote Config           |    ![hide:badge](https://img.shields.io/npm/v/@react-native-firebase/remote-config.svg?style=for-the-badge&logo=npm)    |    [View Release Notes »](https://github.com/invertase/react-native-firebase/tree/master/packages/remote-config/CHANGELOG.md)    |\n\n* * *\n\nTo view release notes for versions prior to `v6.5.0` see the table below.\n\n| Version |                                          |\n| ------- | :--------------------------------------: |\n| v6.4.0  | [View Release Notes »](/releases/v6.4.0) |\n| v6.3.0  | [View Release Notes »](/releases/v6.3.0) |\n| v6.2.0  | [View Release Notes »](/releases/v6.2.0) |\n| v6.1.0  | [View Release Notes »](/releases/v6.1.0) |\n| v6.0.3  | [View Release Notes »](/releases/v6.0.3) |\n| v6.0.2  | [View Release Notes »](/releases/v6.0.2) |\n| v6.0.1  | [View Release Notes »](/releases/v6.0.1) |\n| v6.0.0  | [View Release Notes »](/releases/v6.0.0) |\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/releases/v6.0.0.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n> Please tag any GitHub issues regarding v6.0.0 with `[v6]` in the title.\n\nThis version is effectively a re-write with the goal of splitting every module into it's own package (simplifies maintenance\nfor contributors and also installation for users) and additionally brings each Firebase module up to ~95+% testing coverage and 100%\nFirebase API Coverage.\n\nMany of the manual native installation steps for Android & iOS have been removed and internally automated\nwith most modules now just 'install and go'.\n\nThe new modules:\n\n| Name                                            |                                                                                            Downloads                                                                                            |                                                                 Coverage                                                                |\n| ----------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------: |\n| [Analytics](/analytics)                         |           [![badge](https://img.shields.io/npm/dm/@react-native-firebase/analytics.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/analytics)           |           [![badge](https://api.rnfirebase.io/coverage/analytics/badge)](https://api.rnfirebase.io/coverage/analytics/detail)           |\n| [App](/app)                                     |                 [![badge](https://img.shields.io/npm/dm/@react-native-firebase/app.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/app)                 |                 [![badge](https://api.rnfirebase.io/coverage/app/badge)](https://api.rnfirebase.io/coverage/app/detail)                 |\n| [Cloud Functions](/functions)                   |           [![badge](https://img.shields.io/npm/dm/@react-native-firebase/functions.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/functions)           |           [![badge](https://api.rnfirebase.io/coverage/functions/badge)](https://api.rnfirebase.io/coverage/functions/detail)           |\n| [Cloud Firestore](/firestore)                   |           [![badge](https://img.shields.io/npm/dm/@react-native-firebase/firestore.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/firestore)           |           [![badge](https://api.rnfirebase.io/coverage/firestore/badge)](https://api.rnfirebase.io/coverage/firestore/detail)           |\n| [Cloud Storage](/storage)                       |             [![badge](https://img.shields.io/npm/dm/@react-native-firebase/storage.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/storage)             |             [![badge](https://api.rnfirebase.io/coverage/storage/badge)](https://api.rnfirebase.io/coverage/storage/detail)             |\n| [Cloud Messaging](/messaging)                   |           [![badge](https://img.shields.io/npm/dm/@react-native-firebase/messaging.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/messaging)           |           [![badge](https://api.rnfirebase.io/coverage/messaging/badge)](https://api.rnfirebase.io/coverage/messaging/detail)           |\n| [Crashlytics](/crashlytics)                     |         [![badge](https://img.shields.io/npm/dm/@react-native-firebase/crashlytics.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/crashlytics)         |         [![badge](https://api.rnfirebase.io/coverage/crashlytics/badge)](https://api.rnfirebase.io/coverage/crashlytics/detail)         |\n| [Dynamic Links](/dynamic-links)                 |       [![badge](https://img.shields.io/npm/dm/@react-native-firebase/dynamic-links.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/dynamic-links)       |       [![badge](https://api.rnfirebase.io/coverage/dynamic-links/badge)](https://api.rnfirebase.io/coverage/dynamic-links/detail)       |\n| [In-app Messaging](/in-app-messaging)           |    [![badge](https://img.shields.io/npm/dm/@react-native-firebase/in-app-messaging.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/in-app-messaging)    |    [![badge](https://api.rnfirebase.io/coverage/in-app-messaging/badge)](https://api.rnfirebase.io/coverage/in-app-messaging/detail)    |\n| [Instance ID](/iid)                             |                 [![badge](https://img.shields.io/npm/dm/@react-native-firebase/iid.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/iid)                 |                 [![badge](https://api.rnfirebase.io/coverage/iid/badge)](https://api.rnfirebase.io/coverage/iid/detail)                 |\n| [ML Kit Natural Language](/ml-natural-language) | [![badge](https://img.shields.io/npm/dm/@react-native-firebase/ml-natural-language.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/ml-natural-language) | [![badge](https://api.rnfirebase.io/coverage/ml-natural-language/badge)](https://api.rnfirebase.io/coverage/ml-natural-language/detail) |\n| [ML Kit Vision ](/ml-vision)                    |           [![badge](https://img.shields.io/npm/dm/@react-native-firebase/ml-vision.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/ml-vision)           |           [![badge](https://api.rnfirebase.io/coverage/ml-vision/badge)](https://api.rnfirebase.io/coverage/ml-vision/detail)           |\n| [Performance Monitoring](/perf)                 |                [![badge](https://img.shields.io/npm/dm/@react-native-firebase/perf.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/perf)                |                [![badge](https://api.rnfirebase.io/coverage/perf/badge)](https://api.rnfirebase.io/coverage/perf/detail)                |\n| [Realtime Database](/database)                  |            [![badge](https://img.shields.io/npm/dm/@react-native-firebase/database.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/database)            |            [![badge](https://api.rnfirebase.io/coverage/database/badge)](https://api.rnfirebase.io/coverage/database/detail)            |\n| [Remote Config](/remote-config)                 |       [![badge](https://img.shields.io/npm/dm/@react-native-firebase/remote-config.svg?style=for-the-badge&logo=npm)](https://www.npmjs.com/package/@react-native-firebase/remote-config)       |       [![badge](https://api.rnfirebase.io/coverage/remote-config/badge)](https://api.rnfirebase.io/coverage/remote-config/detail)       |\n\n* * *\n\nThe following modules are currently **migration only** for now (migrated from v5 to v6 with minimal changes), what this means:\n\n-   only some new work was done on them (e.g. migrating to v6 internals)\n-   only some new tests added for them (but all existing tests pass)\n-   flow types missing (but have TS types)\n\n### Where is the Notifications library?\n\nPlease see [this issue](https://github.com/invertase/react-native-firebase/issues/2566) for the latest on notifications.\n\n## Changelog\n\n### General Library Changes\n\n-   [INTERNAL] Improved error codes & handling for all Firebase services;\n    -   Standardized native error to JS conversion\n    -   [DEVEX] Native promise rejection errors now contain additional properties to aid debugging\n    -   All React Native Firebase native methods should now always return an Error to JS - even if the Error occurred due to native code.\n-   [BUGFIX] All native events are now queued natively until a JS listener is registered. This fixes several race conditions for events like `onMessage`, `onNotification`, `onLink` etc where the event would trigger before JS was ready.\n-   [NEW][🔥] In an effort to further reduce manual native code changes when integrating and configuring React Native Firebase; we have added support for configuring various Firebase services & features via a `firebase.json` file in your project root.\n-   [NEW][ios] CocoaPods static framework support for all modules (you can use `use_frameworks!` without issues relating to this lib)\n    -   **Note**: Currently this has been disabled as `use_frameworks!` support in React Native was broken again in RN60. We'll re-enable in a future release for RN61.\n\n* * *\n\n### App (app)\n\n-   [NEW] Added `appConfig` & method support for `setAutomaticDataCollectionEnabled` & `automaticResourceManagement`\n-   [NEW] Added app `options` support for `gaTrackingId`\n-   [NEW] The `[DEFAULT]` Firebase app can now be safely initialized in JS, however this has some caveats;\n    -   Firebase services such as Performance Monitoring & Remote Config require the default app to be initialized through the plist/JSON file.\n-   [BREAKING] Waiting for apps to initialize via `.onReady()` has been removed. `initializeApp()` now returns a promise to the same effect\n-   [BREAKING] Trying to initialize the `[DEFAULT]` Firebase app in JS when it was already initialized natively will now throw an error (formerly warned)\n\n* * *\n\n### AdMob\n\nAdMob has undergone a full rewrite to keep up-to-date with the latest changes and APIs. The JavaScript API interface has been modified from v5 to provider a simpler, cleaner way to manage ads.\n\n-   [NEW] A new `AdsConsent` helper has been added to handle user ads consent, required under GDPR regulations. See the [documentation](https://invertase.io/oss/react-native-firebase/v6/admob/european-user-consent) for more information.\n-   [NEW] Global settings can be applied to AdMob via `setRequestConfiguration`.\n    -   `maxAdContentRating`, `tagForChildDirectedTreatment` & `tagForUnderAgeOfConsent` are now set a global configuration settings.\n-   [NEW] `RewardedAd` interface used the new Google Mobile Ads SDK beta API. Rewarded ads can now be controlled from the user dashboard, supporting both video and interactive ads.\n-   [NEW] Added support for requesting only non-personalized ads via the `requestNonPersonalizedAdsOnly` request options.\n-   [NEW] Added support for custom network extras on ad requests via `networkExtras`.\n    -   The user reward is now pre-fetched when the ad is loaded.\n-   [BREAKING] The API interface for interacting with AdMob has undergone a full re-write.\n-   [BUGFIX] Ads can now work during React Native debugging.\n\n* * *\n\n### App Invites (invites)\n\n-   [BREAKING] this module has been deprecated by Firebase and now been removed, you should migrate to Dynamic Links.\n\n* * *\n\n### Analytics (analytics)\n\n-   [NEW] Added support for `resetAnalyticsData()`\n-   [NEW] Added event specific methods for many built-in analytics events, e.g. `logLevelStart`, `logSearch`, `logSignUp` and many more, see the module reference documentation for the full list of methods added.\n-   [INTERNAL] `setUserProperties` now iterates properties natively (formerly 1 native call per property)\n-   [BREAKING] all analytics methods now return a Promise, rather than formerly being 'fire and forget'\n\n* * *\n\n### Crashlytics (crashlytics)\n\n> **Blog post announcement**: \\[[Firebase Crashlytics for React Native](https://invertase.io/blog/firebase-crashlytics-for-react-native?utm_source=github&utm_medium=changelog)]\n\n-   [NEW] JavaScript stack traces now automatically captured and parsed\n    ![JavaScript stack trace preview](https://pbs.twimg.com/media/D07RPDMW0AA7TTv.jpg:large)\n-   [NEW] Optionally enable automatic reporting of JavaScript unhandled Promise rejections\n-   [NEW] Added support for `setUserName(userName: string)`\n-   [NEW] Added support for `setUserEmail(userEmail: string)`\n-   [NEW] Added support for `isCrashlyticsCollectionEnabled: boolean`\n-   [NEW][android] Added support for [Crashlytics NDK](https://docs.fabric.io/android/crashlytics/ndk.html#using-gradle) reporting. This allows Crashlytics to capture Yoga related crashes generated from React Native.\n-   [NEW][🔥] Added `firebase.json` support for `crashlytics_ndk_enabled`, this toggles NDK support as mentioned above, defaults to `true`\n-   [NEW][🔥] Added `firebase.json` support for `crashlytics_debug_enabled`, this toggles Crashlytics native debug logging, defaults to `false`\n-   [NEW][🔥] Added `firebase.json` support for `crashlytics_auto_collection_enabled`, this toggles Crashlytics error reporting, this is useful for user opt-in first flows, e.g. set to `false` and when your user agrees to opt-in then call `setCrashlyticsCollectionEnabled(true)` in your app, defaults to `true`\n-   [BUGFIX][android] `crash()` now correctly crashes without being caught by a React Native red box\n-   [BREAKING] `setBoolValue`, `setFloatValue`, `setIntValue` & `setStringValue` have been removed and replaced with two new methods (the Crashlytics SDK converted all these into strings internally anyway):\n    -   `setAttribute(key: string, value: string): Promise<null>` - set a singular key value to show alongside any subsequent crash reports\n    -   `setAttributes(values: { [key: string]: string }): Promise<null>` - set multiple key values to show alongside any subsequent crash reports\n-   [BREAKING] all methods except `crash`, `log` & `recordError` now return a `Promise` that resolves when complete\n-   [BREAKING] `recordError(code: number, message: string)`'s function signature changed to `recordError(error: Error)` - now accepts a JS Error class instance\n-   [BREAKING] `setUserIdentifier()` has been renamed to `setUserId()` to match analytics implementation\n-   [BREAKING] `enableCrashlyticsCollection()`'s function signature changed to `setCrashlyticsCollectionEnabled(enabled: boolean)`\n    -   This can be used in all scenarios (formerly only able to use this when automatic initialization of Crashlytics was disabled)\n    -   Changes do not take effect until the next app startup\n    -   This persists between app restarts and only needs to be called once, can be used in conjunction with `isCrashlyticsCollectionEnabled` to reduce bridge startup traffic - though calling multiple times is still allowed\n\n* * *\n\n### Cloud Firestore (firestore)\n\nCloud Firestore has undergone a complete overhaul of both JavaScript & native code, including a re-write of bridge serialization, support for new features & heavy test coverage.\n\n-   [NEW] Added support for collection group queries (`firestore().collectionGroup()`).\n-   [NEW] Added support for `isEqual()` across most classes.\n-   [NEW] Added support for `SetOptions.mergeFields` (`DocumentReference.set()` / `Transaction.set()`).\n-   [NEW] Added support for handling snapshot metadata via the `includeMetadataChanges` flag which can be passed to `CollectionReference.onSnapshot()` and `QuerySnapshot.docChanges()` to return additional results from query snapshot listeners.\n-   [NEW] Cache size can now be set to unlimited using the `CACHE_SIZE_UNLIMITED` static when passed to `firestore().settings()` (also added in v5.4).\n-   [BUGFIX] Remove Metro circular reference warnings.\n-   [BUGFIX] `DocumentReference` and `CollectionReference` snapshot observers now correctly handle the same arguments as the Web SDK.\n-   [BUGFIX] Validate transaction gets must also have a write command (matches Web SDK).\n-   [BUGFIX] Setting a negative infinity value (`-Infinity`) now correctly works as expected.\n-   [BUGFIX] `QuerySnapshot.forEach()` can now correctly takes an optional context argument.\n-   [BUGFIX] Snapshot metadata now correctly returns a `SnapshotMetadata` class (as per Web SDK).\n-   [BUGFIX] `CollectionReference` now correctly extends a `Query` class. In v5 it is possible to chain calls from `Query` → `CollectionReference` which isn't possible on the Web SDK.\n-   [BUGFIX] `onSnapshot()` calls now take the correct arguments, allowing for `SnapshotListenOptions`, inline function callbacks or an object containing next/error callbacks (as per the Web SDK).\n-   [BUGFIX] Setting a `Date` on Firestore was setting an incorrect value. Date objects are now converted to a `Timestamp` as per the Web SDK.\n-   [BUGFIX] Cursor queries in v5 (`startAt`, `startAfter`, `endAt`, `endBefore`) were incorrectly handling a `DocumentSnapshot` argument. It is now possible to perform a cursor query directly on a snapshot, or on snapshot fields, as per the Web SDK, for example ending at a specific snapshot with no order.\n-   [BREAKING] Blob can no longer be constructed manually, as per the Web SDK.\n-   [BREAKING] The v6 release includes **a lot** of additional JavaScript validation. This is more consistent with the Web SDK and helps catch native errors/crashes which may occur due to false-positive data being sent over the bridge.\n    -   Specifically, the `Query` class has undergone a rewrite, and includes a lot of additional checks which are not present in v5. Please check your Firestore queries once upgraded.\n-   [BREAKING] Removed the `Query.where` single equals operator (`=`) as per the Web SDK. Use `==` instead.\n-   [BREAKING] previously deprecated `setTimestampsInSnapshotsEnabled` on settings has now been removed.\n-   [PERFORMANCE][🔥] [ANDROID] Data serialization logic is now correctly performed off the main UI thread. This will help increase performance and reduce activity on the UI thread when sending large volumes of data to Firestore and back to the device.\n-   [PERFORMANCE][🔥] The data serialization logic has undergone a large rewrite for performance.\n    -   JavaScript data being sent over the native bridge has to be converted to it's native counterpart, and visa versa. When dealing with a large number of documents and/or large amounts document data, this process can be both time consuming and resource intensive. The rewrite keeps data being sent over the bridge at a minimum; mapping data types to smaller serialization format that can be parsed by JS and Native code.\n    -   Sample comparisons against v5 have shown:\n        -   Data size sent over the bridge has been reduced by ~58%.\n        -   On large queries (4 documents with 1500 nested array items (containing all data types)) are over ~50% faster on v6. Smaller queries (1 document with 1500 nested array items) are over ~15% quicker.\n\n* * *\n\n### Dynamic Links (dynamicLinks)\n\n-   [BREAKING] the namespace for this module has changed, replace all usages of `firebase.links()` with `firebase.dynamicLinks()`\n-   [BREAKING] `onLink` & `getInitialLink` now return a `DynamicLink` object with multiple properties, formally just provided just the URL as a string\n-   [NEW][ios][🔥] Manually adding `AppDelegate` methods to support receiving Dynamic Link open events is no longer required, we swizzle this at runtime and automatically intercept the required events.\n-   [BUGFIX] Links should now always be accessible via `onLink` & `getInitialLink`\n    -   This fix is a 'side-effect' of the bug fix mentioned above in the `all modules` section ('`All native events are now queued natively`')\n-   [BREAKING] Creating a Dynamic Link builder via `new firebase.links.DynamicLink(link, domainURIPrefix)` has been deprecated, use a plain object instead as an argument for `buildLink()` & `buildShortLink()`.\n-   [BREAKING] Some previously allowed parameter configurations will now throw an argument error, e.g. trying to set any `DynamicLinkIOSParameters` parameter without providing an iOS bundle id will now error.\n    -   these configurations were incorrect to begin with but were never flagged to user code so may have gone unnoticed\n\n* * *\n\n### Functions (functions)\n\n-   [BUGFIX] Fixed an issue where `useFunctionsEmulator` does not persist natively (Firebase iOS SDK requires chaining this method before other calls and does not modify the instance, Android however persists this)\n\n* * *\n\n### In-App Messaging (inAppMessaging) - **[NEW]**\n\n-   [NEW] Added support for `firebase.inAppMessaging().isMessagesDisplaySuppressed: boolean;`\n-   [NEW] Added support for `firebase.inAppMessaging().setMessagesDisplaySuppressed(enabled: boolean): Promise<null>;`\n-   [NEW] Added support for `firebase.inAppMessaging().isAutomaticDataCollectionEnabled: boolean;`\n-   [NEW] Added support for `firebase.inAppMessaging().setAutomaticDataCollectionEnabled(enabled: boolean): Promise<null>;`\n\n* * *\n\n### Instance Id (iid)\n\n-   [NEW] Instance Id now supports multiple Firebase apps, e.g. `firebase.app('fooApp').iid().get()`\n\n* * *\n\n### Cloud Messaging (messaging)\n\n-   [NEW] added support for `onSendError` events, an event that indicates a message (with id) failed to send\n-   [NEW] added support for `onMessageSent` events, an event that indicates a message (with id) was successfully sent\n-   [NEW] added support for `onDeletedMessages` events, an event that indicates the FCM server deleted pending messages\n    -   when your app instance receives this event, it should perform a full sync with your app server if it relies on message data\n-   [NEW] `getToken` & `deleteToken` now optionally support `authorizedEntity` & `scope` arguments\n    -   `authorizedEntity` - defaults to `firebase.app().options.messagingSenderId`\n    -   `scope` - defaults to `FCM`\n-   [NEW][ios] added support for `isRegisteredForRemoteNotifications: boolean;`\n-   [NEW][ios] added support for `unregisterForRemoteNotifications(): Promise<void>;`\n-   [NEW][ios] `requestPermission` on iOS 12+ devices now uses the `UNAuthorizationOptionProvisional` option to request permission\n    -   this allows you to immediately start sending 'quiet' notifications to your users without their explicit permission, i.e., on a trial basis. `requestPermission` with this option will no longer show a permission request dialog to your user. [Learn More](http://iosbrain.com/blog/2018/07/05/new-in-ios-12-implementing-provisional-authorization-for-quiet-notifications-in-swift/)\n    -   [\\[`WWDC 2018 Video`\\]](https://developer.apple.com/videos/play/wwdc2018/710/) (30:00 onwards)\n-   [NEW] added support for `isAutoInitEnabled: boolean;`\n-   [NEW] added support for `setAutoInitEnabled(enabled: boolean): Promise<void>;`\n-   [NEW] added support for disabling messaging auto initialization via the new `firebase.json` configuration file\n    -   `messaging_auto_init_enabled`: `true/false`\n-   [NEW][android] added support for configuring the background Headless task timeout via the new `firebase.json` configuration file\n    -   `messaging_android_headless_task_timeout`: `number` - milliseconds\n-   [NEW][android] added support for registering the background message headless task via `firebase.messaging().setBackgroundMessageHandler(handler: Function)`\n-   [BREAKING][android] manually registering the background message headless task handler via `AppRegistry.registerHeadlessTask` is no longer supported. Call `firebase.messaging().setBackgroundMessageHandler(handler: Function)` instead.\n    -   This is a preemptive change that will allow us to support background tasks for iOS in a future release (as it won't be via RN Headless Tasks as it's not supported on iOS)\n-   [BREAKING][android] the manually added `RNFirebaseMessagingService` service in your `AndroidManifest.xml` file is no longer required - you can safely remove it.\n    -   Many manual code changes that existed in v5 are now automatically handled for you in v6\n-   [BREAKING][ios] any the manually added `AppDelegate.m` changes for messaging on v5 are longer required - you can safely remove them (search for `RNFirebaseMessaging` in your `AppDelegate`)\n    -   Many manual code changes that existed in v5 are now automatically handled for you in v6\n-   [BREAKING] constructing a `RemoteMessage` instance via `new firebase.messaging.RemoteMessage()` is no longer supported, use `firebase.messaging().newRemoteMessage()` to retrieve a new remote message builder instance.\n-   [BREAKING][ios] the minimum supported iOS version is now 10\n\n    -   iOS 9 or lower only accounts for 0.% of all iPhone devices\n    -   to see a detailed device versions breakdown see [this link](https://david-smith.org/iosversionstats/)\n    -   community contributions that add iOS 9 support are welcome\n\n* * *\n\n### Performance Monitoring (perf)\n\nThe Performance Monitoring API has had a significant API change as originally highlighted would happen in the v5.x.x docs:\n\n![image](https://user-images.githubusercontent.com/5347038/58876674-b633b780-86c6-11e9-8a74-6b6194c8ab05.png)\n\n-   [BREAKING] All `Trace` & `HttpMetric` methods (except for `start` & `stop`) are now synchronous and no longer return a Promise, extra attributes/metrics now only get sent to native when you call `stop`\n-   [BREAKING] `firebase.perf.Trace.incrementMetric` will now create a metric if it could not be found\n-   [BREAKING] `firebase.perf.Trace.getMetric` will now return 0 if a metric could not be found\n-   [NEW] Added support for `firebase.perf().isPerformanceCollectionEnabled: boolean`\n-   [NEW] Added `firebase.perf().startTrace(identifier: string): Promise<Trace>;` as a convenience method to create and immediately start a Trace\n\n* * *\n\n### Realtime Database (database)\n\nThe Realtime Database module has had a large re-write, fixing various inconsistencies against the web SDK, along with improving data serialization on the native side by moving intensive serialization work off the UI thread.\n\n-   [BREAKING][bugfix] The `Reference` class now extends a `Query` class (to match the web SDK). Currently in v5 everything is within the `Reference` class, allowing for incorrect behavior such as chaining a reference only method to a query, e.g. `ref().orderByKey().once()`. This is now not possible and will cause a standard JavaScript error.\n-   [BREAKING][bugfix] Internal validation for all methods has now been added. With v5 in some cases, incorrect values would be passed along to native and causing native exceptions/potential crashes.\n-   [BREAKING][bugfix] All query based modifiers are now validated as per the Web SDK spec. In v5 it is possible to chain queries which are not allowed together causing native errors (e.g. `.orderByKey().orderByPriority()`, `.startAt('foo', 'bar').orderByKey()` etc). Doing so in v6 will now throw an error to keep it in-line with the Web SDK.\n-   [BREAKING][bugfix] `Reference.push` now correctly mimics the Web SDK, returning a thenable reference.\n-   [NEW] `DatabaseSnapshot.forEach` now returns the current index key.\n-   [NEW] Many methods were missing an `onComplete` handler, which is now implemented as per the Web SDK.\n-   [BUGFIX] `DatabaseSnapshot.forEach` correct iterates over \"array\" fields in the database.\n\n* * *\n\n### Remote Config (remoteConfig)\n\nThe Remote Config API has had a significant API change as originally highlighted would happen in the v5.x.x docs:\n\n![image](https://user-images.githubusercontent.com/5347038/58876587-7c62b100-86c6-11e9-81f9-95c26e1485a1.png)\n\n-   [BREAKING] Module namespace has been renamed to `.remoteConfig()`, replace all usages of `firebase.config` with the new name.\n-   [BREAKING] All Remote Config values can now be accessed synchronously in JS, see `getValue(key: string): ConfigValue` & `getAll(): ConfigValues` below\n    -   [BREAKING] These replace all the original async methods: `getValue`, `getValues`, `getKeysByPrefix`\n-   [BREAKING] `setDefaultsFromResource` now returns a Promise that resolves when completed, this will reject with code `config/resouce_not_found` if the file could not be found\n-   [BREAKING] `setDefaultsFromResource` now expects a resource file name for Android to match iOS, formerly this required a resource id (something you would not have in RN as this was generated at build time by Android)\n    -   And example for both platforms can be found in the tests.\n-   [BREAKING] `enableDeveloperMode` has been removed, you can now use `setConfigSettings({ isDeveloperModeEnabled: boolean })` instead\n-   [BREAKING] `setDefaults` now returns a Promise that resolves when completed\n-   [NEW] Added a new `fetchAndActivate` method - this fetches the config and activates it without the need to call `activate()` separately\n-   [NEW] Added the following properties to `firebase.remoteConfig()`; `lastFetchTime`, `lastFetchStatus` & `isDeveloperModeEnabled`\n-   [NEW] Added a new `setConfigSettings` method - this allows setting `isDeveloperModeEnabled`, replaces the `enableDeveloperMode` method\n    -   This is a generic settings function to preemptively account for an upcoming future change to the native SDKs - more settings to be added.\n-   [NEW] All previous `get*` methods have been removed and replaced with 2 synchronous methods:\n    -   `getValue(key: string): ConfigValue` - returns a single configuration value `{ value, source }`\n    -   `getAll(): ConfigValues` - returns all configuration values e.g. `{ some_key: { value, source }, other_key: { value, source } }`\n\n> **Note**: Multi-apps is not yet supported as the Firebase iOS SDK is missing support for it.\n\n* * *\n\n### Cloud Storage (storage)\n\n-   [NEW] Added support for `put` (`Blob` \\| `ArrayBuffer` \\| `Uint8Array`)\n    -   `contentType` mime type is automatically inferred from `Blob`\n-   [NEW] Added support for `putString` and all string formats (raw, `base64`, `base64url` & `data_url`)\n    -   `contentType` mime type is automatically inferred from `data_url` strings\n-   [NEW] Added support multiple buckets, e.g. `firebase.app().storage('gs://my-other-bucket')`\n-   [NEW] Added support `pause()`, `resume()` & `cancel()` for Upload & Download Storage tasks\n-   [NEW] Added an `error` property to `TaskSnapshot` for `error` state events - this is an instance of `NativeFirebaseError` (with `code` & `message`)\n-   [NEW] Added support for `StorageReference.list()` & `StorageReference.listAll()`.\n-   [BREAKING] Removed formerly deprecated `UploadTaskSnapshot.downloadUrl` property, use `StorageReference.getDownloadURL(): Promise<string>` instead\n-   [BREAKING] `StorageReference.downloadFile()` is now deprecated and will be removed in a later release, please rename usages of this to `writeToFile()` - renamed to match Native SDKs\n-   [BREAKING] `firebase.storage.Native` has moved to `firebase.utils.Native`\n-   [BREAKING] `firebase.utils.Native` is now deprecated and will be removed in a later release, please rename usages of this to `firebase.utils.FilePath`\n-   [BREAKING] `firebase.utils.Native.*` some properties have been renamed and deprecated and will be removed in a later release, follow the in-app console warnings on how to migrate\n-   [BUGFIX][android] Update/set metadata now correctly supports removing metadata values by passing a null property value in `customMetadata`\n-   [BUGFIX][android] `contentType` mime type is now correctly determined in all scenarios, there was an edge case where it would just use the default value\n-   [INTERNAL][android] `downloadFile` no longer uses a `StreamDownloadTask`, replaced with the newer `FileDownloadTask`\n\n* * *\n\n### ML Kit Natural Language (naturalLanguage)\n\n> This is a new module in React Native Firebase.\n\n-   [NEW] Implemented support for language identification APIs\n    -   Single Languages: `identifyLanguage()`.\n    -   Multiple Languages: `identifyPossibleLanguages()`\n-   [NEW] Implemented support for [Smart Replies](https://firebase.google.com/docs/ml-kit/generate-smart-replies)\n    -   [Example Video](https://twitter.com/mikediarmid/status/1128837402481635331)\n\n> ML Kit Translate APIs to come in a later release.\n\n* * *\n\n### ML Kit Vision (vision)\n\n> This is a new module in React Native Firebase.\n\n-   [NEW] Implemented support for [Text Recognition](https://firebase.google.com/docs/ml-kit/recognize-text) Vision APIs;\n    -   [x] Cloud\n    -   [x] On Device\n-   [NEW] Implemented support for [Document Text Recognition](https://firebase.google.com/docs/ml-kit/recognize-text) Vision APIs;\n    -   [x] Cloud\n-   [NEW] Implemented support for [Face Detection](https://firebase.google.com/docs/ml-kit/detect-faces) Vision APIs;\n    -   [x] On Device\n-   [NEW] Implemented support for [Barcode Detection](https://firebase.google.com/docs/ml-kit/read-barcodes) Vision APIs;\n    -   [x] On Device\n-   [NEW] Implemented support for [Image Labeling](https://firebase.google.com/docs/ml-kit/label-images) Vision APIs;\n    -   [x] Cloud\n    -   [x] On Device\n-   [NEW] Implemented support for [Landmark Recognition](https://firebase.google.com/docs/ml-kit/recognize-landmarks) Vision APIs;\n    -   [x] Cloud\n\n* * *\n\n### Utils\n\n-   [NEW] Added support via `isRunningInTestLab` for checking if an Android application is running inside a Firebase Test Lab environment\n-   [NEW] Added a new `FilePath` utility that provides common file paths on the device, see `firebase.utils.FilePath` docs for more info, this is the replacement API for `firebase.storage.Native`\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/releases/v6.0.1.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n> Please tag any GitHub issues regarding v6 with `[v6]` in the title.\n\n🐞 This is a bug fix release. 🐞\n\n-   Fix [#2635](https://github.com/invertase/react-native-firebase/issues/2635); Android build error; Cannot get property 'parentFile' on null object when trying to detect a `firebase.json` file\n-   Fix [#2648](https://github.com/invertase/react-native-firebase/issues/2648); TypeScript; Auto complete not working with VSCode\n\n## Authentication\n\n-   Fix [#2639](https://github.com/invertase/react-native-firebase/issues/2639); Android; Casting error from JS to native when calling `auth().verifyPhoneNumber(phoneNumber)`\n-   Fix [#2693](https://github.com/invertase/react-native-firebase/issues/2693); iOS; Can't use `verifyPhoneNumber`\n\n## Crashlytics\n\n-   Fix [#2307](https://github.com/invertase/react-native-firebase/issues/2307); Android,iOS; `crashlytics().setUserId` crashes when `auto_collection` disabled\n\n## Firestore\n\n-   Fix [#2654](https://github.com/invertase/react-native-firebase/issues/2654); Firestore settings not applied\n-   Fix [#2532](https://github.com/invertase/react-native-firebase/issues/2532); `FieldPath` doesn't deep merge\n-   Fix [#2581](https://github.com/invertase/react-native-firebase/issues/2581); Index Creation Error Message Surfacing\n-   Fix [#2691](https://github.com/invertase/react-native-firebase/issues/2691); `FirestoreQuery`/`FirestoreQueryModifiers` incorrectly mutating previous query instances when chaining\n-   Fix [#2681](https://github.com/invertase/react-native-firebase/issues/2681); NPE in exception handling\n\n## Realtime Database\n\n-   Fix `DatabaseQuery`/`DatabaseQueryModifiers` incorrectly mutating previous query instances when chaining\n\n## Vision\n\n-   Fix [#2666](https://github.com/invertase/react-native-firebase/issues/2666); `textRecognizerProcessImage()` errors with `vision/file-not-found` when using `file://` paths\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/releases/v6.0.2.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n> Please tag any GitHub issues regarding v6 with `[v6]` in the title.\n\n🐞 This is a bug fix release. 🐞\n\n-   [iOS] Fixed an issue where native event listeners were not cleared after using React Native reload\n\n## Analytics\n\n-   [TS] Fix several incorrect type definitions\n\n## Authentication\n\n-   Fix [#2639](https://github.com/invertase/react-native-firebase/issues/2639); Create a stack trace for usage with `NativeFirebaseError`\n-   Fix [#2713](https://github.com/invertase/react-native-firebase/issues/2713); iOS auth event subscriptions not correctly removing on reload\n\n## Firestore\n\n-   Fix [#2719](https://github.com/invertase/react-native-firebase/issues/2719); Only apply `id` cursor when no `order` query modifiers\n\n## ML Vision\n\n-   Fix [#2744](https://github.com/invertase/react-native-firebase/issues/2744); improve `nil` checks on creating dictionary instances\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/releases/v6.0.3.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n> Please tag any GitHub issues regarding v6 with `[v6]` in the title.\n\n🐞 This is a bug fix release. 🐞\n\n## Database\n\n-   [iOS] Fix a crash in development when reloading React Native; [#2770](https://github.com/invertase/react-native-firebase/pull/2770),[#2772](https://github.com/invertase/react-native-firebase/pull/2772).\n\n## Firestore\n\n-   [TS] Fix incorrect `QuerySnapshot` `forEach` types\n\n## Storage\n\n-   [iOS] Fixed an issue where uploading files from `Photos` would fail to locate the asset (`ph://` files)\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/releases/v6.1.0.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n> Please tag any GitHub issues regarding v6 with `[v6]` in the title.\n\n🐞 This is a bug fix and feature release. 🐞\n\n## Features\n\n### SDK & Dependencies Updates\n\n-   Update Firebase Android `BOM` SDK version to v28.0.3 ([#2868](https://github.com/invertase/react-native-firebase/issues/2868)) ([42e034c](https://github.com/invertase/react-native-firebase/commit/42e034c4807da54441d2baeab9f57bbf1a137a4a))\n-   Update Firebase iOS SDK versions to v6.13.0 ([547d0a2](https://github.com/invertase/react-native-firebase/commit/547d0a2d74a68808b29063f9b3aa3e1ac38551fc))\n-   Update new project template to React Native 0.61.5, from 0.60\n    -   ([3e90981](https://github.com/invertase/react-native-firebase/commit/3e909813fb1b14a3baeb3468cb5e78ea86503f60))\n    -   ([#2821](https://github.com/invertase/react-native-firebase/issues/2821)) ([fb4941b](https://github.com/invertase/react-native-firebase/commit/fb4941b6e5dc6b3101eeaa2c1c429300a3e05da7))\n\n### Firestore\n\n-   Add support for `array-contains`, `array-contains-any` & `in` queries ([#2868](https://github.com/invertase/react-native-firebase/issues/2868)) ([42e034c](https://github.com/invertase/react-native-firebase/commit/42e034c4807da54441d2baeab9f57bbf1a137a4a))\n    -   [Learn more about these new querying features here.](https://firebase.googleblog.com/2019/11/cloud-firestore-now-supports-in-queries.html)\n\n### Remote Config\n\n-   Add support for the `minimumFetchInterval` config setting ([#2789](https://github.com/invertase/react-native-firebase/issues/2789)) ([57965e7](https://github.com/invertase/react-native-firebase/commit/57965e73a7e1089335c5446fb91cd44c1b19725d)), closes [/github.com/firebase/firebase-ios-sdk/blob/master/FirebaseRemoteConfig/Sources/Public/FIRRemoteConfig.h#L148-L149](https://github.com//github.com/firebase/firebase-ios-sdk/blob/master/FirebaseRemoteConfig/Sources/Public/FIRRemoteConfig.h/issues/L148-L149)\n\n## Bug Fixes\n\n-   **`admob`:** add null checks for `getCurrentActivity()` usages ([#2913](https://github.com/invertase/react-native-firebase/issues/2913)) ([1fb296d](https://github.com/invertase/react-native-firebase/commit/1fb296dc3bc2ffcf2db1d09f5f17b0209ff8276a))\n-   **`admob,iOS`:** use `AdMob` vs `Admob` for Pod name ([#2922](https://github.com/invertase/react-native-firebase/issues/2922)) ([88a0167](https://github.com/invertase/react-native-firebase/commit/88a01672a8e443e87c7e1513cdb0d0594dd47ed9))\n-   **`analytics`:** TypeScript `logEvent` parameters argument should be optional ([#2822](https://github.com/invertase/react-native-firebase/issues/2822)) ([3b8757c](https://github.com/invertase/react-native-firebase/commit/3b8757c0d4f6787c2e5f1ca2c04e73e809d3deae))\n-   **`analytics`:** use correct `add_to_cart` event name ([#2882](https://github.com/invertase/react-native-firebase/issues/2882)) ([2369c62](https://github.com/invertase/react-native-firebase/commit/2369c629fc21705f32f2a4b6487260e3ab05569e))\n-   **`auth`:** collection was mutated while being enumerated. ([#2900](https://github.com/invertase/react-native-firebase/issues/2900)) ([5471187](https://github.com/invertase/react-native-firebase/commit/5471187b30527cd1157bde209886664e52413a7c))\n-   **`auth`:** don't mutate modifiers ordering when building query key (fixes [#2833](https://github.com/invertase/react-native-firebase/issues/2833)) ([9df493e](https://github.com/invertase/react-native-firebase/commit/9df493e837b6a709b8f61027690219738ffa830a))\n-   **`auth`:** fix exception in `PhoneAuthListener` ([#2828](https://github.com/invertase/react-native-firebase/issues/2828)) ([0843cbd](https://github.com/invertase/react-native-firebase/commit/0843cbdf3a4548c78a93bed115a1b3b0666436d1)), closes [#2639](https://github.com/invertase/react-native-firebase/issues/2639)\n-   **`auth`:** trigger initial listener asynchronously ([#2897](https://github.com/invertase/react-native-firebase/issues/2897)) ([227ab63](https://github.com/invertase/react-native-firebase/commit/227ab631a6163a950af675da690b1467f7616d6c))\n-   **`crashlytics`:** `setCrashlyticsCollectionEnabled` return promise ([#2792](https://github.com/invertase/react-native-firebase/issues/2792)) ([4c19b94](https://github.com/invertase/react-native-firebase/commit/4c19b9439ddf6ecf57e59f7e2d8b64954678d8e5))\n-   **`database,android`:** fix issue where transaction signal state error not caught ([d7252a2](https://github.com/invertase/react-native-firebase/commit/d7252a2d4e1987114ab1a8e5c04f0088a86d2b5b))\n-   **`database,iOS`:** return null snapshot key if does not exist (fixes [#2813](https://github.com/invertase/react-native-firebase/issues/2813)) ([bbf3df9](https://github.com/invertase/react-native-firebase/commit/bbf3df98ab88559de1392cba7163666a31e98ee3))\n-   **`firestore`:** correctly apply internal `__name__` query modifier ([#2866](https://github.com/invertase/react-native-firebase/issues/2866)) ([a5da010](https://github.com/invertase/react-native-firebase/commit/a5da0107ff570dc6327bb3ae5d7fff4143183ac9)), closes [#2854](https://github.com/invertase/react-native-firebase/issues/2854)\n-   **`firestore,iOS`:** settings incorrectly set multiple times ([#2869](https://github.com/invertase/react-native-firebase/issues/2869)) ([ed858c9](https://github.com/invertase/react-native-firebase/commit/ed858c96eee0bcfa796faf3f151116c35a4328c0))\n-   **`messaging`:** `onTokenRefresh(event => event.token)` fixes [#2889](https://github.com/invertase/react-native-firebase/issues/2889) ([1940d6c](https://github.com/invertase/react-native-firebase/commit/1940d6c8fbab64ccf739186cea9633a605237942))\n-   **`messaging`:** typo in `isRegisteredForRemoteNotifications` ([#2645](https://github.com/invertase/react-native-firebase/issues/2645)) ([f0e614f](https://github.com/invertase/react-native-firebase/commit/f0e614f48567645e89e837ee56d3f3d251473b09)), closes [/github.com/invertase/react-native-firebase/blob/master/packages/messaging/ios/RNFBMessaging/RNFBMessagingModule.m#L58](https://github.com//github.com/invertase/react-native-firebase/blob/master/packages/messaging/ios/RNFBMessaging/RNFBMessagingModule.m/issues/L58)\n-   **`messaging,iOS`:** `hasPermission` checks `authorizationStatus` ([#2908](https://github.com/invertase/react-native-firebase/issues/2908)) ([7cab58d](https://github.com/invertase/react-native-firebase/commit/7cab58d87fcba592c697a3441bd77033eb09ab3c))\n-   **`messaging,iOS`:** wait for remote notification registration status ([8c339d1](https://github.com/invertase/react-native-firebase/commit/8c339d10e288ef60e83e38bc4a245c5a251c83ff)), closes [#2657](https://github.com/invertase/react-native-firebase/issues/2657)\n-   **`storage`:** fix video asset resources on iOS13 ([#2750](https://github.com/invertase/react-native-firebase/issues/2750)) ([fded286](https://github.com/invertase/react-native-firebase/commit/fded28621fb5c73c3daba009cc4f2ef6fde21745))\n-   **`storage,iOS`:** handle null Storage metadata values ([#2875](https://github.com/invertase/react-native-firebase/issues/2875)) ([26f752a](https://github.com/invertase/react-native-firebase/commit/26f752a1172a36e7c5ea837c1792610fd37adbb4))\n-   **`storage,iOS`:** handle null Storage metadata values ([#2881](https://github.com/invertase/react-native-firebase/issues/2881)) ([eeb90c0](https://github.com/invertase/react-native-firebase/commit/eeb90c0a376e88f4ceb20a1dc5fd3bb4ce558a61))\n-   **`storage,iOS`:** use long value for `maxResults` list option (fixes [#2804](https://github.com/invertase/react-native-firebase/issues/2804)) ([9488103](https://github.com/invertase/react-native-firebase/commit/94881037e0d304e3a585088be1dcae42be8794a8))\n-   **`storage,js`:** validate that list `maxResults` is an integer value ([2fc9e9d](https://github.com/invertase/react-native-firebase/commit/2fc9e9d537e954989a50f941e2479fbbdb3874c9))\n-   **`template`:** fix invalid flow config file ([1def1c1](https://github.com/invertase/react-native-firebase/commit/1def1c1ce5ee320e7ff8d490e9e711281f5abdda))\n-   **`template`:** add `noCompress` `tflite` by default to android template (for [#2478](https://github.com/invertase/react-native-firebase/issues/2478)) ([9dd3fa6](https://github.com/invertase/react-native-firebase/commit/9dd3fa68c30b8b2f687bae4d9e81f438311ae739))\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/releases/v6.2.0.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n> Please tag any GitHub issues regarding v6 with `[v6]` in the title.\n\nThis priority release implements Apple Authentication support for Firebase Authentication (iOS only);\n\nRecently the [App Store policy changed](https://developer.apple.com/news/?id=09122019b); apps that provide social\nauthentication on iOS must also provide support for Apple Authentication. All new apps submitted to the App Store must\nnow follow these guidelines. Existing apps and app updates have until April 2020 to follow them.\n\nTo help integrate this in your apps we've also built a new React Native library.\n\n* * *\n\n## React Native Apple Authentication\n\n[React Native Apple Authentication](https://github.com/invertase/react-native-apple-authentication) is a React Native\nlibrary that provides access to the Apple Authentication APIs and Button components on iOS and, integrates well with\nReact Native Firebase.\n\n![Apple Authentication library for React Native](https://static.invertase.io/assets/apple-auth.png)\n\nTo help you get started with integrating Apple Authentication we've included a small guide/example specific to Firebase\non the repository.\n\n[\\[Guide: Usage with React Native Firebase\\]](https://github.com/invertase/react-native-apple-authentication/blob/master/docs/FIREBASE.md)\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/releases/v6.3.0.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n> Please tag any GitHub issues regarding v6 with `[v6]` in the title.\n\n🐞 This is a bug fix and feature release. 🐞\n\n## Features\n\n-   Integrated `userAccessGroup` iOS method into the `auth` module ([`#3074`](https://github.com/invertase/react-native-firebase/issues/3074)) ([`#044711c`](https://github.com/invertase/react-native-firebase/commit/044711cf7d70d65c1ecda039f047d2a6bf304770))\n\n### SDK & Dependencies Updates\n\n-   Update iOS dependencies, `Crashlytics` to v3.14.0 & `Fabric` to v1.10.2 ([`#3012`](https://github.com/invertase/react-native-firebase/issues/3012)) ([`#3901634`](https://github.com/invertase/react-native-firebase/commit/39016346e419175119e863b2e2bff10166ddf40c))\n\n### Firestore\n\n-   Add `QueryDocumentSnapshot` interface ([`#5de3770`](https://github.com/invertase/react-native-firebase/commit/5de37708daead91b849674b12fa5da761cbaf649))\n\n## Bug Fixes\n\n-   **`admob`:** add missing `null` checks (([`#2912`](https://github.com/invertase/react-native-firebase/issues/2912)) ([`#b5243cf`](https://github.com/invertase/react-native-firebase/commit/b5243cf25a130d10160635c23846a20435995cad))\n\n-   **`admob`:** set correct loading variable to allow multiple AdMob instances (([`#3185`](https://github.com/invertase/react-native-firebase/issues/3185)) ([`#af768e3`](https://github.com/invertase/react-native-firebase/commit/af768e3eb57975bec8b4c0f0f50dd0f9e7418e27))\n\n-   **`analytics`:** fixed dynamic linking bug whenever analytics parameters are present (([`#3086`](https://github.com/invertase/react-native-firebase/issues/3086)) ([`#716d472`](https://github.com/invertase/react-native-firebase/commit/716d47262098c1ea3dcf56aaa8e04a4dcf0de6be))\n\n-   **`app`:** fix export to correct syntax for valid TypeScript parsing ([`#2e2b24e`](https://github.com/invertase/react-native-firebase/commit/2e2b24e51d43524c9ec5c7becd75b7dcbaca30be))\n\n-   **`app`:** remove `Object.freeze` from app to allow `redux-firestore` to work ([`#2733`](https://github.com/invertase/react-native-firebase/issues/2733)) ([`#46be1b0`](https://github.com/invertase/react-native-firebase/commit/46be1b0c996e976357f1190bede29559be94a162))\n\n-   **`auth`:** fix default parameter for sending sign in link to email ([`#239b35b`](https://github.com/invertase/react-native-firebase/commit/239b35b362289629fa4c46aa792f9b4200545d24))\n\n-   **`auth`:** `sendPasswordResetEmail` second argument is `null` by default to signal no settings ([`#3198`](https://github.com/invertase/react-native-firebase/issues/3198)) ([`#39ceba3`](https://github.com/invertase/react-native-firebase/commit/39ceba33eccf8f4dc6e0f3b4805f0034419742a9))\n\n-   **`crashlytics`:** fix issue where `fileName` variable could be undefined ([`#3079`](https://github.com/invertase/react-native-firebase/issues/3079)) ([`#1813e14`](https://github.com/invertase/react-native-firebase/commit/1813e14d581ef8f8a50606388468a98c046ac818))\n\n-   **`crashlytics`:** JavaScript source maps now available in Crashlytics ([`#3084`](https://github.com/invertase/react-native-firebase/issues/3084)) ([`#036a50e`](https://github.com/invertase/react-native-firebase/commit/036a50e7b8328ab51ee202300f91069edd2f4cf2))\n\n-   **`database`:** add key to the `Reference` type for (([`#3072`](https://github.com/invertase/react-native-firebase/issues/3072)) ([`#b8490a5`](https://github.com/invertase/react-native-firebase/commit/b8490a58a8844d88cd944e0b1d8d2fa3dfb3418f))\n\n-   **`firestore`:** offline Android lookup was crashing when looking up a document ([`#2757`](https://github.com/invertase/react-native-firebase/issues/2757)) ([`#c66bfc6`](https://github.com/invertase/react-native-firebase/commit/c66bfc61db8538cc9c1b15fa8a1c46f4cdbc580b))\n\n-   **`firestore`:** Can use `in` operator when using `where()` for numbers ([`#3004`](https://github.com/invertase/react-native-firebase/issues/3004)) ([`#13a6560`](https://github.com/invertase/react-native-firebase/commit/13a6560a403b353c46dff0a0a8c52fb64241f4f8))\n\n-   **`firestore`:** collection group queries with document snapshot as bound works ([`#3063`](https://github.com/invertase/react-native-firebase/issues/3063)) ([`#a3aaff3`](https://github.com/invertase/react-native-firebase/commit/a3aaff353f173a386af77c7302c7b23e55b28f2c))\n\n-   **`firestore`:** handle `FieldPath` as array value ([`#3178`](https://github.com/invertase/react-native-firebase/issues/3178)) ([`#2cb6d44`](https://github.com/invertase/react-native-firebase/commit/2cb6d44b77051f3831ed52b2687ce254d407904d))\n\n-   **`ios`:** handle `Info.plist` file paths with spaces ([`#ceddf99`](https://github.com/invertase/react-native-firebase/commit/ceddf996739204ce2c971eb1819bf11640b1cace))\n\n-   **`ios`:** use correct import of `RCTBridgeModule.h` ([`#7db4cd8`](https://github.com/invertase/react-native-firebase/commit/7db4cd883ab71f40fd8c9886c80d7e7489acbcc2))\n\n-   **`messaging`:** corrected TypeScript signature for `setBackgroundMessageHandler` ([`#a2879b6`](https://github.com/invertase/react-native-firebase/commit/a2879b60fda86232737a437f3c74110d4652aacd))\n\n-   **`perf`:** fixed a bug which stopped custom performance metrics from working ([`#3119`](https://github.com/invertase/react-native-firebase/issues/3119)) ([`#1e56721`](https://github.com/invertase/react-native-firebase/commit/1e567214e95b199c8d7a2ed2f804cffd83a89510))\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/releases/v6.4.0.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n## Features\n\n-   `iOS`: added a `Podfile` option to allow using React Native Firebase packages as static frameworks ([`#3253`](https://github.com/invertase/react-native-firebase/issues/3253)) ([`#530f8bb`](https://github.com/invertase/react-native-firebase/commit/530f8bbb51f89f106854dbf1df5ec80211e2cf8b))\n    -   see [Allow iOS Static Frameworks](/#allow-ios-static-frameworks) to learn more. This option will default to true in the next major release.\n\n### Messaging\n\n-   added support for `onNotificationOpenedApp` & `getInitialNotification` APIs.\n    -   these can be used to detect if a user opened the app via pressing a notification. ([`#d66a611`](https://github.com/invertase/react-native-firebase/commit/d66a6118f82005087f53b86571990fc071402153))\n-   the `RemoteMessage` event (e.g. via `onMessage`) now includes a notification payload (if present). ([`#d66a611`](https://github.com/invertase/react-native-firebase/commit/d66a6118f82005087f53b86571990fc071402153))\n-   `setBackgroundMessageHandler` now supported on iOS. ([`#d66a611`](https://github.com/invertase/react-native-firebase/commit/d66a6118f82005087f53b86571990fc071402153))\n-   the iOS permissions API has been upgraded to now support custom permissions.\n    -   the permission API selects sensible defaults, however; allows you to fully customize them if required.\n    -   provisional permissions are now disabled by default (previously, it was enabled by default for iOS 12+ devices). ([`#d66a611`](https://github.com/invertase/react-native-firebase/commit/d66a6118f82005087f53b86571990fc071402153))\n-   the `requestPermission` & `hasPermission` APIs now returns the current authorization status as an enum, rather than a boolean value.\n    -   see [`AuthorizationStatus`](/reference/messaging/authorizationstatus) reference documentation for available enum members\n\n* * *\n\n## Bug Fixes\n\n-   `iOS`: update `in-app-messaging` dependency to latest package name in iOS `InAppMessaging` ([`#166692d`](https://github.com/invertase/react-native-firebase/commit/166692d68ef396f3e8664edd7feab7c80038004b))\n\n### Analytics\n\n-   logging event parameters can be objects and arrays ([`#2876`](https://github.com/invertase/react-native-firebase/issues/2876)) ([`#eebfb04`](https://github.com/invertase/react-native-firebase/commit/eebfb04a7c0a856a9d5d311ae99138df9ab90c3b))\n-   update `logEvent` types ([`#65ec7eb`](https://github.com/invertase/react-native-firebase/commit/65ec7eb431712f8c4d3cf96c24489e6a13ef4e13))\n\n### Authentication\n\n-   `user.metadata.lastSignInTime` & `user.metadata.creationTime` now correctly return an ISO date string ([`#2555`](https://github.com/invertase/react-native-firebase/issues/2555)) ([`#8adef65`](https://github.com/invertase/react-native-firebase/commit/8adef653faa008e0146374f99f5ba1af902749bf))\n\n### Dynamic Links\n\n-   switch `ShortLinkType` interface to an enum ([`#870d0a1`](https://github.com/invertase/react-native-firebase/commit/870d0a198692c65d2857765d1b216738ec74856f))\n-   fix links options not correctly applied in iOS ([`#54bc6f8`](https://github.com/invertase/react-native-firebase/commit/54bc6f8403b12a8cfaf0b862d13310ef28076d06))\n-   fix missing return statement causing bug in iOS ([`#3315`](https://github.com/invertase/react-native-firebase/issues/3315)) ([`#1661f6e`](https://github.com/invertase/react-native-firebase/commit/1661f6e084c47ed835cc4539c654286964a6d9a8))\n\n### Firestore\n\n-   improve Firestore query validation;\n-   `where` field parameter cannot match `orderBy` parameter ([`#6311dc8`](https://github.com/invertase/react-native-firebase/commit/6311dc8f68e6cf0605d2f306885d2fbc0ef779d6))\n-   field path cannot be used with a `orderBy` parameter ([`#ea19622`](https://github.com/invertase/react-native-firebase/commit/b90a736fc8f9a1b25239bb68e5a62de711b673c7))\n\n### Functions\n\n-   correctly throw an `UNAVAILABLE` error code on network IO errors for Android to match iOS ([`#3310`](https://github.com/invertase/react-native-firebase/issues/3310)) ([`#7351147`](https://github.com/invertase/react-native-firebase/commit/73511472bd7690158f3d9924d5f4d8c0cad69910))\n\n### Messaging\n\n-   `onMessage` now works correctly for `data-only`, `notification-only` & `data-notification` messages. Previously it only worked for `data-only` messages\n-   `setBackgroundMessageHandler` now works when the app fully quit or backgrounded, for `data-only`, `notification-only` & `data-notification` messages. Previously, when the app was fully quit, events were not being handled\n    -   for iOS this requires `content-available` to be set\n-   add better handling for messages in cases where no user handler has been set\n-   `Android`: ensure a default notification color is always present when user does not set one\n-   `iOS`: calling `registerDeviceForRemoteMessages`/`registerForRemoteNotifications` was incorrectly causing permissions to be requested before explicitly requesting them via the messaging API\n-   `iOS`: registering the device was not being called if it was already registered internally.\n    -   Devices should **always** register with `registerDeviceForRemoteMessages`, as per Apple guidelines, irregardless of current registration status.\n    -   Make sure you **always** call `registerDeviceForRemoteMessages` during your app initialization on iOS\n-   `iOS`: in cases where requesting an FCM with the default `scope` & `authorizedEntity`, the underlying code now uses the recommended `instanceIDWithHandler` vs `tokenWithAuthorizedEntity`.\n    -   This fixes an issue where FCM would throw a `\"The operation couldn’t be completed\"` error ([`#2657`](https://github.com/invertase/react-native-firebase/issues/2657))\n-   `iOS`: direct FCM connection is now fixed.\n    -   When the app was in the foreground, `data-only` messages were not coming through, they are now.\n-   `iOS`: when running debug build, the APNs token will be registered with FCM as a `\"sandbox\"` key type\n-   `iOS`: the original APNs swizzling we implemented was not functioning correctly with `application:didReceiveRemoteNotification:fetchCompletionHandler:`.\n    -   We added additional logic whereby this is executed in all scenarios (foreground/background/quit) and replaces a deprecated Apple API.\n    -   This fixes issues with `data-only` messages not being handled by the device\n-   `iOS`: any custom `FIRMessagingDelegate` methods you add to your `AppDelegate.m` will now also be called internally by React Native Firebase messaging.\n\n### Storage\n\n-   fixed a bug that occurred when parsing encoded URLs ([`#2753`](https://github.com/invertase/react-native-firebase/issues/2753)) ([`#8e99b9c`](https://github.com/invertase/react-native-firebase/commit/8e99b9cb9093ba0cc3aadcb56127c8500ea8bf36))\n-   storage tasks now correctly have a `snapshot` property - to match the Web SDK\n-   `put` method now correctly returns a thenable `Task` instance instead of a promise ([`#ea19622`](https://github.com/invertase/react-native-firebase/commit/ea1962270b6c20d5b15dbaaea5c4d88a0a4ae3e2))\n\n* * *\n\n## Deprecations\n\n### Messaging\n\n-   `registerForRemoteNotifications` has been deprecated in favor of `registerDeviceForRemoteMessages`.\n    -   It will be removed in a following major version. Underlying functionality has not changed - renamed to avoid confusion with messages vs notifications. ([`#d66a611`](https://github.com/invertase/react-native-firebase/commit/d66a6118f82005087f53b86571990fc071402153))\n-   `isRegisteredForRemoteNotifications` has been deprecated in favor of `isDeviceRegisteredForRemoteMessages`.\n    -   It will be removed in a following major version. Underlying functionality has not changed - renamed to avoid confusion with messages vs notifications. ([`#d66a611`](https://github.com/invertase/react-native-firebase/commit/d66a6118f82005087f53b86571990fc071402153))\n-   `unregisterForRemoteNotifications` has been deprecated in favor of `unregisterDeviceForRemoteMessages`.\n    -   It will be removed in a following major version. Underlying functionality has not changed - renamed to avoid confusion with messages vs notifications. ([`#d66a611`](https://github.com/invertase/react-native-firebase/commit/d66a6118f82005087f53b86571990fc071402153))\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/remote-config/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/storage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/admob/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThe AdMob service call be used with the `@react-native-firebase/admob` module. This module requires that the\n`@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the admob module\nyarn add @react-native-firebase/admob\n```\n\n> On Android, you must update the \"Contains ads\" setting in the Google Play Store dashboard before releasing your app (under \"Pricing & Distribution\").\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/admob/usage/installation/ios) and [Android](/admob/usage/installation/android).\n\n# What does it do\n\nThe AdMob module allows you to display adverts to your users. All adverts are served over the Google AdMob network, meaning\na [Google AdMob account](https://apps.admob.com) is required.\n\n<Youtube id=\"9qCxo0D-Sak\" />\n\nThe module supports three types of Ads:\n\n1.  Full screen [Interstitial Ads](/admob/displaying-ads#interstitial-ads).\n2.  Full screen [Rewarded Ads](/admob/displaying-ads#rewarded-ads).\n3.  Component based [Banner Ads](/admob/displaying-ads#banner-ads).\n\n# Getting Started\n\nA number of steps must be taken and considered before you start serving adverts to your users:\n\n-   [Installation](#installation)\n-   [Getting Started](#getting-started)\n    -   [Setting up Google AdMob](#setting-up-google-admob)\n    -   [Configure outbound requests](#configure-outbound-requests)\n    -   [European User Consent](#european-user-consent)\n    -   [Test ads](#test-ads)\n-   [Next Steps](#next-steps)\n\n## Setting up Google AdMob\n\nBefore you are able to display ads to your users, you must have a [Google AdMob account](https://apps.admob.com). Under the\n\"Apps\" menu item, create or choose an existing Android/iOS app. Each app platform exposes a unique account ID which needs to\nbe added to the project.\n\n> Attempting to build your app without a valid App ID may cause a crash during build.\n\nUnder the \"App settings\" menu item, you can find the \"App ID\":\n\n![Google AdMob App ID](https://prismic-io.s3.amazonaws.com/invertase%2F52dd6900-108c-47a6-accb-699fde963b99_new+project+%2813%29.jpg)\n\nWithin the root of your React Native project, create a `firebase.json` file (if it doesn't already exist) and add the\n`admob_android_app_id` & `admob_ios_app_id` keys with the IDs from the Google AdMob console:\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"admob_android_app_id\": \"ca-app-pub-xxxxxxxx~xxxxxxxx\",\n    \"admob_ios_app_id\": \"ca-app-pub-xxxxxxxx~xxxxxxxx\"\n  }\n}\n```\n\nFor the changes to take effect, rebuild your project:\n\n```bash\n# For iOS\ncd ios/ && pod install\nnpx react-native run-ios\n\n# For Android\nnpx react-native run-android\n```\n\n## Configure outbound requests\n\nBefore requesting ads, you must tell the AdMob network what type of content you'd wish to receive based on your target\naudience.\n\nFor example, if the application targets children then you must configure the outbound requests to only\nreceive content suitable for children before loading any adverts.\n\nTo set the request configuration, call the `setRequestConfiguration` method:\n\n```js\nimport admob, { MaxAdContentRating } from '@react-native-firebase/admob';\n\nadmob()\n  .setRequestConfiguration({\n    // Update all future requests suitable for parental guidance\n    maxAdContentRating: MaxAdContentRating.PG,\n\n    // Indicates that you want your content treated as child-directed for purposes of COPPA.\n    tagForChildDirectedTreatment: true,\n\n    // Indicates that you want the ad request to be handled in a\n    // manner suitable for users under the age of consent.\n    tagForUnderAgeOfConsent: true,\n  })\n  .then(() => {\n    // Request config successfully set!\n  });\n```\n\nTo learn more about the request configuration settings, view the [`RequestConfiguration`](/reference/admob/requestconfiguration) documentation.\n\n## European User Consent\n\nOut of the box, AdMob does not handle any related regulations which you may need to enforce on your application.\nIt is up to the developer to implement and handle this on a user-by-user basis. You must consent to EEA users\nbeing served both personalized and non-personalized adverts before showing them. For more information, see\n[Requesting Consent from European Users](https://developers.google.com/admob/android/eu-consent).\n\nThe AdMob module provides a `AdConsent` helper to help developers quickly implement consent flows within their application.\nSee the [European User Consent page](/admob/european-user-consent) for full examples of how to integrate the helper into your application.\n\n## Test ads\n\nWhilst developing your app with AdMob, you'll want to make sure you use test ads rather than production ads from your\nGoogle AdMob account - otherwise your account may be disabled!\n\nAlthough usage of different advert types is explained later, when creating your adverts the \"Ad Unit ID\" being used whilst\ntesting can be set to a testing ID. The code snippet below shows how to initialize each advert type with a test ID:\n\n```jsx\nimport { InterstitialAd, RewardedAd, BannerAd, TestIds } from '@react-native-firebase/admob';\n\n# Interstitial\nInterstitialAd.createForAdRequest(TestIds.INTERSTITIAL);\n\n# Rewarded\nRewardedAd.createForAdRequest(TestIds.REWARDED);\n\n# Banners\n<BannerAd unitId={TestIds.BANNER} />\n```\n\n# Next Steps\n\nNow the basics of setting up and configuring AdMob have been explained, we can go ahead and start to display different\nadverts to our users. The AdMob module provides integration with three different types:\n\n-   [Interstitial Ads](/admob/displaying-ads#interstitial-ads)\n-   [Rewarded Ads](/admob/displaying-ads#rewarded-ads)\n-   [Banner Ads](/admob/displaying-ads#banner-ads)\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/analytics/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the analytics module\nyarn add @react-native-firebase/analytics\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/analytics/usage/installation/ios) and [Android](/analytics/usage/installation/android).\n\n# What does it do\n\nAnalytics collects usage and behavior data for your app. Its two primary concerns are:\n\n-   **Events**: What is happening in your app, such as user actions, system events, or errors.\n-   **User properties**: Attributes you define to describe segments of your user base, such as language preference or geographic location.\n\n<Youtube id=\"8iZpH7O6zXo\" />\n\nAnalytics automatically logs some [events](https://support.google.com/analytics/answer/9234069) and [user properties](https://support.google.com/analytics/answer/9268042); you don't need to add any code to enable them. However, Analytics also allows you to log [custom](#Custom-Events) or [predefined](#Predefined-Events) events within your app. How you can do this will be explained below.\n\n# Usage\n\nAnalytics offers a wealth of [Predefined Events](#Predefined-Events) to track user behavior. Analytics also offers folks the ability to log [Custom Events](#Custom-Events) . If you're already familiar with Google Analytics, this method is equivalent to using the event command in [gtag.js](https://developers.google.com/gtagjs/).\n\n## Custom Events\n\nBelow is an example showing how a custom event can be logged. Please be aware that primitive data types or arrays of primitive data types are logged in your Firebase Analytics console.\n\n```jsx\nimport react, { useEffect } from 'react';\nimport { View, Button } from 'react-native';\nimport analytics from '@react-native-firebase/analytics';\n\nfunction App() {\n  return (\n    <View>\n      <Button\n        title=\"Add To Basket\"\n        onPress={() =>\n          analytics().logEvent('basket', {\n            id: 3745092,\n            item: 'mens grey t-shirt',\n            description: ['round neck', 'long sleeved'],\n            size: 'L',\n          })\n        }\n      />\n    </View>\n  );\n}\n```\n\n## Predefined Events\n\nTo help you get started, Analytics provides a number of [event methods](/reference/analytics) that are common among\ndifferent types of apps, including retail and e-commerce, travel, and gaming apps. To learn more about these events and\nwhen to use them, browse the [Events and properties](https://support.google.com/analytics/answer/9322688?hl=en&ref_topic=9267641)\narticles in the Firebase Help Center.\n\nBelow is a sample of how to use one of the predefined methods the Analytics module provides for you:\n\n```jsx\nimport react, { useEffect } from 'react';\nimport { View, Button } from 'react-native';\nimport analytics from '@react-native-firebase/analytics';\n\nfunction App() {\n  return (\n    <View>\n      <Button\n        title=\"Press me\"\n        // Logs in the firebase analytics console as \"select_content\" event\n        // only accepts the two object properties which accept strings.\n        onPress={() =>\n          analytics().logSelectContent({\n            content_type: 'clothing',\n            item_id: 'abcd',\n          })\n        }\n      />\n    </View>\n  );\n}\n```\n\nFor a full reference to predefined events and expected parameters, please check out the [reference API](/reference/analytics).\n\n## Reserved Events\n\nThe Analytics package works out of the box, however a number of events are automatically reported to Firebase.\nThese event names are called as 'Reserved Events'. Attempting to send any custom event using the `logEvent` method\nwith any of the following event names will throw an error.\n\n| Reserved Events Names  |                           |                     |\n| ---------------------- | ------------------------- | ------------------- |\n| `app_clear_data`       | `app_uninstall`           | `app_update`        |\n| `error`                | `first_open`              | `first_visit`       |\n| `first_open_time`      | `first_visit_time`        | `in_app_purchase`   |\n| `notification_dismiss` | `notification_foreground` | `notification_open` |\n| `notification_receive` | `os_update`               | `session_start`     |\n| `screen_view`          | `user_engagement`         | `ad_impression`     |\n| `ad_click`             | `ad_query`                | `ad_exposure`       |\n| `adunit_exposure`      | `ad_activeiew`            |                     |\n\n# firebase.json\n\n## Disable Auto-Initialization\n\nAnalytics can be further configured to disable auto collection of Analytics data. This is useful for opt-in-first\ndata flows, for example when dealing with GDPR compliance. This is possible by setting the below noted property\non the `firebase.json` file at the root of your project directory.\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"analytics_auto_collection_enabled\": false\n  }\n}\n```\n\nTo re-enable analytics (e.g. once you have the users consent), call the `setAnalyticsCollectionEnabled` method:\n\n```js\nawait firebase.analytics().setAnalyticsCollectionEnabled(true);\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/auth/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\"\nmodule, view the [Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the authentication module\nyarn add @react-native-firebase/auth\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/auth/usage/installation/ios) and [Android](/auth/usage/installation/android).\n\n# What does it do\n\nFirebase Authentication provides backend services & easy-to-use SDKs to authenticate users to your app. It supports\nauthentication using passwords, phone numbers, popular federated identity providers like Google, Facebook and Twitter, and more.\n\n<Youtube id=\"8sGY55yxicA\" />\n\nFirebase Authentication integrates tightly with other Firebase services, and it leverages industry standards like OAuth\n2.0 and OpenID Connect, so it can be easily integrated with your custom backend.\n\n# Usage\n\n## Listening to authentication state\n\nIn most scenarios using Authentication, you will want to know whether your users are currently signed-in or signed-out\nof your application. The module provides a method called `onAuthStateChanged` which allows you to subscribe to the users\ncurrent authentication state, and receive an event whenever that state changes.\n\nIt is important to remember the `onAuthStateChanged` listener is asynchronous and will trigger an initial state once\na connection with Firebase has been established. Therefore it is important to setup an \"initializing\" state which blocks\nrender of our main application whilst the connection is established:\n\n```jsx\nimport React, { useState, useEffect } from 'react';\nimport { View, Text } from 'react-native';\nimport auth from '@react-native-firebase/auth';\n\nfunction App() {\n  // Set an initializing state whilst Firebase connects\n  const [initializing, setInitializing] = useState(true);\n  const [user, setUser] = useState();\n\n  // Handle user state changes\n  function onAuthStateChanged(user) {\n    setUser(user);\n    if (initializing) setInitializing(false);\n  }\n\n  useEffect(() => {\n    const subscriber = auth().onAuthStateChanged(onAuthStateChanged);\n    return subscriber; // unsubscribe on unmount\n  }, []);\n\n  if (initializing) return null;\n\n  if (!user) {\n    return (\n      <View>\n        <Text>Login</Text>\n      </View>\n    );\n  }\n\n  return (\n    <View>\n      <Text>Welcome {user.email}</Text>\n    </View>\n  );\n}\n```\n\nIf the `user` returned within the handler is `null` we assume the user is currently signed-out, otherwise they are\nsigned-in and a [`User`](/reference/auth/user) interface is returned.\n\nThe `onAuthStateChanged` method also returns an unsubscriber function which allows us to stop listening for events whenever\nthe hook is no longer in use.\n\n## Persisting authentication state\n\nOn web based applications, the Firebase Web SDK takes advantage of features such as cookies and local storage to persist\nthe users authenticated state across sessions. The native Firebase SDKs also provide this functionality using device native SDKs,\nensuring that a users previous authentication state between app sessions is persisted.\n\nThe user is able to clear their state by deleting the apps data/cache from the device settings.\n\n## Anonymous sign-in\n\nSome applications don't require authentication, which make it tricky to identify what users are doing throughout your app.\nIf connecting with external APIs, it is also useful to add an extra layer of security by ensuring the users request is\nfrom the app. This can be achieved with the `signInAnonymously` method, which creates a new anonymous user which is persisted,\nallowing you to integrate with other services such as Analytics by providing a user ID.\n\nEnsure the \"Anonymous\" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).\n\n```js\nimport auth from '@react-native-firebase/auth';\n\nauth()\n  .signInAnonymously()\n  .then(() => {\n    console.log('User signed in anonymously');\n  })\n  .catch(error => {\n    if (error.code === 'auth/operation-not-allowed') {\n      console.log('Enable anonymous in your firebase console.');\n    }\n\n    console.error(error);\n  });\n```\n\nOnce successfully signed in, any [`onAuthStateChanged`](#listening-to-authentication-state) listeners will trigger an event\nwith the [`User`](/reference/auth/user) details.\n\nIn case any errors occur, the module provides support for identifying what specifically went wrong by attaching a code\nto the error. For a full list of error codes available, view the [Firebase documentation](https://firebase.google.com/docs/reference/js/firebase.auth.Auth#error-codes_9).\n\n## Email/Password sign-in\n\nEmail/password sign in is a common method for user sign in on applications. This requires the user to provide an email\naddress and secure password. Users can both register and sign in using a method called `createUserWithEmailAndPassword`\nor sign in to an existing account with `signInWithEmailAndPassword`.\n\nEnsure the \"Email/Password\" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).\n\nThe `createUserWithEmailAndPassword` performs two operations; first creating the user if they do not already exist, and\nthen signing them in.\n\n```js\nimport auth from '@react-native-firebase/auth';\n\nauth()\n  .createUserWithEmailAndPassword('jane.doe@example.com', 'SuperSecretPassword!')\n  .then(() => {\n    console.log('User account created & signed in!');\n  })\n  .catch(error => {\n    if (error.code === 'auth/email-already-in-use') {\n      console.log('That email address is already in use!');\n    }\n\n    if (error.code === 'auth/invalid-email') {\n      console.log('That email address is invalid!');\n    }\n\n    console.error(error);\n  });\n```\n\nOnce successfully created and/or signed in, any [`onAuthStateChanged`](#listening-to-authentication-state) listeners will trigger an event\nwith the [`User`](/reference/auth/user) details.\n\nIn case any errors occur, the module provides support for identifying what specifically went wrong by attaching a code\nto the error. For a full list of error codes available, view the [Firebase documentation](https://firebase.google.com/docs/reference/js/firebase.auth.Auth#error-codes_3).\n\n## Signing out\n\nIf you'd like to sign the user out of their current authentication state, call the `signOut` method:\n\n```js\nimport auth from '@react-native-firebase/auth';\n\nauth()\n  .signOut()\n  .then(() => console.log('User signed out!'));\n```\n\nOnce successfully created and/or signed in, any [`onAuthStateChanged`](#listening-to-authentication-state) listeners will trigger an event\nwith the `user` parameter being a `null` value.\n\n## Other sign-in methods\n\nFirebase also supports authenticating with external provides. To learn more, view the documentation for your authentication\nmethod:\n\n-   [Apple Sign-In](/auth/social-auth#apple).\n-   [Facebook Sign-In](/auth/social-auth#facebook).\n-   [Twitter Sign-In](/auth/social-auth#twitter).\n-   [Google Sign-In](/auth/social-auth#google).\n-   [Phone Number Sign-In](/auth/phone-auth).\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/crashlytics/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the Crashlytics module\nyarn add @react-native-firebase/crashlytics\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nOnce installed, you must complete the following additional setup steps for Android:\n\n-   [Android Additional Setup](/crashlytics/android-setup).\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/crashlytics/usage/installation/ios) and [Android](/crashlytics/usage/installation/android).\n\n# What does it do\n\nCrashlytics helps you to collect analytics and details about crashes and errors that occur in your app. It does this through three aspects:\n\n-   **Logs**: Log events in your app to be sent with the crash report for context if your app crashes.\n-   **Crash reports**: Every crash is automatically turned into a crash report and sent.\n-   **Stack traces**: Even when an error is caught and your app recovers, the JavaScript stack trace can still be sent.\n\n<Youtube id=\"k_mdNRZzd30\" />\n\nTo learn more, view the [Firebase Crashlytics documentation](https://firebase.google.com/docs/crashlytics?utm_source=invertase&utm_medium=react-native-firebase&utm_campaign=crashlytics).\n\n# Usage\n\nUse the `log` method throughout your app to accumulate extra context for possible crashes that can happen. For additional context, Crashlytics also offers [various methods](#crash-attributes) to set attributes for the crash report. You can also test Crashlytics by forcing a crash through the `crash` method.\n\nCrashlytics also supports sending JavaScript stack traces to the Firebase console. This can be used in any situation where an error occurs but is caught by your own code to recover gracefully. To send a stack trace, pass a JavaScript Error to the `recordError` method.\n\n> Crash reporting is disabled by default whilst developing. To enable this, view the [enable debug crash logs](#enable-debug-crash-logs) documentation.\n\n## Crash Attributes\n\nThere are various methods to set attributes for the crash report, in order to provide analytics for crashes and help you review them. You can use set methods to set predefined attributes, but you can also set your own custom attributes.\n\n```js\nimport React, { useEffect } from 'react';\nimport { View, Button } from 'react-native';\nimport crashlytics from '@react-native-firebase/crashlytics';\n\nasync function onSignIn(user) {\n  crashlytics().log('User signed in.');\n  await Promise.all([\n    crashlytics().setUserId(user.uid),\n    crashlytics().setAttribute('credits', String(user.credits)),\n    crashlytics().setAttributes({\n      role: 'admin',\n      followers: '13',\n      email: user.email,\n      username: user.username\n    }),\n  ]);\n}\n\nexport default function App() {\n  useEffect(() => {\n    crashlytics().log('App mounted.');\n  }, []);\n\n  return (\n    <View>\n      <Button\n        title=\"Sign In\"\n        onPress={() =>\n          onSignIn({\n            uid: 'Aa0Bb1Cc2Dd3Ee4Ff5Gg6Hh7Ii8Jj9',\n            username: 'Joaquin Phoenix',\n            email: 'phoenix@example.com',\n            credits: 42,\n          })\n        }\n      />\n      <Button title=\"Test Crash\" onPress={() => crashlytics().crash()} />\n    </View>\n  );\n}\n```\n\n## Error Reports\n\nEven if you catch unexpected errors, in order for your app to recover and behave smoothly you can still report them through\nCrashlytics using the `recordError` method. This will also provide you with the associated stack trace.\n\n```jsx\nimport React, { useState, useEffect } from 'react';\nimport { View, Text } from 'react-native';\nimport crashlytics from '@react-native-firebase/crashlytics';\n\nconst users = [];\n\nexport default function App() {\n  const [userCounts, setUserCounts] = useState(null);\n\n  function updateUserCounts() {\n    crashlytics().log('Updating user count.');\n    try {\n      if (users) {\n        // An empty array is truthy, but not actually true.\n        // Therefore the array was never initialised.\n        setUserCounts(userCounts.push(users.length));\n      }\n    } catch (error) {\n      crashlytics().recordError(error);\n      console.log(error);\n    }\n  }\n\n  useEffect(() => {\n    crashlytics().log('App mounted.');\n    if (users == true) setUserCounts([]);\n    updateUserCounts();\n  }, []);\n\n  if (userCounts) {\n    return (\n      <View>\n        <Text>There are currently {userCounts[userCounts.length - 1]} users.</Text>\n      </View>\n    );\n  }\n\n  return (\n    <View>\n      <Text>Unable to display user information.</Text>\n    </View>\n  );\n}\n```\n\n## Opt-out\n\nAs Crashlytics will be sending certain information regarding the user, users may want to opt-out of the crash reporting.\nThis can be done throughout the app with a simple method call to `setCrashlyticsCollectionEnabled`:\n\n```jsx\nimport React, { useState } from 'react';\nimport { View, Button, Text } from 'react-native';\nimport crashlytics from '@react-native-firebase/crashlytics';\n\nexport default function App() {\n  const [enabled, setEnabled] = useState(crashlytics().isCrashlyticsCollectionEnabled);\n\n  async function toggleCrashlytics() {\n    await crashlytics()\n      .setCrashlyticsCollectionEnabled(!enabled)\n      .then(() => setEnabled(crashlytics().isCrashlyticsCollectionEnabled));\n  }\n\n  return (\n    <View>\n      <Button title=\"Toggle Crashlytics\" onPress={toggleCrashlytics} />\n      <Button title=\"Crash\" onPress={() => crashlytics().crash()} />\n      <Text>Crashlytics is currently {enabled ? 'enabled' : 'disabled'}</Text>\n    </View>\n  );\n}\n```\n\n# firebase.json\n\n## Disable Auto Collection\n\nAdditionally, you can configure whether Crashlytics sends out any reports through the `auto_collection_enabled` option in\nyour `firebase.json` config. If you want users to opt-in, it is recommended that you disable this here and enable it later\nthrough the method once they opt-in.\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"crashlytics_auto_collection_enabled\": false\n  }\n}\n```\n\n## Enable debug crash logs\n\nBecause you have stack traces readily available while you're debugging your app, Crashlytics is disabled by default in debug mode. You can set Crashlytics to be enabled regardless of debug mode through the `debug_enabled` option in your `firebase.json`.\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"crashlytics_debug_enabled\": true\n  }\n}\n```\n\n## Crashlytics NDK\n\nReact Native Firebase supports [Crashlytics NDK](https://docs.fabric.io/android/crashlytics/ndk.html#using-gradle) reporting\nwhich is enabled by default. This allows Crashlytics to capture crashes originating from the Yoga layout engine used by\nReact Native. You can disable Crashlytics NDK in your `firebase.json` config.\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"crashlytics_ndk_enabled\": false\n  }\n}\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/database/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the database module\nyarn add @react-native-firebase/database\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install && cd ..\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/database/usage/installation/ios) and [Android](/database/usage/installation/android).\n\n# What does it do\n\nThe Realtime Database is a cloud-hosted database. Data is stored as JSON and synchronized in realtime to every connected\nclient. React Native Firebase provides native integration with the Android & iOS Firebase SDKs, supporting both realtime\ndata sync and offline capabilities.\n\n<Youtube id=\"U5aeM5dvUpA\" />\n\nTo learn more, view the [Firebase Realtime Database documentation](https://firebase.google.com/docs/database?utm_source=invertase&utm_medium=react-native-firebase&utm_campaign=database).\n\n# Usage\n\n## References\n\nA core concept to understanding Realtime Database are references - a reference to a specific node within your database. A node\ncan be a specific property or sub-nodes.\n\nTo create a [`Reference`](/reference/database/reference), call the `ref` method:\n\n```js\nimport database from '@react-native-firebase/database';\n\nconst reference = database().ref('/users/123');\n```\n\n## Reading data\n\nThe Realtime Data provides the ability to read the value of a reference as a one-time read, or realtime changes to the node.\nWhen a value is read from the database, the API returns a [`DataSnapshot`](/reference/database/datasnapshot).\n\nThe snapshot includes information such as whether the reference node exists, it's value or any children the node has and more.\n\n### One-time read\n\nTo read the value once, call the `once` method on a reference:\n\n```js\nimport database from '@react-native-firebase/database';\n\ndatabase()\n  .ref('/users/123')\n  .once('value')\n  .then(snapshot => {\n    console.log('User data: ', snapshot.val());\n  });\n```\n\n### Realtime changes\n\nTo setup an active listener to react to any changes to the node and it's children, call the `on` method with an event handler:\n\n```js\nimport database from '@react-native-firebase/database';\n\ndatabase()\n  .ref('/users/123')\n  .on('value', snapshot => {\n    console.log('User data: ', snapshot.val());\n  });\n```\n\nThe event handler will be called straight away with the snapshot data, and further called when any changes to the node\noccur.\n\nYou can unsubscribe from events by calling the `off` method. To unsubscribe from specific events, call the `off` method\nwith the function that the event handler returned. This can be used within any `useEffect` hooks to automatically unsubscribe\nwhen the hook needs to unsubscribe itself:\n\n```jsx\nimport React, { useEffect } from 'react';\nimport database from '@react-native-firebase/database';\n\nfunction User({ userId }) {\n  useEffect(() => {\n    const onValueChange = database()\n      .ref(`/users/${userId}`)\n      .on('value', snapshot => {\n        console.log('User data: ', snapshot.val());\n      });\n\n    // Stop listening for updates when no longer required\n    return () =>\n      database()\n        .ref(`/users/${userId}`)\n        .off('value', onValueChange);\n  }, [userId]);\n}\n```\n\n#### Additional events\n\nThe above example demonstrates how to subscribe to events whenever a value within the node changes. In some cases, you\nmay need to only subscribe to events whenever a child node is added/changed/moved/removed. This can be achieved by passing\na different [`EventType`](/reference/database/eventtype) to the `on` method.\n\nIf you are listening to a node with many children, only listening to data you care about helps reduce network bandwidth\nand speeds up your application.\n\n```jsx\nimport React, { useEffect } from 'react';\nimport database from '@react-native-firebase/database';\n\nfunction User({ userId }) {\n  useEffect(() => {\n    const onChildAdd = database()\n      .ref('/users')\n      .on('child_added', snapshot => {\n        console.log('A new node has been added', snapshot.val());\n      });\n\n    // Stop listening for updates when no longer required\n    return () =>\n      database()\n        .ref('/users')\n        .off('child_added', onChildAdd);\n  }, [userId]);\n}\n```\n\n### Querying\n\nRealtime Database provides support for basic querying of your data. When a reference node contains children, you can both\norder & limit the returned results.\n\nIf your application requires more advanced query capabilities, it is recommended you use [Cloud Firestore](/firestore).\n\n#### Ordering\n\nBy default, results are ordered based on the node [keys](#database-keys). If however you are using custom keys you can use\none of the `orderByX` methods to order your data.\n\nFor example, if all of the nodes children are scalar values (string, number or boolean) you can use the `orderByValue` method,\nand Firebase will automatically order the results. The example below would return the `def` node before the `abc` node:\n\n```js\n/*\n * {\n *   'scores': {\n *     'abc: 30,\n *     'def': 50,\n *   }\n * }\n */\n\nconst scores = database()\n  .ref('scores')\n  .orderByValue()\n  .once('value');\n```\n\nPlease note that the ordering will not be respected if you do not use the `forEach` method provided on the `DataSnapshot`.\n\n#### Limiting\n\nYou can limit the number of results returned from a query by using one of the `limitToX` methods. For example, to limit to the\nfirst 10 results:\n\n```js\nconst users = database()\n  .ref('users')\n  .limitToFirst(10)\n  .once('value');\n```\n\nFirebase also provides the ability to return the last set of results in a query via the `limitToLast` method.\n\nInstead of limiting to a specific number of documents, you can also start from, or end at a specific reference node value:\n\n```js\nawait database()\n  .ref('users')\n  .orderByChild('age')\n  .startAt(21)\n  .once('value');\n```\n\n## Writing data\n\nThe [Firebase documentation](https://firebase.google.com/docs/database/web/structure-data) provides great examples on best\npractices on how to structure your data. We highly recommend reading the guide before building out your database.\n\n### Setting data\n\nThe `set` method on a [`Reference`](/reference/database/reference) overwrites all of the existing data at that reference node.\nThe value can be anything; a string, number, object etc:\n\n```js\nimport database from '@react-native-firebase/database';\n\ndatabase()\n  .ref('/users/123')\n  .set({\n    name: 'Ada Lovelace',\n    age: 31,\n  })\n  .then(() => console.log('Data set.'));\n```\n\nIf you set the value to `null`, Firebase will automatically class the node as removed, and delete it from the database.\n\n### Updating data\n\nRather than overwriting all existing data, the `update` method provides the ability to update any existing data on the reference node.\nFirebase will automatically merge the data depending on what currently exists.\n\n```js\nimport database from '@react-native-firebase/database';\n\ndatabase()\n  .ref('/users/123')\n  .update({\n    age: 32,\n  })\n  .then(() => console.log('Data updated.'));\n```\n\n### Pushing data\n\nCurrently the examples have only demonstrated working with known reference node keys (e.g. `/users/123`). In some cases,\nyou may not have a suitable id or may want Firebase to automatically create a node with a generated key. The `push` method\nreturns a [`ThenableReference`](/reference/database/thenablereference), allowing you to observe a node before it is\nsent to remote Firebase database.\n\nThe `push` method will automatically generate a new key if one is not provided:\n\n```js\nconst newReference = database()\n  .ref('/users')\n  .push();\n\nconsole.log('Auto generated key: ', newReference.key);\n\nnewReference\n  .set({\n    age: 32,\n  })\n  .then(() => console.log('Data updated.'));\n```\n\nThe keys generated are ordered to the current time, so the list of items returned from Firebase will be chronologically\nsorted by default.\n\n## Removing data\n\nTo remove data, you can call the `remove` method on a reference:\n\n```js\nawait database()\n  .ref('/users/123')\n  .remove();\n```\n\nOptionally, you can also set the value of a reference node to `null` to remove it from the database:\n\n```js\nawait database()\n  .ref('/users/123')\n  .set(null);\n```\n\n## Transactions\n\nTransactions are a way to always ensure a write occurs with the latest information available on the server. Transactions never\npartially apply writes & all writes execute at the end of a successful transaction.\n\nImagine a scenario whereby an app has the ability to \"Like\" user posts. Whenever a user presses the \"Like\" button,\nthe `/likes/:postId` value (number of likes) on the database increments. Without transactions, we'd first need to\nread the existing value and then increment that value in two separate operations.\n\nOn a high traffic application, the value on the server could already have changed by the time the operation sets a new value,\ncausing the actual number to not be consistent.\n\nTransactions remove this issue by atomically updating the value on the server. If the value changes whilst the transaction\nis executing, it will retry. This always ensures the value on the server is used rather than the client value.\n\nTo execute a new transaction, call the `transaction` method on a reference:\n\n```js\nimport database from '@react-native-firebase/database';\n\nfunction onPostLike(postId) {\n  const reference = database().ref(`/likes/${postId}`);\n\n  // Execute transaction\n  return reference.transaction(currentLikes => {\n    if (currentLikes === null) return 1;\n    return currentLikes + 1;\n  });\n}\n\n// When post \"567\" is liked\nonPostLike('567').then(transaction => {\n  console.log('New post like count: ', transaction.snapshot.val());\n});\n```\n\nOnce the transaction is successful, a promise is resolved with a value containing whether the operation committed on the remote\ndatabase and the new [`DataSnapshot`](/reference/database/datasnapshot) containing the new value.\n\n# Securing data\n\nIt is important that you understand how to write rules in your Firebase console to ensure that your data is secure.\nPlease follow the Firebase Realtime Database documentation on [security](https://firebase.google.com/docs/database/security)\n\n# Using a secondary database\n\nIf the default installed Firebase instance needs to address a different database within the same project, call the database method on the default app with passing the database URL.\nFor example:\n\n```js\nimport { firebase } from '@react-native-firebase/database';\n\nconst database = firebase.app().database('https://path-to-database.firebaseio.com');\n\ndatabase.ref();\n```\n\n## Connect to a database of a secondary app\n\nIf you want to address a database from a different Firebase project, you will need to create a secondary app first\n(Read more on creating a secondary app here: <https://rnfirebase.io/app/usage>).\nFor example:\n\n```js\nimport database, { firebase } from '@react-native-firebase/database';\n\n// create a secondary app\nconst secondaryApp = await firebase.initalizeApp(credentials, config);\n\n// pass the secondary app instance to the database module\nconst secondaryDatabase = database(secondaryApp);\n\nsecondaryDatabase.ref();\n```\n\n# firebase.json\n\n## Enabling persistence\n\nThe Realtime Database can be set to persist data on the user application to be used by the SDKs for offline usage\nand caching. To enable this functionality, update the `database_persistence_enabled` key in the `firebase.json` file:\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"database_persistence_enabled\": true\n  }\n}\n```\n\nFor more on persistence, view the [Offline Support](/database/offline-support) documentation.\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/dynamic-links/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the dynamic-links module\nyarn add @react-native-firebase/dynamic-links\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/dynamic-links/usage/installation/ios) and [Android](/dynamic-links/usage/installation/android).\n\n# What does it do\n\nDynamic Links are links that work the way you want, on either iOS or Android and whether or not your app is already installed.\n\n<Youtube id=\"LvY1JMcrPF8\" />\n\nWith Dynamic Links, your users get the best available experience for the platform they open your link on. If a user opens\na Dynamic Link on iOS or Android, they can be taken directly to the linked content in your app.\n\n# Usage\n\n## Firebase Setup\n\n1.  Open the Dynamic Links tab and configure a new domain for your app. In this test example, I've created one for `https://rnfbtestapplication.page.link`.\n\n![Firebase console dynamic link first step](https://images.prismic.io/invertase/4152f98c-b4e9-4561-a790-a0750a0392bb_Screenshot+2020-05-07+at+09.26.47.png?auto=compress,format)\n\n2.  Create a dynamic link with your domain in the Firebase console. The freshly created dynamic link URL will appear in the table.\n\n![Firebase console dynamic link second step](https://images.prismic.io/invertase/7e5c7a61-899f-45e5-ab4e-ddf3cfee636a_Screenshot+2020-05-07+at+10.26.22.png?auto=compress,format)\n\n## iOS Setup\n\nTo setup Dynamic Links on iOS, it is a **prerequisite** that you have an Apple developer account [setup](https://developer.apple.com/programs/enroll/).\n\n1.  Add an `App Store ID` & `Team ID` to your app in your Firebase console. If you do not have an `App Store ID` yet, you can put any number in here for now. Your `Team ID` can be found in your Apple developer console.\n\n![iOS dynamic link first step](https://images.prismic.io/invertase/30e302f6-a7bb-4e37-98fd-7115dac4c1f1_Screenshot+2020-05-07+at+09.10.02.png?auto=compress,format)\n\n2.  Test the domain you created in your Firebase console (first step in `Firebase Setup`). Go to the following location in your browser `[your domain]/apple-app-site-association`. The response will have a `details` array property containing an object that has the property `appID`. That will be your app's app ID (It may take some\n    time for your domain to register). Please ensure it is registered before proceeding.\n\n3.  Once you're sure your domain is registered, you need to head over to your Apple developer console and create a provisioning profile for your app. Please ensure you've enabled the `Associated Domain` capability which you should check before proceeding.\n\n![iOS dynamic link third step](https://images.prismic.io/invertase/12d6e692-c2b1-47f5-98aa-f364c928114a_Screenshot+2020-05-07+at+10.03.45.png?auto=compress,format)\n\n4.  Open your project in Xcode and open your app under the `TARGETS` header. Click the `Signing & Capabilities` tab. You will need to ensure your `Team` is registered, and your `Provisioning Profile` field is completed. Please add the domain you created in your\n    Firebase console to the `Associated Domains` and prefix with `applinks:`\n\n![iOS dynamic link fourth step](https://images.prismic.io/invertase/d7a8696f-bef1-44a4-b048-aab7bb534f71_Screenshot+2020-05-07+at+09.55.53.png?auto=compress,format)\n\n5.  Click the `Info` tab, and add a `URL Type` to your project. The `Identifier` can be called `Bundle Id` or whatever you wish. Add your bundle identifier to the `URL Schemes` property.\n\n![iOS dynamic link fifth step](https://images.prismic.io/invertase/cb029ba6-ad40-494e-a3f6-2aacaff494d1_Screenshot+2020-05-07+at+10.16.16.png?auto=compress,format)\n\n### Dynamic Links With Custom Domains\n\nIf you have set up a [custom domain](https://firebase.google.com/docs/dynamic-links/custom-domains) for your Firebase project, you must add the dynamic link URL prefix into your iOS project's `info.plist` file by using the  `FirebaseDynamicLinksCustomDomains` key. You can add multiple URLs as well.\n\nExample:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>FirebaseDynamicLinksCustomDomains</key>\n  <array>\n    <string>https://custom.domain.io/bla</string>\n    <string>https://custom.domain.io/bla2</string>\n  </array>\n  \n  ...other settings\n  \n</dict>\n</plist>\n```\n\nIf you don't add this, the dynamic link will invoke your app, but you cannot retrieve any deep link data you may need within your app, as the deep link will be completely ignored.\n\n## iOS Testing Your Dynamic Link\n\nTo test your dynamic link, you will need to use a real device as it will not work on a simulator.\n\n### Application Is Installed On Device\n\nThe iOS Notes app is a good place to paste your dynamic link and test it opens your app. It should work even if it is not a published app.\n\n### Application Is Not Installed On Device\n\n1.  Switch the `App Store ID` in your Firebase Console project settings to a valid App Store ID e.g. iOS Notes App Store ID.\n\n2.  Generate a new dynamic link and associate with your app.\n\n3.  Paste the link in iOS Notes app. When you press, it should take you to the App Store for the ID you listed in your project settings. Just by making it to the App Store is good enough to indicate your dynamic link is working.\n\n## iOS Troubleshooting\n\n1.  Ensure you have the right URL in the Associated Domains in Xcode.\n\n![iOS troubleshooting first step](https://images.prismic.io/invertase/35c09a84-8a84-4a12-8352-0364a6a784bf_Screenshot+2020-05-22+at+09.28.53.png?auto=compress,format)\n\n2.  Ensure you have input the correct Team ID in the Firebase console.\n\n![iOS troubleshooting second step](https://images.prismic.io/invertase/4af777b7-7a2e-48a8-a0dc-23cea50e1a4b_Screenshot+2020-05-22+at+09.40.18.png?auto=compress,format)\n\n3.  Paste your link into the iOS Notes app. Long press the link which will open the menu and ensure you click \"Open in [YOUR APP NAME]\". Be sure _not_ to press \"Open in Safari\" as that will disable that dynamic link domain for your device.\n\n![iOS troubleshooting third step](https://images.prismic.io/invertase/1f8b049d-e54c-4901-a369-e7f6a19a444c_FA031D26-E14F-4A92-87F2-442191455537.png?auto=compress,format)\n\n4.  Ensure your dynamic link domain has an Apple app site association file for your app. Check in the browser by going to the following address: `[your domain]/apple-app-site-association`\n\n![iOS troubleshooting fourth step](https://images.prismic.io/invertase/10f825ac-6cd1-487d-9195-a1d86c7511f7_Screenshot+2020-05-22+at+10.00.57.png?auto=compress,format)\n\n5.  There is a known bug that you can follow [here](http://bit.ly/2y8gey4) that stops Apple from downloading the app site association file. The work around is to uninstall your app, restart your device and reinstall your app.\n\n## Android Setup\n\n1.  Create a SHA-256 fingerprint using these [instructions](https://developers.google.com/android/guides/client-auth) for your app, and add to your app in your Firebase console.\n\n![android dynamic link first step](https://images.prismic.io/invertase/ac7615cb-ea4f-49d8-ba2e-5d6d4d209520_Screenshot+2020-05-07+at+10.47.48.png?auto=compress,format)\n\n2.  Test the domain you created in your Firebase console (first step in `Firebase Setup`). Go to the following location in your browser `[your-domain]/.well-known/assetlinks.json`. The response will have a `target` object containing a `package_name` which ought to have your app's package name. Please\n    do not proceed until you see this, it may take a while to register.\n\n3.  Test the dynamic link works via your emulator by pasting it into in a text message, notepad or email, and checking that it does open your application (ensure the app is installed on the emulator).\n\n## Create a Link\n\nYou can create dynamic links via the Firebase console, your app or even your custom API. Please refer to [Firebase create dynamic link documentation](https://firebase.google.com/docs/dynamic-links/create-links) for further details. Below, we will show how to build links as part of your application code:\n\n```jsx\nimport dynamicLinks from '@react-native-firebase/dynamic-links';\n\nasync function buildLink() {\n  const link = await dynamicLinks().buildLink({\n    link: 'https://invertase.io',\n    // domainUriPrefix is created in your Firebase console\n    domainUriPrefix: 'https://xyz.page.link',\n    // optional set up which updates Firebase analytics campaign\n    // \"banner\". This also needs setting up before hand\n    analytics: {\n      campaign: 'banner',\n    },\n  });\n\n  return link;\n}\n```\n\n## Listening for Dynamic Links\n\nThe module provides two methods for reacting to events related to the application in the foreground & background/quit.\n\n### Foreground events\n\nWhen the app is in the foreground (visible on the device), you can use the `onLink` method to subscribe to events as and\nwhen they happen:\n\n```jsx\nimport dynamicLinks from '@react-native-firebase/dynamic-links';\n\nfunction App() {\n  const handleDynamicLink = link => {\n    // Handle dynamic link inside your own application\n    if (link.url === 'https://invertase.io/offer') {\n      // ...navigate to your offers screen\n    }\n  };\n\n  useEffect(() => {\n    const unsubscribe = dynamicLinks().onLink(handleDynamicLink);\n    // When the is component unmounted, remove the listener\n    return () => unsubscribe();\n  }, []);\n\n  return null;\n}\n```\n\n### Background/Quit events\n\nIf the application is in a background state / has fully quit then the `getInitialLink` method can be used to detect whether\nthe application was opened via a link:\n\n```jsx\nimport dynamicLinks from '@react-native-firebase/dynamic-links';\n\nfunction App() {\n  useEffect(() => {\n    dynamicLinks()\n      .getInitialLink()\n      .then(link => {\n        if (link.url === 'https://invertase.io/offer') {\n          // ...set initial route as offers screen\n        }\n      });\n  }, []);\n\n  return null;\n}\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/firestore/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the firestore module\nyarn add @react-native-firebase/firestore\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/firestore/usage/installation/ios) and [Android](firestore/usage/installation/android).\n\nIf you have started to receive a `app:mergeDexDebug` error after adding Cloud Firestore, please read the\n[Enabling Multidex](/enabling-multidex) documentation for more information on how to resolve this error.\n\n# What does it do\n\nFirestore is a flexible, scalable NoSQL cloud database to store and sync data. It keeps your data in sync across client\napps through realtime listeners and offers offline support so you can build responsive apps that work regardless of network\nlatency or Internet connectivity.\n\n<Youtube id=\"QcsAb2RR52c\" />\n\n# Usage\n\n## Collections & Documents\n\nCloud Firestore stores data within \"documents\", which are contained within \"collections\", and documents can also contain\ncollections. For example, we could store a list of our users documents within a \"Users\" collection. The `collection` method\nallows us to reference a collection within our code:\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nconst usersCollection = firestore().collection('Users');\n```\n\nThe `collection` method returns a [`CollectionReference`](/reference/firestore/collectionreference) class, which provides\nproperties and methods to query and fetch the data from Cloud Firestore. We can also directly reference a single document\non the collection by calling the `doc` method:\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\n// Get user document with an ID of ABC\nconst userDocument = firestore()\n  .collection('Users')\n  .doc('ABC');\n```\n\nThe `doc` method returns a [`DocumentReference`](/reference/firestore/documentreference).\n\nA document can contain different types of data, including scalar values (strings, booleans, numbers), arrays (lists) and\nobjects (maps) along with specific Cloud Firestore data such as [Timestamps](/reference/firestore/timestamp),\n[GeoPoints](/reference/firestore/geopoint), [Blobs](/reference/firestore/blob) and more.\n\n## Read Data\n\nCloud Firestore provides the ability to read the value of a collection or document. This can be read one-time, or provide\nrealtime updates when the data within a query changes.\n\n### One-time read\n\nTo read a collection or document once, call the `get` method on a [`CollectionReference`](/reference/firestore/collectionreference)\nor [`DocumentReference`](/reference/firestore/documentreference):\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nconst users = await firestore()\n  .collection('Users')\n  .get();\nconst user = await firestore()\n  .collection('Users')\n  .doc('ABC')\n  .get();\n```\n\n### Realtime changes\n\nTo setup an active listener to react to any changes to the query, call the `onSnapshot` method with an event handler callback.\nFor example, to watch the entire \"Users\" collection for when any documents are changed (removed, added, modified):\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nfunction onResult(QuerySnapshot) {\n  console.log('Got Users collection result.');\n}\n\nfunction onError(error) {\n  console.error(error);\n}\n\nfirestore()\n  .collection('Users')\n  .onSnapshot(onResult, onError);\n```\n\nThe `onSnapshot` method also returns a function, allowing you to unsubscribe from events. This can be used within any\n`useEffect` hooks to automatically unsubscribe when the hook needs to unsubscribe itself:\n\n```js\nimport React, { useEffect } from 'react';\nimport firestore from '@react-native-firebase/firestore';\n\nfunction User({ userId }) {\n  useEffect(() => {\n    const subscriber = firestore()\n      .collection('Users')\n      .doc(userId)\n      .onSnapshot(documentSnapshot => {\n        console.log('User data: ', documentSnapshot.data());\n      });\n\n    // Stop listening for updates when no longer required\n    return () => subscriber();\n  }, [userId]);\n}\n```\n\nRealtime changes via the `onSnapshot` method can be applied to both collections and documents.\n\n### Snapshots\n\nOnce a query has returned a result, Firestore returns either a [`QuerySnapshot`](/reference/firestore/querysnapshot) (for\ncollection queries) or a [`DocumentSnapshot`](/reference/firestore/documentsnapshot) (for document queries). These snapshots\nprovide the ability to view the data, view query metadata (such as whether the data was from local cache), whether the\ndocument exists or not and more.\n\n#### `QuerySnapshot`\n\nA [`QuerySnapshot`](/reference/firestore/querysnapshot) returned from a collection query allows you to inspect the collection,\nsuch as how many documents exist within it, access to the documents within the collection, any changes since the last query\nand more.\n\nTo access the documents within a `QuerySnapshot`, call the `forEach` method:\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nfirestore()\n  .collection('Users')\n  .get()\n  .then(querySnapshot => {\n    console.log('Total users: ', querySnapshot.size);\n\n    querySnapshot.forEach(documentSnapshot => {\n      console.log('User ID: ', documentSnapshot.id, documentSnapshot.data());\n    });\n  });\n```\n\nEach child document of a `QuerySnapshot` is a [`QueryDocumentSnapshot`](/reference/firestore/querydocumentsnapshot), which\nallows you to access specific information about a document (see below).\n\n#### `DocumentSnapshot`\n\nA [`DocumentSnapshot`](/reference/firestore/documentsnapshot) is returned from a query to a specific document, or as part\nof the documents returned via a [`QuerySnapshot`](/reference/firestore/querysnapshot). The snapshot provides the ability\nto view a documents data, metadata and whether a document actually exists.\n\nTo view a documents data, call the `data` method on the snapshot:\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nfirestore()\n  .collection('Users')\n  .doc('ABC')\n  .get()\n  .then(documentSnapshot => {\n    console.log('User exists: ', documentSnapshot.exists);\n\n    if (documentSnapshot.exists) {\n      console.log('User data: ', documentSnapshot.data());\n    }\n  });\n```\n\nA snapshot also provides a helper function to easily access deeply nested data within a document. Call the `get` method\nwith a dot-notated path:\n\n```js\nfunction getUserZipCode(documentSnapshot) {\n  return documentSnapshot.get('info.address.zipcode');\n}\n\nfirestore()\n  .collection('Users')\n  .doc('ABC')\n  .get()\n  .then(documentSnapshot => getUserZipCode(documentSnapshot))\n  .then(zipCode => {\n    console.log('Users zip code is: ', zipCode);\n  });\n```\n\n### Querying\n\nCloud Firestore offers advanced capabilities for querying collections.\n\n#### Filtering\n\nTo filter documents within a collection, the `where` method can be chained onto a collection reference. Filtering supports\nequality checks and \"in\" queries. For example, to filter users where their age is greater or equal than 18 years old:\n\n```js\nfirestore()\n  .collection('Users')\n  // Filter results\n  .where('age', '>=', 18)\n  .get()\n  .then(querySnapshot => {\n    /* ... */\n  });\n```\n\nCloud Firestore also supports array membership queries. For example, to filter users who speak both English (en) or\nFrench (fr), use the `in` filter:\n\n```js\nfirestore()\n  .collection('Users')\n  // Filter results\n  .where('languages', 'in', ['en', 'fr'])\n  .get()\n  .then(querySnapshot => {\n    /* ... */\n  });\n```\n\nTo learn more about all of the querying capabilities Cloud Firestore has to offer, view the\n[Firebase documentation](https://firebase.google.com/docs/firestore/query-data/queries).\n\n#### Limiting\n\nTo limit the number of documents returned from a query, use the `limit` method on a collection reference:\n\n```js\nfirestore()\n  .collection('Users')\n  // Filter results\n  .where('age', '>=', 18)\n  // Limit results\n  .limit(20)\n  .get()\n  .then(querySnapshot => {\n    /* ... */\n  });\n```\n\nThe above example both filters the users by age and limits the documents returned to 20.\n\n#### Ordering\n\nTo order the documents by a specific value, use the `orderBy` method:\n\n```js\nfirestore()\n  .collection('Users')\n  // Order results\n  .orderBy('age', 'desc')\n  .get()\n  .then(querySnapshot => {\n    /* ... */\n  });\n```\n\nThe above example orders all user in the snapshot by age in descending order.\n\n#### Start/End\n\nTo start and/or end the query at a specific point within the collection, you can pass either a value to the `startAt`,\n`endAt`, `startAfter` or `endBefore` methods. You must specify an order to use pointers, for example:\n\n```js\nfirestore()\n  .collection('Users')\n  .orderBy('age', 'desc')\n  .startAt(18)\n  .endAt(30)\n  .get()\n  .then(querySnapshot => {\n    /* ... */\n  });\n```\n\nThe above query orders the users by age in descending order, but only returns users whose age is between 18 and 30.\n\nYou can further specify a [`DocumentSnapshot`](/reference/firestore/documentsnapshot) instead of a specific value. For example:\n\n```js\nconst userDocumentSnapshot = await firestore()\n  .collection('Users')\n  .doc('DEF')\n  .get();\n\nfirestore()\n  .collection('Users')\n  .orderBy('age', 'desc')\n  .startAt(userDocumentSnapshot)\n  .get()\n  .then(querySnapshot => {\n    /* ... */\n  });\n```\n\nThe above query orders the users by age in descending order, however only returns documents whose order starts at the user\nwith an ID of `DEF`.\n\n#### Query Limitations\n\nCloud Firestore does not support the following types of queries:\n\n-   Queries with range filters on different fields, as described in the previous section.\n-   Logical OR queries. In this case, you should create a separate query for each OR condition and merge the query results in your app.\n-   Queries with a `!=` clause. In this case, you should split the query into a greater-than query and a less-than query.\n    For example, although the query clause `where(\"age\", \"!=\", \"30\")` is not supported, you can get the same result set by\n    combining two queries, one with the clause `where(\"age\", \"<\", \"30\")` and one with the clause `where(\"age\", \">\", 30)`.\n\n## Writing Data\n\nThe [Firebase documentation](https://firebase.google.com/docs/firestore/manage-data/structure-data) provides great examples\non best practices on how to structure your data. We highly recommend reading the guide before building out your database.\n\nFor a more in-depth look at what is possible when writing data to Firestore please refer to this [documentation](https://firebase.google.com/docs/firestore/manage-data/add-data)\n\n## Adding documents\n\nTo add a new document to a collection, use the `add` method on a [`CollectionReference`](/reference/firestore/collectionreference):\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nfirestore()\n  .collection('Users')\n  .add({\n    name: 'Ada Lovelace',\n    age: 30,\n  })\n  .then(() => {\n    console.log('User added!');\n  });\n```\n\nThe `add` method adds the new document to your collection with a random unique ID. If you'd like to specify your own ID,\ncall the `set` method on a [`DocumentReference`](/reference/firestore/documentreference) instead:\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nfirestore()\n  .collection('Users')\n  .doc('ABC')\n  .set({\n    name: 'Ada Lovelace',\n    age: 30,\n  })\n  .then(() => {\n    console.log('User added!');\n  });\n```\n\n### Updating documents\n\nThe `set` method exampled above replaces any existing data on a given [`DocumentReference`](/reference/firestore/documentreference).\nif you'd like to update a document instead, use the `update` method:\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nfirestore()\n  .collection('Users')\n  .doc('ABC')\n  .update({\n    age: 31,\n  })\n  .then(() => {\n    console.log('User updated!');\n  });\n```\n\nThe method also provides support for updating deeply nested values via dot-notation:\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nfirestore()\n  .collection('Users')\n  .doc('ABC')\n  .update({\n    'info.address.zipcode': 94040,\n  })\n  .then(() => {\n    console.log('User updated!');\n  });\n```\n\n#### Field values\n\nCloud Firestore supports storing and manipulating values on your database, such as [Timestamps](/reference/firestore/timestamp),\n[GeoPoints](/reference/firestore/geopoint), [Blobs](/reference/firestore/blob) and array management.\n\nTo store [`GeoPoint`](/reference/firestore/geopoint) values, provide the latitude and longitude to a new instance of the\nclass:\n\n```js\nfirestore()\n  .doc('users/ABC')\n  .update({\n    'info.address.location': new firestore.GeoPoint(53.483959, -2.244644),\n  });\n```\n\nTo store a [Blob](/reference/firestore/blob) (for example of a `Base64` image string), provide the string to the static\n`fromBase64String` method on the class:\n\n```js\nfirestore()\n  .doc('users/ABC')\n  .update({\n    'info.avatar': firestore.Blob.fromBase64String('data:image/png;base64,iVBOR...'),\n  });\n```\n\nWhen storing timestamps, it is recommended you use the `serverTimestamp` static method on the [`FieldValue`](/reference/firestore/fieldvalue)\nclass. When written to the database, the Firebase servers will write a new timestamp based on their time, rather than the clients. This helps\nresolve any data consistency issues with different client timezones:\n\n```js\nfirestore()\n  .doc('users/ABC')\n  .update({\n    createdAt: firestore.FieldValue.serverTimestamp(),\n  });\n```\n\nCloud Firestore also allows for storing arrays. To help manage the values with an array (adding or removing) the API\nexposes an `arrayUnion` and `arrayRemove` methods on the [`FieldValue`](/reference/firestore/fieldvalue) class.\n\nTo add a new value to an array (if it does not exist):\n\n```js\nfirestore()\n  .doc('users/ABC')\n  .update({\n    fcmTokens: firestore.FieldValue.arrayUnion('ABCDE123456'),\n  });\n```\n\nTo remove a value from the array (if it exists):\n\n```js\nfirestore()\n  .doc('users/ABC')\n  .update({\n    fcmTokens: firestore.FieldValue.arrayRemove('ABCDE123456'),\n  });\n```\n\n## Removing data\n\nYou can delete documents within Cloud Firestore using the `delete` method on a [`DocumentReference`](/reference/firestore/documentreference):\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nfirestore()\n  .collection('Users')\n  .doc('ABC')\n  .delete()\n  .then(() => {\n    console.log('User deleted!');\n  });\n```\n\nAt this time, you cannot delete an entire collection without use of a Firebase Admin SDK.\n\n> If a document contains any sub-collections, these will not be deleted from database. You must delete\n> any sub-collections yourself.\n\nIf you need to remove a specific property with a document, rather than the document itself, you can use the `delete`\nmethod on the [`FieldValue`](/reference/firestore/fieldvalue) class:\n\n```js\nfirestore()\n  .collection('Users')\n  .doc('ABC')\n  .update({\n    fcmTokens: firestore.FieldValue.delete(),\n  });\n```\n\n## Transactions\n\nTransactions are a way to always ensure a write occurs with the latest information available on the server. Transactions\nnever partially apply writes & all writes execute at the end of a successful transaction.\n\nTransactions are useful when you want to update a field's value based on its current value, or the value of some other field.\nIf you simply want to write multiple documents without using the document's current state, a [batch write](#batch-write) would be more appropriate.\n\nWhen using transactions, note that:\n\n-   Read operations must come before write operations.\n-   A function calling a transaction (transaction function) might run more than once if a concurrent edit affects a document that the transaction reads.\n-   Transaction functions should not directly modify application state (return a value from the `updateFunction`).\n-   Transactions will fail when the client is offline.\n\nImagine a scenario whereby an app has the ability to \"Like\" user posts. Whenever a user presses the \"Like\" button,\na \"likes\" value (number of likes) on a \"Posts\" collection document increments. Without transactions, we'd first need to read\nthe existing value and then increment that value in two separate operations.\n\nOn a high traffic application, the value on the server could already have changed by the time the operation sets a new value,\ncausing the actual number to not be consistent.\n\nTransactions remove this issue by atomically updating the value on the server. If the value changes whilst the transaction\nis executing, it will retry. This always ensures the value on the server is used rather than the client value.\n\nTo execute a new transaction, call the `runTransaction` method:\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nfunction onPostLike(postId) {\n  // Create a reference to the post\n  const postReference = firestore().doc(`posts/${postId}`);\n\n  return firestore().runTransaction(async transaction => {\n    // Get post data first\n    const postSnapshot = await transaction.get(postReference);\n\n    if (!postSnapshot.exists) {\n      throw 'Post does not exist!';\n    }\n\n    await transaction.update(postReference, {\n      likes: postSnapshot.data().likes + 1,\n    });\n  });\n}\n\nonPostLike('ABC')\n  .then(() => console.log('Post likes incremented via a transaction'))\n  .catch(error => console.error(error));\n```\n\n## Batch write\n\nIf you do not need to read any documents in your operation set, you can execute multiple write operations as a single batch\nthat contains any combination of `set`, `update`, or `delete` operations. A batch of writes completes atomically and can\nwrite to multiple documents.\n\nFirst, create a new batch instance via the `batch` method, perform operations on the batch and finally commit it once ready.\nThe example below shows how to delete all documents in a collection in a single operation:\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nasync function massDeleteUsers() {\n  // Get all users\n  const usersQuerySnapshot = await firestore()\n    .collection('Users')\n    .get();\n\n  // Create a new batch instance\n  const batch = firestore().batch();\n\n  usersQuerySnapshot.forEach(documentSnapshot => {\n    batch.delete(documentSnapshot.ref);\n  });\n\n  return batch.commit();\n}\n\nmassDeleteUsers().then(() => console.log('All users deleted in a single batch operation.'));\n```\n\n## Secure your data\n\nIt is important that you understand how to write rules in your Firebase console to ensure that your data is secure. Please\nfollow the Firebase Firestore documentation on [security](https://firebase.google.com/docs/firestore/security/get-started).\n\n## Offline Capabilities\n\nFirestore provides out of the box support for offline capabilities. When reading and writing data, Firestore uses a local\ndatabase which synchronizes automatically with the server. Firestore functionality continues when users are offline, and\nautomatically handles data migration to the server when they regain connectivity.\n\nThis functionality is enabled by default, however it can be disabled if you need it to be disabled (e.g. on apps containing\nsensitive information). The `settings()` method must be called before any Firestore interaction is performed, otherwise it will only take effect on the next app launch:\n\n```js\nimport firestore from '@react-native-firebase/firestore';\n\nasync function bootstrap() {\n  await firestore().settings({\n    persistence: false, // disable offline persistence\n  });\n}\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/functions/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the functions module\nyarn add @react-native-firebase/functions\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/functions/usage/installation/ios) and [Android](/functions/usage/installation/android).\n\n# What does it do\n\nFirebase Cloud Functions let you automatically run backend code in response to events triggered by Firebase features and\nHTTPS requests. Your code is stored in Google's cloud and runs in a managed environment. There's no need to manage and\nscale your own servers.\n\n<Youtube id=\"vr0Gfvp5v1A\" />\n\nAfter you write and deploy a function, Google's servers begin to manage the function immediately. You can fire the function\ndirectly with an HTTP request, via the Cloud Functions module, or in the case of background functions, Google's servers will listen for events and run\nthe function when it is triggered.\n\nFor more information on use cases, view the [Firebase Cloud Functions](https://firebase.google.com/docs/functions/use-cases) documentation.\n\n# Usage\n\nThe Cloud Functions module provides the functionality to directly trigger deployed HTTPS callable functions, without worrying\nabout security or implementing a HTTP request library.\n\nFunctions deployed to Firebase have unique names, allowing you to easily identify which endpoint you wish to send a request to.\nTo learn more about deploying Functions to Firebase, view the [Writing & Deploying Functions](/functions/writing-deploying-functions) documentation.\n\n## Calling an endpoint\n\nAssuming we have a deployed a callable endpoint named `listProducts`, to call the endpoint the library exposes a\n`httpsCallable` method. For example:\n\n```js\n// Deployed HTTPS callable\nexports.listProducts = functions.https.onCall(() => {\n  return [\n    /* ... */\n    // Return some data\n  ];\n});\n```\n\nWithin the React Native application, the list of products returned can be directly accessed:\n\n```jsx\nimport functions from '@react-native-firebase/functions';\n\nfunction App() {\n  const [loading, setLoading] = useState(true);\n  const [products, setProducts] = useState([]);\n\n  useEffect(() => {\n    functions()\n      .httpsCallable('listProducts')()\n      .then(response => {\n        setProducts(response.data);\n        setLoading(false);\n      });\n  }, []);\n\n  if (loading) {\n    return null;\n  }\n\n  // ...\n}\n```\n\n## Using an emulator\n\nWhilst developing your application with Cloud Functions, it is possible to run the functions inside of a local emulator.\n\nTo call the emulated functions, call the `useFunctionsEmulator` method exposed by the library:\n\n```js\nimport functions from '@react-native-firebase/functions';\n\n// Use a local emulator in development\nif (__DEV__) {\n  functions().useFunctionsEmulator('http://localhost:5000');\n}\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/iid/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the iid module\nyarn add @react-native-firebase/iid\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/iid/usage/installation/ios) and [Android](/iid/usage/installation/android).\n\n# What does it do\n\nInstance ID provides a simple API to generate security tokens that authorize third parties to access your apps server side\nmanaged resources.\n\nAn example of this is sending messages via Firebase Cloud Messaging.\n\n# Usage\n\n## Retrieving the instance ID\n\nTo retrieve the current instance ID, call the `get` method:\n\n```js\nimport iid from '@react-native-firebase/iid';\n\nasync function getInstanceId() {\n  const id = await iid().get();\n  console.log('Current Instance ID: ', id);\n}\n```\n\n## Retrieving a token\n\nReturns the token that authorizes performing actions on behalf of this application instance.\n\nFor example, the token could be used to send messages via Firebase Cloud Messaging.\n\n```js\nimport iid from '@react-native-firebase/iid';\n\nconst token = await firebase.iid().getToken();\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/in-app-messaging/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the in-app-messaging module\nyarn add @react-native-firebase/in-app-messaging\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/in-app-messaging/usage/installation/ios) and [Android](/in-app-messaging/usage/installation/android).\n\n# What does it do\n\nFirebase In-App Messaging helps you to engage your apps active users by sending them targeted, contextual messages that encourage\nthem to use key app features. For example, you could send an in-app message to get users to subscribe, watch a video,\ncomplete a level, or buy an item. You can customize messages as cards, banners, modals, or images, and set up triggers\nso that they appear exactly when they'd benefit your users most.\n\n<Youtube id=\"5MRKpvKV2pg\" />\n\nReact Native Firebase provides support for both native Android & iOS integration with a simple JavaScript API.\n\n# Usage\n\nMost of the set up occurs on [Firebase Console](https://console.firebase.google.com/u/0/project/_/inappmessaging) in the\n`In-App Messaging` tab. You can create campaigns and customize elements such as Image, Banner, Modal & Cards to appear on\npredefined events (e.g. purchase). This involves no code for the developer to implement. Any published campaigns from the\nFirebase Console are automatically handled and displayed on your user's device.\n\nThis module provides a JavaScript API to allow greater control of the displaying of these messages.\n\n## Displaying Messages\n\nThe `setMessagesDisplaySuppressed` method allows you to control when messages can/cannot be displayed. Below illustrates\na use case for controlling the flow of messages:\n\n> The suppressed state is not persisted between restarts, so ensure it is called as early as possible.\n\n```jsx\nimport inAppMessaging from '@react-native-firebase/in-app-messaging';\n\nasync function bootstrap() {\n  await inAppMessaging().setMessagesDisplaySuppressed(true);\n}\n\nasync function onSetup(user) {\n  await setupUser(user);\n  // Allow user to receive messages now setup is complete\n  inAppMessaging().setMessagesDisplaySuppressed(false);\n}\n```\n\n# firebase.json\n\n## Disable collection of data\n\nIn App Messaging can be further configured to enable or disable automatic data collection for Firebase In-App Messaging.\n\nThis is useful for opt-in-first data flows, for example when dealing with GDPR compliance. This can be overridden in JavaScript.\nThis is possible by setting the below noted property on the `firebase.json` file at the root of your project directory.\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"in_app_messaging_auto_collection_enabled\": false\n  }\n}\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/messaging/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the messaging module\nyarn add @react-native-firebase/messaging\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\n> iOS requires further configuration before you can start receiving and sending\n> messages through Firebase. Read the documentation on how to [setup iOS with Firebase Cloud Messaging](/messaging/usage/ios-setup).\n>\n> use of the `sendMessage()` API and it's associated listeners requires a custom `XMPP` server. Read the documentation on how to [Messaging with XMPP](/messaging/usage/messaging-with-xmpp).\n\nIf you're using an older version of React Native without auto-linking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/messaging/usage/installation/ios) and [Android](/messaging/usage/installation/android).\n\n# What does it do\n\nReact Native Firebase provides native integration of Firebase Cloud Messaging (FCM) for both Android & iOS. FCM is a cost\nfree service, allowing for server-device and device-device communication. The React Native Firebase Messaging module provides\na simple JavaScript API to interact with FCM.\n\n<Youtube id=\"sioEY4tWmLI\" />\n\nThe module also provides basic support for displaying local notifications, to learn more view the [Notifications](/messaging/notifications) documentation.\n\n# Usage\n\n## iOS - Requesting permissions\n\niOS prevents messages containing notification (or 'alert') payloads from being displayed unless you have received explicit permission from the user.\n\n> To learn more about local notifications, view the [Notifications](/messaging/notifications) documentation.\n\nThis module provides a `requestPermission` method which triggers a native permission dialog requesting the user's permission:\n\n```js\nimport messaging from '@react-native-firebase/messaging';\n\nasync function requestUserPermission() {\n  const authStatus = await messaging().requestPermission();\n  const enabled =\n    authStatus === messaging.AuthorizationStatus.AUTHORIZED ||\n    authStatus === messaging.AuthorizationStatus.PROVISIONAL;\n\n  if (enabled) {\n    console.log('Authorization status:', authStatus);\n  }\n}\n```\n\nThe permissions API for iOS provides much more fine-grain control over permissions and how they're handled within your\napplication. To learn more, view the advanced [iOS Permissions](/messaging/ios-permissions) documentation.\n\nOn Android, you do not need to request user permission. This method can still be called on Android devices; however, and will always resolve successfully.\n\n## Receiving messages\n\nFCM messages can be sent to devices via a number of methods (see below). A message is simply a payload of data which can\nbe used however you see fit within your application. Common use-cases for handling messages could be:\n\n-   Displaying a notification (see [Notifications](/messaging/notifications)).\n-   Syncing message data silently on the device (e.g. via `AsyncStorage`).\n-   Updating the application's UI.\n\n> To learn about how to send messages to devices from your own server setup, view the\n> [Server Integration](/messaging/server-integration) documentation.\n\nDepending on the devices state, incoming messages are handled differently by the device and module. To understand these\nscenarios, it is first important to establish the various states a device can be in:\n\n| State          | Description                                                                                                                                                                                               |\n| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Foreground** | When the application is open and in view.                                                                                                                                                                 |\n| **Background** | When the application is open, however in the background (minimised). This typically occurs when the user has pressed the \"home\" button on the device or has switched to another app via the app switcher. |\n| **Quit**       | When the device is locked or application is not active or running. The user can quit an app by \"swiping it away\" via the app switcher UI on the device.                                                   |\n\nThe user must have opened the app before messages can be received. If the user force quits the app from the device settings, it must be re-opened again before receiving messages.\n\nDepending on the contents of the message, it's important to understand both how the device will handle the message (e.g. display a notification, or even ignore it) and also how the library sends events to your own listeners.\n\n### Message handlers\n\nThe device state and message contents determines which handler will be called:\n\n|                         | Foreground  | Background                                      | Quit                                            |\n| ----------------------- | ----------- | ----------------------------------------------- | ----------------------------------------------- |\n| **Notification**        | `onMessage` | `setBackgroundMessageHandler`                   | `setBackgroundMessageHandler`                   |\n| **Notification + Data** | `onMessage` | `setBackgroundMessageHandler`                   | `setBackgroundMessageHandler`                   |\n| **Data**                | `onMessage` | `setBackgroundMessageHandler` (**_see below_**) | `setBackgroundMessageHandler` (**_see below_**) |\n\n-   In cases where the message is data-only and the device is in the background or quit, both Android & iOS treat the message\n    as low priority and will ignore it (i.e. no event will be sent). You can however increase the priority by setting the `priority` to `high` (Android) and\n    `content-available` to `true` (iOS) properties on the payload.\n\nTo learn more about how to send these options in your message payload, view the Firebase documentation for your [FCM API implementation](https://firebase.google.com/docs/cloud-messaging/concept-options).\n\n### Notifications\n\nThe device state and message contents can also determine whether a [Notification](/messaging/notifications) will be displayed:\n\n|                         | Foreground      | Background      | Quit            |\n| ----------------------- | --------------- | --------------- | --------------- |\n| **Notification**        | Notification: ❌ | Notification: ✅ | Notification: ✅ |\n| **Notification + Data** | Notification: ❌ | Notification: ✅ | Notification: ✅ |\n| **Data**                | Notification: ❌ | Notification: ❌ | Notification: ❌ |\n\n### Foreground state messages\n\nTo listen to messages in the foreground, call the `onMessage` method inside of your application code. Code\nexecuted via this handler has access to React context and is able to interact with your application (e.g. updating the state or UI).\n\nFor example, the React Native [`Alert`](https://reactnative.dev/docs/alert) API could be used to display a new Alert\neach time a message is delivered'\n\n```js\nimport React, { useEffect } from 'react';\nimport { Alert } from 'react-native';\nimport messaging from '@react-native-firebase/messaging';\n\nfunction App() {\n  useEffect(() => {\n    const unsubscribe = messaging().onMessage(async remoteMessage => {\n      Alert.alert('A new FCM message arrived!', JSON.stringify(remoteMessage));\n    });\n\n    return unsubscribe;\n  }, []);\n}\n```\n\nThe `remoteMessage` property contains all of the information about the message sent to the device from FCM, including\nany custom data (via the `data` property) and notification data. To learn more, view the [`RemoteMessage`](/reference/messaging/remotemessage)\nAPI reference.\n\nIf the `RemoteMessage` payload contains a `notification` property when sent to the `onMessage` handler, the device\nwill not show any notification to the user. Instead, you could trigger a [local notification](/messaging/notifications#notifee---advanced-notifications)\nor update the in-app UI to signal a new notification.\n\n### Background & Quit state messages\n\nWhen the application is in a background or quit state, the `onMessage` handler will not be called when receiving messages.\nInstead, you need to setup a background callback handler via the `setBackgroundMessageHandler` method.\n\nTo setup a background handler, call the `setBackgroundMessageHandler` outside of your application logic as early as possible:\n\n```jsx\n// index.js\nimport { AppRegistry } from 'react-native';\nimport messaging from '@react-native-firebase/messaging';\nimport App from './App';\n\n// Register background handler\nmessaging().setBackgroundMessageHandler(async remoteMessage => {\n  console.log('Message handled in the background!', remoteMessage);\n});\n\nAppRegistry.registerComponent('app', () => App);\n```\n\nThe handler must return a promise once your logic has completed to free up device resources. It must not attempt to update\nany UI (e.g. via state) - you can however perform network requests, update local storage etc.\n\nThe `remoteMessage` property contains all of the information about the message sent to the device from FCM, including\nany custom data via the `data` property. To learn more, view the [`RemoteMessage`](/reference/messaging/remotemessage)\nAPI reference.\n\nIf the `RemoteMessage` payload contains a `notification` property when sent to the `setBackgroundMessageHandler` handler, the device\nwill have displayed a [notification](/messaging/notifications) to the user.\n\n#### Data-only messages\n\nWhen an incoming message is \"data-only\" (contains no `notification` option), both Android & iOS regard it as low priority\nand will prevent the application from waking (ignoring the message). To allow data-only messages to trigger the background\nhandler, you must set the \"priority\" to \"high\" on Android, and enable the `content-available` flag on iOS. For example,\nif using the Node.js [`firebase-admin`](https://www.npmjs.com/package/firebase-admin) package to send a message:\n\n```js\nadmin.messaging().sendToDevice(\n  [], // device fcm tokens...\n  {\n    data: {\n      owner: JSON.stringify(owner),\n      user: JSON.stringify(user),\n      picture: JSON.stringify(picture),\n    },\n  },\n  {\n    // Required for background/quit data-only messages on iOS\n    contentAvailable: true,\n    // Required for background/quit data-only messages on Android\n    priority: 'high',\n  },\n);\n```\n\nFor iOS specific \"data-only\" messages, the message must include the appropriate APNs headers as well as the `content-available` flag in order to trigger the background handler. For example, if using the Node.js [`firebase-admin`](https://www.npmjs.com/package/firebase-admin) package to send a \"data-only\" message to an iOS device:\n\n```js\nadmin.messaging().send({\n    data: {\n      //some data\n    },\n    apns: {\n      payload: {\n        aps: {\n          contentAvailable: true\n        }\n      },\n      headers: {\n        'apns-push-type': 'background',\n        'apns-priority': '5',\n        'apns-topic': '' // your app bundle identifier\n      }\n    },\n    //must include token, topic, or condition\n    //token: //device token\n    //topic: //notification topic\n    //condition: //notification condition\n});\n```\n\nView the [Sending Notification Requests to APNs](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/sending_notification_requests_to_apns/) documentation to learn more about APNs headers.\n\nThese options can be applied to all FCM messages. View the [Server Integration](/messaging/server-integration) documentation\nto learn more about other available SDKs.\n\n#### Background Application State\n\nAlthough the library supports handling messages in background/quit states, the underlying implementation on how this works is different on Android & iOS.\n\nOn Android, a [Headless JS](https://reactnative.dev/docs/headless-js-android) task (an Android only feature) is created that runs separately to your main React component; allowing your background handler code to run without mounting your root component.\n\nOn iOS however, when a message is received the device silently starts your application in a background state. At this point, your background handler (via `setBackgroundMessageHandler`) is triggered, but your root React component also gets mounted. This can be problematic for some users since any side-effects will be called inside of your app (e.g. `useEffects`, analytics events/triggers etc). To get around this problem,\nthe messaging module injects a `isHeadless` prop to your root component which you can conditionally use to render/do \"nothing\" if your app is launched in the background:\n\n```jsx\n// index.js\nimport { AppRegistry } from 'react-native';\nimport messaging from '@react-native-firebase/messaging';\n\nmessaging().setBackgroundMessageHandler(async remoteMessage => {\n  console.log('Message handled in the background!', remoteMessage);\n});\n\nfunction HeadlessCheck({ isHeadless }) {\n  if (isHeadless) {\n    // App has been launched in the background by iOS, ignore\n    return null;\n  }\n\n  return <App />;\n}\n\nfunction App{) {\n  // Your application\n}\n\nAppRegistry.registerComponent('app', () => HeadlessCheck);\n```\n\nOn Android, this prop will not exist.\n\n### Topics\n\nTopics are a mechanism which allow a device to subscribe and unsubscribe from named PubSub channels, all managed via FCM.\nRather than sending a message to a specific device by FCM token, you can instead send a message to a topic and any\ndevices subscribed to that topic will receive the message.\n\nTopics allow you to simplify FCM [server integration](/messaging/server-integration) as you do not need to keep a store of\ndevice tokens. There are however some things to keep in mind about topics:\n\n-   Messages sent to topics should not contain sensitive or private information. Do not create a topic for a specific user\n    to subscribe to.\n-   Topic messaging supports unlimited subscriptions for each topic.\n-   One app instance can be subscribed to no more than 2000 topics.\n-   The frequency of new subscriptions is rate-limited per project. If you send too many subscription requests in a short\n    period of time, FCM servers will respond with a 429 RESOURCE_EXHAUSTED (\"quota exceeded\") response. Retry with exponential backoff.\n-   A server integration can send a single message to multiple topics at once. This however is limited to 5 topics.\n\nTo learn more about how to send messages to devices subscribed to topics, view the [Send messages to topics](/messaging/server-integration#send-messages-to-topics)\ndocumentation.\n\n#### Subscribing to topics\n\nTo subscribe a device, call the `subscribeToTopic` method with the topic name:\n\n```js\nmessaging()\n  .subscribeToTopic('weather')\n  .then(() => console.log('Subscribed to topic!'));\n```\n\n#### Unsubscribing to topics\n\nTo unsubscribe from a topic, call the `unsubscribeFromTopic` method with the topic name:\n\n```js\nmessaging()\n  .unsubscribeFromTopic('weather')\n  .then(() => console.log('Unsubscribed fom the topic!'));\n```\n\n# firebase.json\n\nMessaging can be further configured to provide more control over how FCM is handled internally within your application.\n\n## Auto Registration (iOS)\n\nReact Native Firebase Messaging automatically registers the device with APNs to receive remote messages. If you need\nto manually control registration you can disable this via the `firebase.json` file:\n\n```json\n// <projectRoot>/firebase.json\n{\n  \"react-native\": {\n    \"messaging_ios_auto_register_for_remote_messages\": false\n  }\n}\n```\n\nOnce auto-registration is disabled you must manually call `registerDeviceForRemoteMessages` in your JavaScript code as\nearly as possible in your application startup;\n\n```js\nimport messaging from '@react-native-firebase/messaging';\n\nasync function registerAppWithFCM() {\n  await messaging().registerDeviceForRemoteMessages();\n}\n```\n\n## Auto initialization\n\nFirebase generates an Instance ID, which FCM uses to generate a registration token and which Analytics uses for data collection.\nWhen an Instance ID is generated, the library will upload the identifier and configuration data to Firebase. In most cases,\nyou do not need to change this behavior.\n\nIf you prefer to prevent Instance ID auto-generation, disable auto initialization for FCM and Analytics:\n\n```json\n// <projectRoot>/firebase.json\n{\n  \"react-native\": {\n    \"analytics_auto_collection_enabled\": false,\n    \"messaging_auto_init_enabled\": false\n  }\n}\n```\n\nTo re-enable initialization (e.g. once requested permission) call the `messaging().setAutoInitEnabled(true)` method.\n\n## Background handler timeout (Android)\n\nOn Android, a background event sent to `setBackgroundMessageHandler` has 60 seconds to resolve before it is automatically\ncanceled to free up device resources. If you wish to override this value, set the number of milliseconds in your config:\n\n```json\n// <projectRoot>/firebase.json\n{\n  \"react-native\": {\n    \"messaging_android_headless_task_timeout\": 30000\n  }\n}\n```\n\n## Notification Channel ID\n\nOn Android, any message which displays a [Notification](/messaging/notifications) use a default Notification Channel\n(created by FCM called \"Miscellaneous\"). This channel contains basic notification settings which may not be appropriate for\nyour application. You can change what Channel is used by updating the `messaging_android_notification_channel_id` property:\n\n```json\n// <projectRoot>/firebase.json\n{\n  \"react-native\": {\n    \"messaging_android_notification_channel_id\": \"high-priority\"\n  }\n}\n```\n\nCreating and managing Channels is outside of the scope of the React Native Firebase library, however external libraries\nsuch as [Notifee](https://notifee.app/react-native/docs/android/channels) can provide such functionality.\n\n## Notification Color\n\nOn Android, any messages which display a [Notification](/messaging/notifications) do not use a color to tint the content\n(such as the small icon, title etc). To provide a custom tint color, update the `messaging_android_notification_color` property\nwith a Android color resource name.\n\nThe library provides a set of default [HTML colors](https://www.w3schools.com/colors/colors_names.asp) (in lowercase) for ease, for example:\n\n```json\n// <projectRoot>/firebase.json\n{\n  \"react-native\": {\n    \"messaging_android_notification_color\": \"@color/hotpink\"\n  }\n}\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/messaging/usage/ios-setup.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\nIntegrating the Cloud Messaging module on iOS devices requires additional setup before you devices receive messages.\nThere are also a number of prerequisites which are required to be able to enable messaging:\n\n-   You must have an active [Apple Developer Account](https://developer.apple.com/membercenter/index.action).\n-   You must have a physical iOS device to receive messages.\n    -   Firebase Cloud Messaging integrates with the [Apple Push Notification service (APNs)](https://developer.apple.com/notifications/),\n        however APNs only works with real devices.\n\n# Configuring your app\n\nBefore your application can start to receive messages, you must explicitly enable \"Push Notifications\" and \"Background Modes\"\nwithin Xcode.\n\nOpen your project's workspace file via Xcode (found within the `/ios` directory). The file name is prefixed with your project name,\nfor example `/ios/myapp.xcworkspace`. Once open, follow the steps below:\n\n1.  Select your project.\n2.  Select the project target.\n3.  Select the \"Signing & Capabilities\" tab.\n\n![Example with Steps](https://images.prismic.io/invertase/c954c8ed-a6bf-42f3-9b1d-c9eac937f9ec_xcode-signing-tab.png?auto=format)\n\n## Enable Push Notifications\n\nNext the \"Push Notifications\" capability needs to be added to the project. This can be done via the \"Capability\" option on the\n\"Signing & Capabilities\" tab:\n\n1.  Click on the \"+ Capabilities\" button.\n2.  Search for \"Push Notifications\".\n\n![Enabling the Push Notification capability](https://images.prismic.io/invertase/d682a40c-07ab-4fce-90a7-fb4278643323_xcode-enable-push-notification.png?auto=format)\n\nOnce selected, the capability will be shown below the other enabled capabilities. If no option appears when searching, the\ncapability may already be enabled.\n\n## Enable Background Modes\n\nNext the \"Background Modes\" capability needs to be enabled, along with both the \"Background fetch\" and \"Remote notifications\" sub-modes.\nThis can be added via the \"Capability\" option on the \"Signing & Capabilities\" tab:\n\n1.  Click on the \"+ Capabilities\" button.\n2.  Search for \"Background Modes\".\n\n![Enabling the Background Modes capability](https://images.prismic.io/invertase/517e18ad-37a7-4f44-a89e-c5947ea3742e_xcode-enable-background-modes-capability.png?auto=compress,format)\n\nOnce selected, the capability will be shown below the other enabled capabilities. If no option appears when searching, the\ncapability may already be enabled.\n\nNow ensure that both the \"Background fetch\" and the \"Remote notifications\" sub-modes are enabled:\n\n![Enabling the sub-modes](https://images.prismic.io/invertase/3a618574-dd9f-4478-9f39-9834d142b2e5_xcode-background-modes-check.gif?auto=compress,format)\n\n# Linking APNs with FCM\n\nEven though FCM a has limited capability to work without linking with APNs, the below steps are strongly recommended\nto ensure the library works as expected. Without linking APNs, your device will not receive messages when in the background\nor when quit.\n\nA few steps are required:\n\n1.  [Registering a key](#1-registering-a-key).\n2.  [Registering an App Identifier](#2-registering-an-app-identifier).\n3.  [Generating a provisioning profile](#3-generating-a-provisioning-profile).\n\nAll of these steps require you to have access to your [Apple Developer](https://developer.apple.com/membercenter/index.action) account.\nOnce on the account, navigate to the [Certificates, Identifiers & Profiles](https://developer.apple.com/account/resources/certificates/list)\ntab on the account sidebar:\n\n![Certificates, Identifiers & Profiles menu item](https://images.prismic.io/invertase/c0a795c8-ebca-41c3-9a8d-23f09deb625f_apple-dev-tab.png?auto=format)\n\n## 1. Registering a key\n\nA key can be generated which gives the FCM full access over the Apple Push Notification service (APNs). On the \"Keys\" menu item,\nregister a new key. The name of the key can be anything, however you must ensure the APNs service\nis enabled:\n\n![Enable \"Apple Push Notification (APNs)\"](https://images.prismic.io/invertase/01fefe19-132f-4b88-8c17-9dc40357e4ce_apple-key.png?auto=format)\n\nClick \"Continue\" & then \"Save\". Once saved, you will be presented with a screen displaying the private \"Key ID\" & the ability\nto download the key. Copy the ID, and download the file to your local machine:\n\n![Copy Key ID & Download File](https://images.prismic.io/invertase/2c7f194c-10a9-4011-8f80-78b8fc521af8_app-key-final.png?auto=format)\n\nThe file & Key ID can now be added to your Firebase Project. On the [Firebase Console](https://console.firebase.google.com/project/_/settings/cloudmessaging),\nnavigate to the \"Project settings\" and select the \"Cloud Messaging\" tab. Select your iOS application under the \"iOS app configuration\" heading.\n\nUpload the downloaded file and enter the Key ID:\n\n![Upload the key & Key ID](https://images.prismic.io/invertase/7539b8ec-c310-40dd-91e5-69f19009786f_apple-fcm-upload-key.gif?auto=format)\n\n## 2. Registering an App Identifier\n\nFor messaging to work when your app is built for production, you must create a new App Identifier which is linked to the\napplication that you're developing.\n\nOn the \"Identifiers\" menu item, register a App Identifier. Select the \"App IDs\" option and click \"Continue\".\n\nThe following screen enables you to link the identifier to your application via the \"Bundle ID\". This is a unique string\nwhich was generated when starting your new React Native project. Your Bundle ID can be obtained within Xcode, under the\n\"General\" tab for your project target:\n\n![Project Bundle ID](https://images.prismic.io/invertase/7108ff7f-ce94-4452-851d-fa5dde668a9a_xcode-bundle-id.png?auto=compress,format)\n\nNext, follow these steps:\n\n1.  Enter a description for the identifier.\n2.  Enter the \"Bundle ID\" copied from Xcode.\n3.  Scroll down and enable the \"Push Notifications\" capability (along with any others your app uses).\n\n![Create an identifier](https://images.prismic.io/invertase/0e711691-ccd2-43ab-9c0c-7696b6790153_apple-identifier.gif?auto=format)\n\nSave the identifier, it'll be used when creating a provisioning profile in the next step.\n\n## 3. Generating a provisioning profile\n\nA provisioning profile enables signed communicate between Apple and your application. Since messaging can only be used on\nreal devices, a signed certificate ensures that the app being installed on a device is genuine and has the correct\npermissions enabled.\n\nOn the \"Profiles\" menu item, register a new Profile. Select the \"iOS App Development\" checkbox and click \"Continue\".\n\nIf you followed [Step 2](#2-registering-an-app-identifier) correctly, your App Identifier will be available in the drop down\nprovided:\n\n![Select the App Identifier](https://images.prismic.io/invertase/9fd060fa-4afa-4dfe-8eaa-4b1156cdd912_apple-select-app-id.png?auto=format)\n\nClick \"Continue\". On the next screen you will be presented with the Certificates on your Apple account. Select the user\ncertificates that you wish to assign this provisioning profile too. If you have not yet created a Certificate, you must set\none up on your account.\n\nTo create a new Certificate, follow the [Apple documentation](https://help.apple.com/developer-account/#/devbfa00fef7). Once\nthe Certificate has been downloaded, upload it to the Apple Developer console via the \"Certificates\" menu item.\n\nThe created provisioning profile can now be used when building your application (in both debug and release mode) onto a\nreal device (using Xcode). Back within Xcode, select your project target and select the \"Signing & Capabilities\" tab.\nIf Xcode (via Preferences) is linked to your Apple Account, Xcode can automatically sync the profile created above. Otherwise,\nyou must manually add the profile from the Apple Developer console:\n\n1.  Select the project.\n2.  Select the project target.\n3.  Assign the provisioning profile.\n\n![Assign the provisioning profile via Xcode](https://images.prismic.io/invertase/50349f49-19a0-45f4-b899-e6bc3015c509_xcode-assign-profile.png?auto=format)\n\n# Next steps\n\nOnce the above has been completed, you're ready to get started receiving messages on your iOS device for both\ntesting and production. To rebuild your app, run the following command:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/messaging/usage/messaging-with-xmpp.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n## Introduction\n\nThis is a reference for using the Firebase Messaging service. Although methods are provided for sending and receiving message, additional configuration is needed to ensure a working solution.\n\n> A custom solution is needed to exchange messages between devices (including the message sender device)\n> please ensure a solution from this article has been configured to successfully send and receive messages from a device.\n\nThe following describes how to set up a server to handle messages, including...\n\n-   A custom XMPP server with XCS for receiving messages.\n-   Firebase admin for sending messages.\n\nSo what are we going to do?\n\n1.  Send a message from a client device.\n2.  Intercept using a custom XMPP server.\n3.  Push the message to Firebase using firebase-admin\n4.  Receive the message and acknowledge on other connected devices.\n\n## Why can't I send and receive messages?\n\nA common instance involves an implementation similar to the following.\n\n```js\nfirebase.messaging().onMessage(message => {\n  console.log('Received a message');\n});\n\nfirebase.messaging().onMessageSent(message => {\n  console.log('Sent a message');\n});\n\nfirebase.messaging().onSendError(message => {\n  console.log('Received an Error');\n});\n\nfirebase.messaging().sendMessage({\n  data: {\n    foo: 'bar',\n  },\n});\n```\n\nAlthough correct, none of the listeners will acknowledge a `message` or `error`.\n\nPermissions are limited on the client meaning an additional solution is required to communicate between `FCM` and any connected devices.\n\n## How do I receive messages?\n\nThis is where a custom server based on Node XCS\n\nBelow is an example of how to configure a custom XMPP server using `node-xcs`.\n\n```js\nconst Sender = require('node-xcs').Sender;\n\nasync function operation() {\n  return new Promise((resolve, reject) => {\n    console.log('Listening >>>');\n\n    // Enter firebase credentials here. {SenderID, ServerKey}\n    var xcs = new Sender('XXXXXXXX', 'XXXXXXXX');\n\n    xcs.start();\n\n    xcs.on('message', function(messageId, from, data, category) {\n      console.log('received message', messageId, from, data, category);\n    });\n\n    xcs.on('receipt', function(messageId, from, data, category) {\n      console.log('received receipt', arguments);\n    });\n\n    xcs.on('error', e => console.warn('XMPP error.', e));\n  });\n}\n\nasync function app() {\n  await operation();\n}\n\napp();\n```\n\n## How do I send messages?\n\nAn ability to post to firebase with the correct permissions, for this we can use `Firebase-admin`.\n\n```js\nconst admin = require('firebase-admin');\nconst serviceAccount = require('./service-account.json');\n\n(async () => {\n  admin.initializeApp({\n    credential: admin.credential.cert(serviceAccount),\n    databaseURL: 'XXXXXXXX',\n  });\n\n  await admin.messaging().send({\n    token: 'XXXXXXX',\n    data: {\n      foo: 'bar',\n    },\n  });\n})();\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-natural-language/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the ml-natural-language module\nyarn add @react-native-firebase/ml-natural-language\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/ml-natural-language/usage/installation/ios) and [Android](/ml-natural-language/usage/installation/android).\n\n# What does it do\n\nThe React Native Firebase ML Natural Language module supports [Smart Replies](https://firebase.google.com/docs/ml-kit/generate-smart-replies)\n& [Language Identification](https://firebase.google.com/docs/ml-kit/identify-languages) provided by Firebase ML kit.\nAt this moment, the [Translation](https://firebase.google.com/docs/ml-kit/translation) module is not supported\n\n<Youtube id=\"ejrn_JHksws\" />\n\nSmart reply can automatically generate relevant replies to messages. It helps your users respond to messages quickly,\nand makes it easier to reply to messages on devices with limited input capabilities.\n\nLanguage identification can be used to determine the language of a string of text. It can be useful when working with\nuser-provided text, which often doesn't come with any language information.\n\n# Usage\n\nEach services requires enabling before it can be used within your app. The sections below show how to enable the models\nfor each service and usage examples of each.\n\n## Smart Replies\n\nThe [Smart Replies](https://firebase.google.com/docs/ml-kit/generate-smart-replies) service from Firebase allows you to\ngenerate suggested replies based on a list of on-going conversation data.\n\nBefore using the API, the Smart Reply model must be installed on your device. To enable installation of the model, set\nthe `ml_natural_language_smart_reply_model` to `true` in your `firebase.json` file:\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"ml_natural_language_smart_reply_model\": true\n  }\n}\n```\n\nOnce added, rebuild your application:\n\n```bash\n// For Android\nnpx react-native run-android\n\n// For iOS\ncd ios/ && pod install\nnpx react-native run-ios\n```\n\nOnce complete, the `suggestReplies` method allows you to generate potential replies by providing it with an array of text input(s)\nwhich may generate three responses per input as example below:\n\n```jsx\nconst replies = await firebase\n  .naturalLanguage()\n  .suggestReplies([\n    { text: 'Hey, long time no speak!' },\n    { text: 'I know right, it has been a while..', userId: '123', isLocalUser: false },\n    { text: 'We should catchup some time!' },\n    { text: 'Definitely, how about we go for lunch this week?', userId: '123', isLocalUser: false },\n  ]);\n\nreplies.forEach(reply => {\n  console.log(reply.text);\n});\n```\n\nEach array item an is an instance of a [`TextMessage`](/reference/ml-natural-language/textmessage). At a minimum you\nmust provide the a `text` property. To help the Machine Learning service identify various users in the conversation, you\ncan set the `isLocalUser` flag to `false` if the message is from an external user, along with a unique ID.\n\nOnce returned, if the service is able to generate suggested replies you can iterate over the response to extract the `text`\nproperty from the returned [`SuggestedReply`](/reference/ml-natural-language/suggestedreply) instance.\n\n## Identify language\n\nThe [Language Identification](https://firebase.google.com/docs/ml-kit/identify-languages) service from Firebase allows you to\nidentify a language from any given string of text.\n\nBefore using the API, the Language Identification model must be installed on your device. To enable installation of the model, set\nthe `ml_natural_language_language_id_model` to `true` in your `firebase.json` file:\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"ml_natural_language_language_id_model\": true\n  }\n}\n```\n\nOnce added, rebuild your application:\n\n```bash\n// For Android\nnpx react-native run-android\n\n// For iOS\ncd ios/ && pod install\nnpx react-native run-ios\n```\n\nThe `identifyLanguage` method allows then allows you to identify a language, for example:\n\n```jsx\nconst language = await firebase.naturalLanguage().identifyLanguage('Hello there. General Kenobi.');\n\nconsole.log('Identified language: ', language); // en\n```\n\n# firebase.json\n\nAdd any of the keys indicated below to your `firebase.json` file at the root of your project directory, and set them to\ntrue to enable them. All models and APIs are disabled (false) by default.\n\n> If you are manually linking on iOS (e.g. not using CocoaPods) then it's up to you to manage these models and dependencies\n> yourself - firebase.json support is only for Android and iOS (via Pods).\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    // Language Identification\n    \"ml_natural_language_language_id_model\": true,\n    // Smart Replies\n    \"ml_natural_language_smart_reply_model\": true\n  }\n}\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-vision/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the ml-vision module\nyarn add @react-native-firebase/ml-vision\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/ml-vision/usage/installation/ios) and [Android](/ml-vision/usage/installation/android).\n\n# What does it do\n\nML Kit Vision makes use of Firebase's Machine Learning Kit's [Text Recognition](https://firebase.google.com/docs/ml-kit/recognize-text),\n[Face Detection](https://firebase.google.com/docs/ml-kit/detect-faces), [Barcode Scanning](https://firebase.google.com/docs/ml-kit/read-barcodes),\n[Image Labeling](https://firebase.google.com/docs/ml-kit/label-images) & [Landmark Recognition](https://firebase.google.com/docs/ml-kit/recognize-landmarks) features.\n\nDepending on the service, it is possible to perform Machine Learning on both the local device or cloud.\n\n<Youtube id=\"ejrn_JHksws\" />\n\n## Support table\n\nThe table below outlines the current module support for each available service, and whether they are available on local device,\ncloud or both.\n\n| API                                                                                   | Cloud Model | On Device |\n| ------------------------------------------------------------------------------------- | ----------- | --------- |\n| [Text Recognition](https://firebase.google.com/docs/ml-kit/recognize-text)            | ✅           | ✅         |\n| [Document Text Recognition](https://firebase.google.com/docs/ml-kit/recognize-text))  | ✅           |           |\n| [Face Detection](https://firebase.google.com/docs/ml-kit/detect-faces)                |             | ✅         |\n| [Barcode Scanning](https://firebase.google.com/docs/ml-kit/read-barcodes)             |             | ✅         |\n| [Image Labeling](https://firebase.google.com/docs/ml-kit/label-images)                | ✅           | ✅         |\n| [Landmark Recognition](https://firebase.google.com/docs/ml-kit/recognize-landmarks)   |             | ✅         |\n| [AutoML Vision Edge](https://firebase.google.com/docs/ml-kit/automl-image-labeling)   | ❌           | ❌         |\n| [Object Detection/Tracking](https://firebase.google.com/docs/ml-kit/object-detection) | ❌           | ❌         |\n\n# Usage\n\nTo get started, you can find the documentation for the individual ML Kit Vision services below:\n\n-   [Text Recognition](/ml-vision/text-recognition).\n-   [Landmark Recognition](/ml-vision/landmark-recognition).\n-   [Barcode Scanning](/ml-vision/barcode-scanning).\n-   [Image ](/ml-vision/image-labeling).\n-   [Face Detection](/ml-vision/face-detection).\n\n# firebase.json\n\n## Enabling models\n\nTo be able to use the on-device Machine Learning models you'll need to enable them. This is possible by setting the below noted properties\non the `firebase.json` file at the root of your project directory.\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    // on device face detection\n    \"ml_vision_face_model\": true,\n    // on device text recognition\n    \"ml_vision_ocr_model\": true,\n    // on device barcode detection\n    \"ml_vision_barcode_model\": true,\n\n    // on device image labeling\n    \"ml_vision_label_model\": true,\n    \"ml_vision_image_label_model\": true\n  }\n}\n```\n\nThe models are disabled by default to help control app size.\n\nSince only models enabled here will be compiled into the application, any changes to this file require a rebuild.\n\n```bash\n# For Android\nnpx react-native run-android\n\n# For iOS\ncd ios/ && pod install --repo-update\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/perf/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the performance monitoring module\nyarn add @react-native-firebase/perf\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/perf/usage/installation/ios) and [Android](/perf/usage/installation/android).\n\n## Add the Performance Monitoring Plugin\n\nOn Android, you need to install the Google Performance Monitoring Plugin which enables automatic\nHTTPS network request monitoring.\n\nAdd the plugin to your `/android/build.gradle` file as a dependency:\n\n```groovy\nbuildscript {\n    dependencies {\n        // ...\n        classpath 'com.google.firebase:perf-plugin:1.3.1'\n    }\n```\n\nApply the plugin via the `/android/app/build.gradle` file (at the top):\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'com.google.firebase.firebase-perf'\n```\n\n# What does it do\n\nPerformance Monitoring allows you to gain insight into key performance characteristics within your React Native application.\nIt provides a simple API to track custom trace and HTTP request metrics.\n\n<Youtube id=\"0EHSPFvH7vk\" />\n\nReview and analyze that data in the Firebase console. Performance Monitoring helps you to understand where and when the\nperformance of your app can be improved so that you can use that information to fix performance issues.\n\nPerformance Monitoring package automatically traces events and metrics which are sent to Firebase. For more information\non the automatic traces, please see the Firebase Performance Monitoring [documentation](https://firebase.google.com/docs/perf-mon/auto_duration-traces-metrics_ios-android).\nThe package also allows you to performance monitor custom aspects to your application like network requests & task specific\napp code. All performance metrics are available on your Firebase [console](https://console.firebase.google.com/u/0/) performance tab.\n\n# Usage\n\n## Custom tracing\n\nBelow is how you would measure the amount of time it would take to complete a specific task in your app code.\n\n```jsx\nimport perf from '@react-native-firebase/perf';\n\nasync function customTrace() {\n  // Define & start a trace\n  const trace = await perf().startTrace('custom_trace');\n\n  // Define trace meta details\n  trace.putAttribute('user', 'abcd');\n  trace.putMetric('credits', 30);\n\n  // Stop the trace\n  await trace.stop();\n}\n```\n\n## HTTP Request Tracing\n\nBelow illustrates you would measure the latency of a HTTP request.\n\n```jsx\nimport perf from '@react-native-firebase/perf';\n\nasync function getRequest(url) {\n  // Define the network metric\n  const metric = await perf().newHttpMetric(url, 'GET');\n\n  // Define meta details\n  metric.putAttribute('user', 'abcd');\n\n  // Start the metric\n  await metric.start();\n\n  // Perform a HTTP request and provide response information\n  const response = await fetch(url);\n  metric.setHttpResponseCode(response.status);\n  metric.setResponseContentType(response.headers.get('Content-Type'));\n  metric.setResponsePayloadSize(response.headers.get('Content-Length'));\n\n  // Stop the metric\n  await metric.stop();\n\n  return response.json();\n}\n\n// Call API\ngetRequest('https://api.com').then(json => {\n  console.log(json);\n});\n```\n\n# firebase.json\n\n## Disable Auto-Initialization\n\nThe Performance Monitoring module will automatically start collecting data once it is installed. To disable this behavior,\nset the `perf_auto_collection_enabled` flag to `false`:\n\n```json\n// <project-root>/firebase.json\n{\n  \"react-native\": {\n    \"perf_auto_collection_enabled\": false\n  }\n}\n```\n\nTo re-enable collection (e.g. once you have the users consent), call the `setPerformanceCollectionEnabled` method:\n\n```js\nawait firebase.perf().setPerformanceCollectionEnabled(true);\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/remote-config/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the remote-config module\nyarn add @react-native-firebase/remote-config\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/remote-config/usage/installation/ios) and [Android](/remote-config/usage/installation/android).\n\n# What does it do\n\nRemote Config allows you to change the appearance and/or functionality of your app without requiring an app update.\nRemote Config values are input into the Firebase console and accessible via a JavaScript API. This gives you full control\nover when and how these Remote Config values are applied and affect your application.\n\n<Youtube id=\"_CXXVFPO6f0\" />\n\n# Usage\n\nTo get started, you need to define some parameters over on the [Firebase Console](https://console.firebase.google.com/project/_/config).\n\n![Firebase Console - Remote Config](https://images.prismic.io/invertase/87dc40bd-0da7-4d83-a87c-b12698b9818f_remote-config-console.png?auto=compress,format)\n\nEach parameter is assigned a unique \"key\" and values. The values can be broken down to target specific conditions (such as Android or iOS). In the above example,\nonly Android devices would receive `enabled` for the `awesome_new_feature` parameter.\n\n## Default values\n\nBefore fetching the parameters from Firebase, it is first important to set some default values. Default values\nhelp ensure that your application code runs as expected in scenarios where the device has not yet retrieved the values.\n\nAn example of this is having no network or you have not yet fetched them within your own code.\n\nSetting default values helps to ensure that both the local device & Firebase servers are both in sync. Call the\n`setDefaults` method early on in your application:\n\n```js\nimport React, { useEffect } from 'react';\nimport remoteConfig from '@react-native-firebase/remote-config';\n\nfunction App() {\n  useEffect(() => {\n    remoteConfig()\n      .setDefaults({\n        awesome_new_feature: 'disabled',\n      })\n      .then(() => {\n        console.log('Default values set.');\n      });\n  }, []);\n}\n```\n\n## Fetch & Activate\n\nBefore reading the values from Firebase, we first need to pull them from Firebase (fetching) & then enable them on\nthe device (activating). The `fetchAndActivate` API combines both tasks into a single flow:\n\n```js\nimport remoteConfig from '@react-native-firebase/remote-config';\n\nremoteConfig()\n  .setDefaults({\n    awesome_new_feature: 'disabled',\n  })\n  .then(() => remoteConfig().fetchAndActivate())\n  .then(activated => {\n    if (activated) {\n      console.log('Defaults set, fetched & activated!');\n    } else {\n      console.log('Defaults set, however activation failed.');\n    }\n  });\n```\n\n## Reading values\n\nWith the defaults set and the remote values fetched from Firebase, we can now use the `getValue` method to get the\nvalue and use a number of methods to retrieve the value (same API as Firebase Remote Config web SDK)\n\n```js\nconst awesomeNewFeature = remoteConfig().getValue('awesome_new_feature');\n\n// resolves value to string\nif (awesomeNewFeature.asString() === 'enabled') {\n  enableAwesomeNewFeature();\n}\n// resolves value to number\n// if it is not a number or source is 'static', the value will be 0\nif (awesomeNewFeature.asNumber() === 5) {\n  enableAwesomeNewFeature();\n}\n// resolves value to boolean\n// if value is any of the following: '1', 'true', 't', 'yes', 'y', 'on', it will resolve to true\n// if source is 'static', value will be false\nif (awesomeNewFeature.asNumber() === true) {\n  enableAwesomeNewFeature();\n}\n```\n\nThe API also provides a `getAll` method to read all parameters at once rather than by key:\n\n```js\nconst parameters = remoteConfig().getAll();\n\nObject.entries(parameters).forEach(([key, parameter]) => {\n  console.log('Key: ', key);\n  console.log('Value: ', parameter.value);\n});\n```\n\n### Value source\n\nWhen a value is read, it contains source data about the parameter. As explained above, if a value is read before it has\nbeen fetched & activated then the value will fallback to the default value set. If you need to validate whether the value\nreturned from the module was local or remote, the `getSource()` method can be conditionally checked:\n\n```js\nconst awesomeNewFeature = remoteConfig().getValue('awesome_new_feature');\n\nif (awesomeNewFeature.getSource() === 'remote') {\n  console.log('Parameter value was from the Firebase servers.');\n} else if (awesomeNewFeature.getSource() === 'default') {\n  console.log('Parameter value was from a default value.');\n} else {\n  console.log('Parameter value was from a locally cached value.');\n}\n```\n\n## Caching\n\nAlthough Remote Config is a data-store, it is not designed for frequent reads - Firebase heavily caches the parameters\n(default is 12 hours). By design, this prevents the values being able to change frequently and potentially cause users\nconfusion.\n\nYou can however specify your own cache length by specifically calling the `fetch` method with the number of seconds to\ncache the values for:\n\n```js\n// Fetch and cache for 5 minutes\nawait remoteConfig().fetch(300);\n```\n\nTo bypass caching fully, you can pass a value of `0`. Be warned Firebase may start to reject your requests\nif values are requested too frequently.\n\nYou can also apply a global cache frequency by calling the `setConfigSettings` method with the `minimumFetchIntervalMillis` property:\n\n```js\nawait remoteConfig().setConfigSettings({\n  minimumFetchIntervalMillis: 30000,\n});\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/storage/usage/index.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Installation\n\nThis module requires that the `@react-native-firebase/app` module is already setup and installed. To install the \"app\" module, view the\n[Getting Started](/) documentation.\n\n```bash\n# Install & setup the app module\nyarn add @react-native-firebase/app\n\n# Install the storage module\nyarn add @react-native-firebase/storage\n\n# If you're developing your app using iOS, run this command\ncd ios/ && pod install\n```\n\nIf you're using an older version of React Native without autolinking support, or wish to integrate into an existing project,\nyou can follow the manual installation steps for [iOS](/storage/usage/installation/ios) and [Android](/storage/usage/installation/android).\n\n# What does it do\n\nStorage is built for app developers who need to store and serve user-generated content, such as photos or videos.\n\n<Youtube id=\"_tyjqozrEPY\" />\n\nYour data is stored in a Google Cloud Storage bucket, an exabyte scale object storage solution with high availability and\nglobal redundancy. Storage lets you securely upload these files directly from mobile devices, handling spotty networks with ease.\n\n# Usage\n\nYour files are stored in a Google Cloud Storage bucket. The files in this bucket are presented in a hierarchical structure,\njust like a file system. By creating a reference to a file, your app gains access to it. These references can then be\nused to upload or download data, get or update metadata or delete the file. A reference can either point to a specific\nfile or to a higher level node in the hierarchy.\n\nThe Storage module also provides support for multiple buckets.\n\nYou can view your buckets on the [Firebase Console](https://console.firebase.google.com/project/_/storage/files).\n\n## Creating a reference\n\nA reference is a local pointer to some file on your bucket. This can either be a file which already exists, or one\nwhich does not exist yet. To create a reference, use the `ref` method:\n\n```js\nimport storage from '@react-native-firebase/storage';\n\nconst reference = storage().ref('black-t-shirt-sm.png');\n```\n\nYou can also specify a file located in a deeply nested directory:\n\n```js\nconst reference = storage().ref('/images/t-shirts/black-t-shirt-sm.png');\n```\n\n## Upload a file\n\nTo upload a file directly from the users device, the `putFile` method on a reference accepts a string path to the file\non the users device. For example, you may be creating an app which uploads users photos. The React Native Firebase\nlibrary provides [Utils](/app/utils) to help identify device directories:\n\n```jsx\nimport React, { useEffect } from 'react';\nimport { View, Button } from 'react-native';\n\nimport { utils } from '@react-native-firebase/app';\nimport storage from '@react-native-firebase/storage';\n\nfunction App() {\n  // create bucket storage reference to not yet existing image\n  const reference = firebase.storage().ref('black-t-shirt-sm.png');\n\n  return (\n    <View>\n      <Button\n        onPress={async () => {\n          // path to existing file on filesystem\n          const pathToFile = `${utils.FilePath.PICTURES_DIRECTORY}/black-t-shirt-sm.png`;\n          // uploads file\n          await reference.putFile(pathToFile);\n        }}\n      />\n    </View>\n  );\n}\n```\n\n### Tasks\n\nThe `putFile` method returns a [`Task`](/reference/storage/task), which if required, allows you to hook into information\nsuch as the current upload progress:\n\n```js\nconst task = reference.putFile(pathToFile);\n\ntask.on('state_changed', taskSnapshot => {\n  console.log(`${taskSnapshot.bytesTransferred} transferred out of ${taskSnapshot.totalBytes}`);\n});\n\ntask.then(() => {\n  console.log('Image uploaded to the bucket!');\n});\n```\n\nA task also provides the ability to pause & resume on-going operations:\n\n```js\nconst task = reference.putFile(pathToFile);\n\ntask.pause();\n\n// Sometime later...\ntask.resume();\n```\n\n## Download URLs\n\nA common use-case for Cloud Storage is to use it as a global Content Delivery Network (CDN) for your images. When uploading\nfiles to a bucket, they are not automatically available for consumption via a HTTP URL. To generate a new Download URL, you\nneed to call the `getDownloadURL` method on a reference:\n\n```js\nimport storage from '@react-native-firebase/storage';\n\nconst url = await storage()\n  .ref('images/profile-1.png')\n  .getDownloadURL();\n```\n\n> Images uploaded manually via the Firebase Console automatically generate a download URL.\n\n## Listing files & directories\n\nIf you wish to view a full list of the current files & directories within a particular bucket reference, you can use\nthe `list` method. The results are however paginated, and if more results are available you can pass a page token into the request:\n\n```js\nimport storage from '@react-native-firebase/storage';\n\nfunction listFilesAndDirectories(reference, pageToken) {\n  return reference.list({ pageToken }).then(result => {\n    // Loop over each item\n    result.items.forEach(ref => {\n      console.log(ref.fullPath);\n    });\n\n    if (result.nextPageToken) {\n      return listFilesAndDirectories(reference, result.nextPageToken);\n    }\n\n    return Promise.resolve();\n  });\n}\n\nconst reference = storage().ref('images');\n\nlistFilesAndDirectories(reference).then(() => {\n  console.log('Finished listing');\n});\n```\n\n## Security\n\nBy default your bucket will come with rules which allows only authenticated users on your project to access it. You can\nhowever fully customize the security rules to your own applications requirements.\n\nTo learn more, view the [Storage Security](https://firebase.google.com/docs/storage/security/start) documentation\non the Firebase website.\n\n## Multiple Buckets\n\nA single Firebase project can have multiple storage buckets. The module will use the default bucket if no bucket argument\nis passed to the `storage` instance. To switch buckets, provide the module with the `gs://` bucket URL found on the\nFirebase Console, under Storage > Files.\n\n```js\nimport storage, { firebase } from '@react-native-firebase/storage';\n\nconst defaultStorageBucket = storage();\nconst secondaryStorageBucket = firebase.app().storage('gs://my-secondary-bucket.appspot.com');\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/admob/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_admob'\nproject(':@react-native-firebase_admob').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/admob/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Firebase module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_admob\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.admob.ReactNativeFirebaseAdmobPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseAdmobPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/admob/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Add the `RNFBAdMob` Pod\n\nAdd the `RNFBAdMob` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBAdMob', :path => '../node_modules/@react-native-firebase/admob'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBAdMob` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/analytics/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_analytics'\nproject(':@react-native-firebase_analytics').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/analytics/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Firebase module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_analytics\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\n```java\nimport io.invertase.firebase.analytics.ReactNativeFirebaseAnalyticsPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseAnalyticsPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/analytics/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Add the Pod\n\nAdd the `RNFBAnalytics` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBAnalytics', :path => '../node_modules/@react-native-firebase/analytics'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBAnalytics` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n\n# Device Identification\n\nIf you would like to enable Firebase Analytics to generate automatic audience metrics for iOS (as it does by default in Android), you must link additional iOS libraries, [as documented by the Google Firebase team](https://support.google.com/firebase/answer/6318039). Specifically you need `libAdIdAccess.a` and `AdSupport.framework`.\n\nThe way to do this using CocoaPods is to add this to your `Podfile` (though please use [the most current Pod version](https://cocoapods.org/pods/GoogleIDFASupport) supported by React Native Firebase):\n\n```ruby\n# ...\ntarget 'app' do\n  # ...\n  pod 'RNFBAnalytics', :path => '../node_modules/@react-native-firebase/analytics'\n  pod 'GoogleIDFASupport', '~> 3.14.0'\nend\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/auth/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_auth'\nproject(':@react-native-firebase_auth').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/auth/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Firebase module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_auth\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.auth.ReactNativeFirebaseAuthPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseAuthPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/auth/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Add the Pod\n\nAdd the `RNFBAuth` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  #  ...\n  pod 'RNFBAuth', :path => '../node_modules/@react-native-firebase/auth'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBAuth` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/crashlytics/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Installation\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_crashlytics'\nproject(':@react-native-firebase_crashlytics').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/crashlytics/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Firebase Crashlytics module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_crashlytics\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.crashlytics.ReactNativeFirebaseCrashlyticsPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseCrashlyticsPackage(),\n```\n\n## 4. Additional Android Setup\n\nAndroid requires additional steps in order to complete setup. View the [Android Setup](crashlytics/android-setup) documentation\nfor more information.\n\n## 5. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/crashlytics/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Add the Pod\n\nAdd the `RNFBCrashlytics` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # Add the RNFBCrashlytics podspec to your app target:\n  pod 'RNFBCrashlytics', :path => '../node_modules/@react-native-firebase/crashlytics'\nend\n```\n\n## 2. iOS Additional Steps\n\niOS requires additional steps in order to complete setup. View the [iOS Setup](crashlytics/ios-setup) documentation\nfor more information.\n\n## 3. Update Pods & rebuild the project\n\nYou may need to update your local Pods repository in order for the Pods to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/database/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Linking\n\nThe following steps are only required if your environment does not have access to React Native auto-linking.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_database'\nproject(':@react-native-firebase_database').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/database/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Firebase module dependency to your `/android/app/build.gradle` file:\n\n```groovy\n// ..\ndependencies {\n  // ..\n  implementation project(path: \":@react-native-firebase_database\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.database.ReactNativeFirebaseDatabasePackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseDatabasePackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/database/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Linking\n\nThe following steps are only required if you are using React Native &lt;= 0.59 or need to manually integrate the library.\n\n## 1. Add the `RNFBAnalytics` Pod\n\nAdd the `RNFBDatabase` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  #  ...\n  pod 'RNFBDatabase', :path => '../node_modules/@react-native-firebase/database'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBDatabase` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/dynamic-links/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_dynamic-links'\nproject(':@react-native-firebase_dynamic-links').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/dynamic-links/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Dynamic Links module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_dynamic-links\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.dynamiclinks.ReactNativeFirebaseDynamicLinksPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseDynamicLinksPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/dynamic-links/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Add the Pod\n\nAdd the `RNFBDynamicLinks` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBDynamicLinks', :path => '../node_modules/@react-native-firebase/dynamic-links'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBDynamicLinks` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/firestore/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if you are using React Native without auto-linking (&lt;= 0.59) or you need to manually integrate the library.\n\n## 1. Add Firestore to Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_firestore'\nproject(':@react-native-firebase_firestore').projectDir = new File(rootProject.projectDir, '../node_modules/@react-native-firebase/firestore/android')\n```\n\n## 2. Add Firestore to App Gradle Dependencies\n\nAdd the React Native Firebase module dependency to your `/android/app/build.gradle` file:\n\n```groovy\n// ..\ndependencies {\n  // ..\n  implementation project(':@react-native-firebase_firestore')\n}\n```\n\n## 3. Add Firestore to Main Android Application:\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\n```java\nimport io.invertase.firebase.firestore.ReactNativeFirebaseFirestorePackage;\n```\n\nAdd the package to the registry:\n\n````java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseFirestorePackage(),\n```// ..\n````\n\nIn some scenarios, your Android build may fail with the `app:mergeDexDebug` error. This required that multidex is enabled\nfor your application. To learn more, read the [Enabling Multidex](/firestore/enabling-multidex) documentation.\n\n## 4. Rebuild your project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/firestore/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Linking\n\nThe following steps are only required if your environment does not have access to React Native auto-linking (&lt;= 0.59) or you need to manually integrate the library.\n\n## 1. Add the Pod\n\nAdd the `RNFBFirestore` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBFirestore', :path => '../node_modules/@react-native-firebase/firestore'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBFirestore` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/functions/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native auto-linking.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_functions'\nproject(':@react-native-firebase_functions').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/functions/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Functions module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  ...\n  implementation project(path: \":@react-native-firebase_functions\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.functions.ReactNativeFirebaseFunctionsPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseFunctionsPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/functions/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Linking\n\nThe following steps are only required if your environment does not have access to React Native auto-linking.\n\n## 1. Add the `RNFBFunctions` Pod\n\nAdd the `RNFBFunctions` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBFunctions', :path => '../node_modules/@react-native-firebase/functions'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBFunctions` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/iid/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_iid'\nproject(':@react-native-firebase_iid').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/iid/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Functions module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_iid\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.iid.ReactNativeFirebaseIidPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseIidPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/iid/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Add the Pod\n\nAdd the `RNFBIid` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBIid', :path => '../node_modules/@react-native-firebase/iid'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBIid` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/in-app-messaging/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_in-app-messaging'\nproject(':@react-native-firebase_in-app-messaging').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/in-app-messaging/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Functions module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_inAppMessaging\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.fiam.ReactNativeFirebaseFiamPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseFiamPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/in-app-messaging/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Add the Pod\n\nAdd the `RNFBInAppMessaging` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  ...\n  pod 'RNFBInAppMessaging', :path => '../node_modules/@react-native-firebase/in-app-messaging'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBInAppMessaging` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/messaging/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Linking\n\nThe following steps are only required if your environment does not have access to React Native auto-linking.\n\n## 1. Update Gradle Settings\n\nAdd the following to your project's `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_messaging'\nproject(':@react-native-firebase_messaging').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/messaging/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Functions module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_messaging\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\n### 3.1 Import the package\n\nAdd the following underneath\n`import com.facebook.react.ReactActivity;`:\n\n```java\nimport io.invertase.firebase.messaging.ReactNativeFirebaseMessagingPackage;\n```\n\n### 3.2 Add the package to the registry\n\nAdd the following within the `MainActivity` class:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseMessagingPackage(),\n}\n```\n\n> If the method `getPackages()` already exists on the class in your project, then instead only add `new ReactNativeFirebaseMessagingPackage(),` to the returned list.\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/messaging/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native auto-linking.\n\n## 1. Add the Pod\n\nAdd the `RNFBMessaging` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBMessaging', :path => '../node_modules/@react-native-firebase/messaging'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBMessaging` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-natural-language/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_ml-natural-language'\nproject(':@react-native-firebase_ml-natural-language').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/ml-natural-language/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Functions module dependency to your `/android/app/build.gradle` file:\n\n```groovy\n// ..\ndependencies {\n  // ..\n  implementation project(path: \":@react-native-firebase_ml-natural-language\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.perf.ReactNativeFirebaseMLNaturalLanguagePackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseMLNaturalLanguagePackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-natural-language/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Add the Pod\n\nAdd the `RNFBMLNaturalLanguage` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBMLNaturalLanguage', :path => '../node_modules/@react-native-firebase/ml-natural-language'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBMLNaturalLanguage` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-vision/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_ml-vision'\nproject(':@react-native-firebase_ml-vision').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/ml-vision/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Functions module dependency to your `/android/app/build.gradle` file:\n\n```groovy\n// ..\ndependencies {\n  // ..\n  implementation project(path: \":@react-native-firebase_ml-vision\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.perf.ReactNativeFirebaseMLVisionPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseMLVisionPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/ml-vision/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Add the Pod\n\nAdd the `RNFBMLVision` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBMLVision', :path => '../node_modules/@react-native-firebase/ml-vision'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBMLVision` Pod to be installed in your project:\n\n```bash\n$ cd /ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/perf/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_perf'\nproject(':@react-native-firebase_perf').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/perf/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Functions module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_perf\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.perf.ReactNativeFirebasePerfPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebasePerfPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/perf/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Add the Pod\n\nAdd the `RNFBPerf` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBPerf', :path => '../node_modules/@react-native-firebase/perf'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBPerf` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/remote-config/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Add Remote Config to Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_config'\nproject(':@react-native-firebase_config').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/remote-config/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Functions module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  implementation project(path: \":@react-native-firebase_config\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.config.ReactNativeFirebaseConfigPackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseConfigPackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/remote-config/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Add the Pod\n\nAdd the `RNFBRemoteConfig` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBRemoteConfig', :path => '../node_modules/@react-native-firebase/remote-config'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBRemoteConfig` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/storage/usage/installation/android.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# Android Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Update Gradle Settings\n\nAdd the following to your projects `/android/settings.gradle` file:\n\n```groovy\ninclude ':@react-native-firebase_storage'\nproject(':@react-native-firebase_storage').projectDir = new File(rootProject.projectDir, './../node_modules/@react-native-firebase/storage/android')\n```\n\n## 2. Update Gradle Dependencies\n\nAdd the React Native Functions module dependency to your `/android/app/build.gradle` file:\n\n```groovy\ndependencies {\n  // ...\n  implementation project(path: \":@react-native-firebase_storage\")\n}\n```\n\n## 3. Add package to the Android Application\n\nImport and apply the React Native Firebase module package to your `/android/app/src/main/java/**/MainApplication.java` file:\n\nImport the package:\n\n```java\nimport io.invertase.firebase.storage.ReactNativeFirebaseStoragePackage;\n```\n\nAdd the package to the registry:\n\n```java\nprotected List<ReactPackage> getPackages() {\n  return Arrays.asList(\n    new MainReactPackage(),\n    new ReactNativeFirebaseStoragePackage(),\n```\n\n## 4. Rebuild the project\n\nOnce the above steps have been completed, rebuild your Android project:\n\n```bash\nnpx react-native run-android\n```\n"
    },
    {
        "data": {},
        "messages": [],
        "history": [
            "docs/storage/usage/installation/ios.md"
        ],
        "cwd": "/Users/darren/projects/invertase/react-native-firebase",
        "contents": "\n\n# iOS Manual Installation\n\nThe following steps are only required if your environment does not have access to React Native\nauto-linking.\n\n## 1. Add the Pod\n\nAdd the `RNFBStorage` Pod to your projects `/ios/Podfile`:\n\n```ruby\ntarget 'app' do\n  # ...\n  pod 'RNFBStorage', :path => '../node_modules/@react-native-firebase/storage'\nend\n```\n\n## 2. Update Pods & rebuild the project\n\nYou may need to update your local Pods in order for the `RNFBStorage` Pod to be installed in your project:\n\n```bash\n$ cd ios/\n$ pod install --repo-update\n```\n\nOnce the Pods have installed locally, rebuild your iOS project:\n\n```bash\nnpx react-native run-ios\n```\n"
    }
]